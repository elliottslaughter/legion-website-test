<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Introduction to the Legion Mapper API &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction to the Legion Mapper API">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/mapper/index.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/mapper/index.html">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="icon" sizes="16x16" href="/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" href="/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" href="/images/favicon/favicon-48x48.png">
<link rel="icon" sizes="96x96" href="/images/favicon/favicon-96x96.png">
<link rel="icon" sizes="144x144" href="/images/favicon/favicon-144x144.png">
<link rel="icon" sizes="192x192" href="/images/favicon/favicon-192x192.png">
<link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
<link rel="apple-touch-icon-precomposed" sizes="192x192" href="/images/favicon/apple-icon-precomposed.png">
<meta name="msapplication-config" content="/images/favicon/browserconfig.xml" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<link rel="manifest" href="/images/favicon/manifest.json">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/overview/" >Overview</a></li>
		        
				<li><a href="/starting/" >Getting Started</a></li>
		        
				<li><a href="/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/events/" >Events</a></li>
		        
				<li><a href="/documentation/" >Documentation</a></li>
		        
				<li><a href="/publications/" >Publications</a></li>
		        
				<li><a href="/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <a href="https://www.stanford.edu/"><img src="/images/logos/stanford.png" class="bio-photo" alt="Stanford University logo"></a>
<a href="https://www6.slac.stanford.edu/"><img src="/images/logos/slac.jpg" class="bio-photo" alt="SLAC National Accelerator Laboratory logo"></a>
<a href="https://www.lanl.gov/"><img src="/images/logos/los-alamos.png" class="bio-photo" alt="Los Alamos National Laboratory logo"></a>
<a href="https://www.nvidia.com/"><img src="/images/logos/nvidia.png" class="bio-photo" alt="NVIDIA logo"></a>
<a href="https://www.rdworldonline.com/rd-100-award-winners-announced-in-analytical-test-it-electrical-categories/"><img src="/images/logos/rd100.png" class="bio-photo" alt="Winner of the R&D 100 Award"></a>

<h3>Legion</h3>
<p>High Productivity High Performance Computing</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>



  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Introduction to the Legion Mapper API</h1>
    <div class="article-wrap" itemprop="text">
      <p>A Legion mapper is a C++ object that handles callbacks from the Legion runtime as part of the execution of a Legion application. Mapper callbacks are performed whenever a “policy” decision has to be made regarding how best to map the Legion application to the the target machine. The callback interface is defined by a pure virtual interface defined by the Legion::Mapper class. Every mapper object must inherit from this interface either directly or through a sub-class. The most common way this is done is by inheriting from the Legion::Mapping::DefaultMapper class which provides default implementations of all the mapper callbacks and then selectively overriding particular methods. However, there is nothing preventing a mapper from implementing the Legion::Mapper interface directly.</p>

<p>The rest of this introduction reviews how to create and implement a custom mapper. We also encourage readers to review the detailed comments for each mapper call in legion_mapping.h.</p>

<p>Finally note this is a work in progress and subject to updates.</p>

<ul>
  <li><a href="#Mapper-registration">Mapper Registration</a></li>
  <li><a href="#Callback-model">Callback Model</a>
    <ul>
      <li><a href="#Machine-model">Machine Model</a></li>
      <li><a href="#Task-launch">Task Launch</a></li>
      <li><a href="#Mapping">Mapping</a></li>
      <li><a href="#Load-balancing">Load Balancing</a></li>
      <li><a href="#Message-passing">Message Passing</a></li>
      <li><a href="#Must-epoch-launches">Must Epoch Launches</a></li>
      <li><a href="#Mappable-data-annotations">MappableData Annotations</a></li>
    </ul>
  </li>
</ul>

<h2 id="mapper-registration">Mapper Registration</h2>

<p>By default, the Legion runtime will create one instance of the Legion::Mapping::DefaultMapper class for each processor in the machine. The default mappers are registered with mapper ID ‘0’. Before starting Legion, applications can record a “registration callback” function with the runtime. This callback function will be invoked after the runtime is created but before any application task is run. Registration functions can register new mapper implementations with alternative mapper IDs or even replace the default mapper for mapper ID ‘0’.</p>

<p>Here is an example of replacing the default mapper with a custom mapper. This code belongs in the source file for the custom mapper.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">create_mappers</span><span class="p">(</span><span class="n">Machine</span> <span class="n">machine</span><span class="p">,</span> <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">local_procs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;*</span> <span class="n">procs_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;*</span> <span class="n">sysmems_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&gt;*</span> <span class="n">sysmem_local_procs</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span> <span class="n">Memory</span><span class="o">&gt;*</span> <span class="n">proc_sysmems</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span> <span class="n">Memory</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span> <span class="n">Memory</span><span class="o">&gt;*</span> <span class="n">proc_regmems</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span> <span class="n">Memory</span><span class="o">&gt;</span><span class="p">();</span>
  
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Machine</span><span class="o">::</span><span class="n">ProcessorMemoryAffinity</span><span class="o">&gt;</span> <span class="n">proc_mem_affinities</span><span class="p">;</span>
  <span class="n">machine</span><span class="p">.</span><span class="n">get_proc_mem_affinity</span><span class="p">(</span><span class="n">proc_mem_affinities</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">proc_mem_affinities</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Machine</span><span class="o">::</span><span class="n">ProcessorMemoryAffinity</span><span class="o">&amp;</span> <span class="n">affinity</span> <span class="o">=</span> <span class="n">proc_mem_affinities</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span>
        <span class="o">||</span> <span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Processor</span><span class="o">::</span><span class="n">IO_PROC</span>
        <span class="o">||</span> <span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Processor</span><span class="o">::</span><span class="n">PY_PROC</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">affinity</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Memory</span><span class="o">::</span><span class="n">SYSTEM_MEM</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">proc_sysmems</span><span class="p">)[</span><span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">affinity</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">proc_regmems</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">proc_regmems</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
          <span class="p">(</span><span class="o">*</span><span class="n">proc_regmems</span><span class="p">)[</span><span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">affinity</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">affinity</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Memory</span><span class="o">::</span><span class="n">REGDMA_MEM</span><span class="p">)</span>
        <span class="p">(</span><span class="o">*</span><span class="n">proc_regmems</span><span class="p">)[</span><span class="n">affinity</span><span class="p">.</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">affinity</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Processor</span><span class="p">,</span> <span class="n">Memory</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">proc_sysmems</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">proc_sysmems</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">procs_list</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">sysmem_local_procs</span><span class="p">)[</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span>
       <span class="n">sysmem_local_procs</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">sysmem_local_procs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">sysmems_list</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">LifelineMapper</span><span class="o">*</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LifelineMapper</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">get_mapper_runtime</span><span class="p">(),</span>
                                                <span class="n">machine</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="s">"lifeline_mapper"</span><span class="p">,</span>
                                                <span class="n">procs_list</span><span class="p">,</span>
                                                <span class="n">sysmems_list</span><span class="p">,</span>
                                                <span class="n">sysmem_local_procs</span><span class="p">,</span>
                                                <span class="n">proc_sysmems</span><span class="p">,</span>
                                                <span class="n">proc_regmems</span><span class="p">);</span>
    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">replace_default_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">register_lifeline_mapper</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">add_registration_callback</span><span class="p">(</span><span class="n">create_mappers</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Mappers can only be registered for application processors on the “local” node. As part of the registration callback, Legion provides a set of the local application processor names for use in registering mappers. A given mapper object can be registered with one or more local application processors. The mappers registered with an application processor will handle all mapper callbacks related to that application processor. While mapper objects are registered with application processors they most commonly run on “utility” processors that are used for runtime meta-work. If there are multiple utility processors, then there is a tradeoff between parallelism and programmability: registering one mapper for all local processors can make programming easier, but may cause synchronization bottlenecks depending on the mapper synchronization model (see section 3.1). It is up to the user to determine how they would like to develop their mapper and register it for a particular application.</p>

<h2 id="callback-model">Callback Model</h2>

<p>The mapper API is a series of callbacks that a mapper must support. For any given operation (e.g. task) launched onto the Legion runtime, a well-defined sequence of mapper callbacks will be performed. It is possible that this sequence of callbacks will actually be performed over several different mapper objects depending on how the mapper chooses to distribute the operation (e.g. move a task around).</p>

<p>TODO: some examples of the state machines for mapper calls for different operation kinds</p>

<h3 id="machine-model">Machine Model</h3>

<p>In order to provide the mapper with context about the machine being targeted, each mapper object is passed a ‘Machine’ object at construction. This Machine object provides an interface for querying various properties of the machine including the number and kinds of different processors as well as the number, kinds, and capacities of different memories. The Machine object also permits queries about the topology of the machine including which processors can directly access a given memory and which memories can be directly to from other memories. We therefore encourage users to think of the machine as a graph of processors and memories, with edges between processor-memory and memory-memory pairs that can directly access each other. The Machine object also has an interface for querying the bandwidth and latency available on each of these edges. This detailed knowledge of the machine is what enables Legion mappers to make intelligent mapping decisions for a given machine.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Machine</span><span class="o">::</span><span class="n">ProcessorMemoryAffinity</span><span class="o">&gt;</span> <span class="n">proc_mem_affinities</span><span class="p">;</span>
<span class="n">machine</span><span class="p">.</span><span class="n">get_proc_mem_affinity</span><span class="p">(</span><span class="n">proc_mem_affinities</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The machine model is currently static, processors and memories persist from the beginning to the end of the run. In future work the machine model will be dynamic and components can be added or removed during a run.</p>

<h3 id="synchronization">Synchronization</h3>

<p>Since multiple callbacks may want to access the same mapper concurrently, we allow mappers to select a synchronization model that controls if/how concurrent mapper calls are performed to a single mapper object. Each mapper object will receive a call to the get_mapper_sync_model mapper call almost immediately after it is registered with the runtime. There are three possible models to choose from. The SERIALIZED_NON_REENTRANT_MAPPER_MODEL permits a single mapper call to be running in a given mapper object at a time and all mapper calls execute atomically. This is the easiest model to program to but permits the least concurrency. SERIALIZED_REENTRANT_MAPPER_MODEL also guarantees that a single mapper call is executing in a given mapper object at a time, but mapper calls are not guaranteed to execute atomically. If a mapper with this synchronization model calls back into the runtime then the mapper call may be preempted and other mapper calls could execute before the preempted call resumes. The CONCURRENT_MAPPER_MODEL is a truly concurrent mapper in which multiple mapper calls may be executing at the same time in the same mapper object. In this model it is the programmer’s responsibility to use mapper locking methods to control access to shared data structures.</p>

<p>Here is an example of defining the synchronization model:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>  <span class="n">MapperSyncModel</span> <span class="n">get_mapper_sync_model</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SERIALIZED_REENTRANT_MAPPER_MODEL</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="task-launch">Task Launch</h3>

<p>The lifecycle of a task starts with select_task_options. When a Legion application first launches a task the runtime invokes select_task_options in the mapper for the processor that launched the task.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_task_options</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>    <span class="n">ctx</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>            <span class="n">task</span><span class="p">,</span>
                                   <span class="n">TaskOptions</span><span class="o">&amp;</span>           <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If the task is a single task then output.initial_proc defines the processor to launch it on. If output.inline_task is true the task will be inlined directly into the parent task using the parent tasks regions. If output.stealable is true then the task can be stolen for load balancing. If output.map_locally is true then map_task(task) will be called in the current mapper rather than in the mapper for the destination processor. If output.parent_priority is modified then the parent task will change priority if this is permitted by the mapper for the parent task.</p>

<p>If the task is an index task launch the runtime calls slice_task to divide the index task into a set of slices that contain point tasks. One slice corresponds to one target processor.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">slice_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>      <span class="n">ctx</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">SliceTaskInput</span><span class="o">&amp;</span>    <span class="n">input</span><span class="p">,</span>
                        <span class="n">SliceTaskOutput</span><span class="o">&amp;</span>         <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SliceTaskInput</span> <span class="p">{</span>
  <span class="n">IndexSpace</span>                             <span class="n">domain_is</span><span class="p">;</span>
  <span class="n">Domain</span>                                 <span class="n">domain</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">SliceTaskOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskSlice</span><span class="o">&gt;</span>                 <span class="n">slices</span><span class="p">;</span>
  <span class="kt">bool</span>                                   <span class="n">verify_correctness</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Each TaskSlice object identifies an index space (i.e., a subregion of the original domain) and a target processor. All of the point tasks for the subregion will be mapped by the mapper for the target processor.</p>

<p>If slice.stealable is true the task can be stolen for load balancing. If slice.recurse is true the mapper for the target processor will invoke slice_task again with the slice as input. Here is sample code to create a stealable slice:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">TaskSlice</span> <span class="n">slice</span><span class="p">;</span>
<span class="n">slice</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">slice_subregion</span><span class="p">;</span>
<span class="n">slice</span><span class="p">.</span><span class="n">proc</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">target_proc_index</span><span class="p">];</span>
<span class="n">slice</span><span class="p">.</span><span class="n">recurse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">slice</span><span class="p">.</span><span class="n">stealable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">slices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="mapping">Mapping</h3>

<p>If a mapper has one or more tasks that are ready to execute it calls select_tasks_to_map. This method can copy tasks to the map_tasks list to indicate the task should be mapped by this mapper. The method can copy tasks to the relocate_tasks list to indicate the task should be mapped by a mapper for a different processor. If it does neither the task stays in the ready list.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_tasks_to_map</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>          <span class="n">ctx</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">SelectMappingInput</span><span class="o">&amp;</span>    <span class="n">input</span><span class="p">,</span>
                                 <span class="n">SelectMappingOutput</span><span class="o">&amp;</span>         <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SelectMappingInput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                  <span class="n">ready_tasks</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">SelectMappingOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                   <span class="n">map_tasks</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*</span><span class="p">,</span><span class="n">Processor</span><span class="o">&gt;</span>         <span class="n">relocate_tasks</span><span class="p">;</span>
  <span class="n">MapperEvent</span>                             <span class="n">deferral_event</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If select_tasks_to_map does not map or relocate any tasks then it must assign a MapperEvent to deferral_event. When another mapper call triggers the MapperEvent the mapper will invoke select_tasks_to_map. The mapper will also invoke select_tasks_to_map if new tasks are added to the ready list. Here is an example of creating a MapperEvent:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">MapperEvent</span> <span class="n">defer_select_tasks_to_map</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">defer_select_tasks_to_map</span><span class="p">.</span><span class="n">exists</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">defer_select_tasks_to_map</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">create_mapper_event</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">output</span><span class="p">.</span><span class="n">deferral_event</span> <span class="o">=</span> <span class="n">defer_select_tasks_to_map</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here is sample code for triggering and clearing the event:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">if</span><span class="p">(</span><span class="n">defer_select_tasks_to_map</span><span class="p">.</span><span class="n">exists</span><span class="p">()){</span>
  <span class="n">MapperEvent</span> <span class="n">temp_event</span> <span class="o">=</span> <span class="n">defer_select_tasks_to_map</span><span class="p">;</span>
  <span class="n">defer_select_tasks_to_map</span> <span class="o">=</span> <span class="n">MapperEvent</span><span class="p">();</span>
  <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">trigger_mapper_event</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">temp_event</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When a task is ready to execute the runtime invokes map_task. This allows the programmer to select and rank the PhysicalInstances to be mapped and the target processors on which the task may run. Other capabilities are to choose the task variant, to create profiling requests, set the task priority, and indicate that postmap operation is needed.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">map_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>     <span class="n">ctx</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">MapTaskInput</span><span class="o">&amp;</span>      <span class="n">input</span><span class="p">,</span>
                      <span class="n">MapTaskOutput</span><span class="o">&amp;</span>           <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">MapTaskInput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span>     <span class="n">valid_instances</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span>                           <span class="n">premapped_regions</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">MapTaskOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span>     <span class="n">chosen_instances</span><span class="p">;</span> 
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span>                          <span class="n">target_procs</span><span class="p">;</span>
  <span class="n">VariantID</span>                                       <span class="n">chosen_variant</span><span class="p">;</span> <span class="c1">// = 0 </span>
  <span class="n">ProfilingRequest</span>                                <span class="n">task_prof_requests</span><span class="p">;</span>
  <span class="n">ProfilingRequest</span>                                <span class="n">copy_prof_requests</span><span class="p">;</span>
  <span class="n">TaskPriority</span>                                    <span class="n">profiling_priority</span><span class="p">;</span>
  <span class="n">TaskPriority</span>                                    <span class="n">task_priority</span><span class="p">;</span>  <span class="c1">// = 0</span>
  <span class="kt">bool</span>                                            <span class="n">postmap_task</span><span class="p">;</span> <span class="c1">// = false</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here is example code to create a profiling request to indicate task completion:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">ProfilingRequest</span> <span class="n">completionRequest</span><span class="p">;</span>
<span class="n">completionRequest</span><span class="p">.</span><span class="n">add_measurement</span><span class="p">();</span>
<span class="n">output</span><span class="p">.</span><span class="n">task_prof_requests</span> <span class="o">=</span> <span class="n">completionRequest</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If map_task sets output.postmap_task = true the runtime invokes postmap_task when the task completes. This lets the programmer create additional copies of the output in different memories.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">PostMapInput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span>     <span class="n">mapped_regions</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span>     <span class="n">valid_instances</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">PostMapOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span>     <span class="n">chosen_instances</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">postmap_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>      <span class="n">ctx</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">PostMapInput</span><span class="o">&amp;</span>      <span class="n">input</span><span class="p">,</span>
                          <span class="n">PostMapOutput</span><span class="o">&amp;</span>           <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="load-balancing">Load Balancing</h3>

<p>The mapper supports a work stealing model for load balancing. Mappers that want to steal tasks identify the processors to steal from in select_steal_targets. Processors appear in the blacklist if a previous steal request failed due to lack of available work. Processors are removed from the blacklist automatically when they gain new work.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">SelectStealingInput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span>                     <span class="n">blacklist</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">SelectStealingOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span>                     <span class="n">targets</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_steal_targets</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>         <span class="n">ctx</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">SelectStealingInput</span><span class="o">&amp;</span>  <span class="n">input</span><span class="p">,</span>
                                  <span class="n">SelectStealingOutput</span><span class="o">&amp;</span>       <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If a mapper is selected as a steal target the runtime invokes permit_steal_request. This allows the mapper to decide which tasks are to be stolen as a result of the request.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">StealRequestInput</span> <span class="p">{</span>
  <span class="n">Processor</span>                               <span class="n">thief_proc</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                <span class="n">stealable_tasks</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">StealRequestOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                   <span class="n">stolen_tasks</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">permit_steal_request</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>         <span class="n">ctx</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">StealRequestInput</span><span class="o">&amp;</span>    <span class="n">input</span><span class="p">,</span>
                                  <span class="n">StealRequestOutput</span><span class="o">&amp;</span>         <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="message-passing">Message Passing</h3>

<p>Mappers can communicate among themselves using message passing. Messages are guaranteed to be delivered but are not guaranteed to be in order.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="n">send_message</span><span class="p">(</span><span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
                  <span class="kt">size_t</span> <span class="n">message_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">message_kind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
               <span class="kt">size_t</span> <span class="n">message_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">message_kind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">radix</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">MapperMessage</span> <span class="p">{</span>
  <span class="n">Processor</span>                               <span class="n">sender</span><span class="p">;</span>
  <span class="kt">unsigned</span>                                <span class="n">kind</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>                             <span class="n">message</span><span class="p">;</span>
  <span class="kt">size_t</span>                                  <span class="n">size</span><span class="p">;</span>
  <span class="kt">bool</span>                                    <span class="n">broadcast</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle_message</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>           <span class="n">ctx</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">MapperMessage</span><span class="o">&amp;</span>          <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="must-epoch-launches">Must Epoch Launches</h3>

<p>If the application uses must epoch launches the runtime invokes map_must_epoch. This allows the mapper to control which processors the epoch tasks are mapped on and which physical regions are mapped with them.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">MappingConstraint</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                    <span class="n">constrained_tasks</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span>                       <span class="n">requirement_indexes</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">MapMustEpochInput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Task</span><span class="o">*&gt;</span>                    <span class="n">tasks</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MappingConstraint</span><span class="o">&gt;</span>              <span class="n">constraints</span><span class="p">;</span>
  <span class="n">MappingTagID</span>                                <span class="n">mapping_tag</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">MapMustEpochOutput</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span>                      <span class="n">task_processors</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PhysicalInstance</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">constraint_mappings</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">map_must_epoch</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>           <span class="n">ctx</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">MapMustEpochInput</span><span class="o">&amp;</span>      <span class="n">input</span><span class="p">,</span>
                            <span class="n">MapMustEpochOutput</span><span class="o">&amp;</span>           <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="mappabledata-annotations">MappableData Annotations</h3>

<p>Every Mappable object (a Task is a Mappable object) has an auxiliary data field that can be used to hold application-specific data. This is usually used to help in debugging by attaching unique identifiers to the different tasks. Here is an example of assigning a unique id that persists across task stealing operations:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">Task</span> <span class="n">task</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">shiftBits</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">taskSerialId</span><span class="p">)</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">taskId</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_proc</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">shiftBits</span><span class="p">)</span> <span class="o">+</span> <span class="n">taskSerialId</span><span class="o">++</span><span class="p">;</span>
<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">update_mappable_data</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">taskId</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">taskId</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You would normally do this in two places: in select_task_options for newly created tasks; and in map_task for point tasks that are generated from index task launches in slice_task. In the second case it is necessary to distinguish between point tasks and individual tasks using <code class="language-plaintext highlighter-rouge">task.is_index_space == true</code> to identify the point tasks. Note that point tasks will enter map_task with mappable data that is copied from the parent index task launch. So you can record the parent task before overwriting the mappable data with the new identifier.</p>


    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2023 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>
