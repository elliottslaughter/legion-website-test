<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Custom Mappers &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Custom Mappers">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/legion-website-test/tutorial/custom_mappers.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/legion-website-test/tutorial/custom_mappers.html">
<link href="/legion-website-test/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/legion-website-test/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/legion-website-test/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/legion-website-test/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="icon" sizes="16x16" href="/legion-website-test/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" href="/legion-website-test/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" href="/legion-website-test/images/favicon/favicon-48x48.png">
<link rel="icon" sizes="96x96" href="/legion-website-test/images/favicon/favicon-96x96.png">
<link rel="icon" sizes="144x144" href="/legion-website-test/images/favicon/favicon-144x144.png">
<link rel="icon" sizes="192x192" href="/legion-website-test/images/favicon/favicon-192x192.png">
<link rel="apple-touch-icon" sizes="57x57" href="/legion-website-test/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/legion-website-test/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/legion-website-test/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/legion-website-test/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/legion-website-test/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/legion-website-test/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/legion-website-test/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/legion-website-test/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/legion-website-test/images/favicon/apple-icon-180x180.png">
<link rel="apple-touch-icon-precomposed" sizes="192x192" href="/legion-website-test/images/favicon/apple-icon-precomposed.png">
<meta name="msapplication-config" content="/legion-website-test/images/favicon/browserconfig.xml" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<link rel="manifest" href="/legion-website-test/images/favicon/manifest.json">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/legion-website-test/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/legion-website-test/overview/" >Overview</a></li>
		        
				<li><a href="/legion-website-test/starting/" >Getting Started</a></li>
		        
				<li><a href="/legion-website-test/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/legion-website-test/events/" >Events</a></li>
		        
				<li><a href="/legion-website-test/documentation/" >Documentation</a></li>
		        
				<li><a href="/legion-website-test/publications/" >Publications</a></li>
		        
				<li><a href="/legion-website-test/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <a href="https://www.stanford.edu/"><img src="/legion-website-test/images/logos/stanford.png" class="bio-photo" alt="Stanford University logo"></a>
<a href="https://www6.slac.stanford.edu/"><img src="/legion-website-test/images/logos/slac.jpg" class="bio-photo" alt="SLAC National Accelerator Laboratory logo"></a>
<a href="https://www.lanl.gov/"><img src="/legion-website-test/images/logos/los-alamos.png" class="bio-photo" alt="Los Alamos National Laboratory logo"></a>
<a href="https://www.nvidia.com/"><img src="/legion-website-test/images/logos/nvidia.png" class="bio-photo" alt="NVIDIA logo"></a>
<a href="https://www.rdworldonline.com/rd-100-award-winners-announced-in-analytical-test-it-electrical-categories/"><img src="/legion-website-test/images/logos/rd100.png" class="bio-photo" alt="Winner of the R&D 100 Award"></a>

<h3>Legion</h3>
<p>High Productivity High Performance Computing</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>



  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Custom Mappers</h1>
    <div class="article-wrap" itemprop="text">
      <p>One of the primary goals of Legion is to
make it easy to remap applications onto
different architectures. Up to this point
all of our applications have been mapped
by the <code class="language-plaintext highlighter-rouge">DefaultMapper</code> implementation that
is distributed with Legion. The <code class="language-plaintext highlighter-rouge">DefaultMapper</code>
class provides heuristics for performing mappings
that are good, but regularly not optimal for
specific applications or architectures. By
creating custom mappers programmers can make
application- or architecture-specific mapping
decisions. Furthermore, the mapping interface
isolates mapping decisions from application
code, allowing the same Legion applications
to be targeted at different architectures without
having to modify the application source code.</p>

<p>A common problem encountered when writing code
for large distributed and heterogeneous machines
is how mapping impacts correctness. In Legion, any valid set of
mapping decisions will result in the same answer being computed, and
therefore, if an application produces the correct answer on one
machine, it will produce the same answer regardless of the machine or
mapping strategy used. Mapping can therefore be considered orthogonal
to the correct execution of the program.</p>

<p>To introduce how to write a custom mapper we’ll
implement two custom mappers. The first will be
an adversarial mapper that makes random mapping
decisions designed to stress-test the Legion runtime.
We’ll also have the adversarial mapper report the chosen
mapping decisions (which will change with each run
of the application) to further emphasize the orthogonality
of mapping decisions from correctness. The second mapper
that we’ll create will be used for partitioning to decide
how many sub-regions to create using <em>tunable</em>
variables. The application code for DAXPY is
identical to the code from
an <a href="/legion-website-test/tutorial/partitioning.html">earlier example</a>
and is therefore omitted. We only show the new
code required for creating and implementing the
custom mappers.</p>

<h4 id="mapper-objects-and-registration">Mapper Objects and Registration</h4>

<p>Mappers are classes that implement the interface
declared in the abstract class <code class="language-plaintext highlighter-rouge">Mapper</code>. Legion provides a default
implementation of this interface defined by the
<code class="language-plaintext highlighter-rouge">DefaultMapper</code> class. The default mapper allows
applications to be developed without being
concerned with mapping decisions. Once correctness
has been established, programmers can implement
custom mappers to achieve higher performance.
Custom mappers can either extend the <code class="language-plaintext highlighter-rouge">DefaultMapper</code>
class or implement the <code class="language-plaintext highlighter-rouge">Mapper</code> interface from
scratch. In this example, we extend the
<code class="language-plaintext highlighter-rouge">DefaultMapper</code> to create both our <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>
(line 20) and <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> (line 41). We then override
four of the mapping interface calls in the <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>
(lines 25-38) and one in the <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> (lines 46-49)
to show how they work. We’ll describe the semantics of these calls and our implementations
of them in the coming sections.</p>

<p>Mappers objects are instantiated after the
Legion runtime starts but before the application
begins executing. To instantiate mappers, the application
registers a callback function for the runtime to
invoke prior to beginning execution of the application. In this
example we create the <code class="language-plaintext highlighter-rouge">mapper_registration</code>
function (lines 52-62) and register the function
with runtime using the static method <code class="language-plaintext highlighter-rouge">add_registration_callback</code>
of <code class="language-plaintext highlighter-rouge">Runtime</code> (line 469). All callback
functions must have the same type as the <code class="language-plaintext highlighter-rouge">mapper_registration</code>
function so that the runtime can pass the
necessary parameters for creating new mappers.</p>

<p>In Legion, each kind of
mapper is identified by a <code class="language-plaintext highlighter-rouge">MapperID</code> (an unsigned integer).
There should be one instance of each kind of mapper
for every processor in the system. Having a single
instance for each processor guarantees that processors
can map tasks in parallel without needing to be
concerned about contention for a single mapper object. Note that in
general, mappers are permitted to be stateful, and users of the
mapping API can choose what state to track and how to manage that
state.</p>

<p>When <code class="language-plaintext highlighter-rouge">mapper_registration</code> callback function is invoked, it can
instantiate an arbitrary number of mappers and kinds of mappers.
For each kind, it should create one instance for
every processor in the set <code class="language-plaintext highlighter-rouge">local_procs</code> which
describes the set of processors on the local node. Note that in a
multi-node execution of Legion, this callback will be issued once on
every node in the system. The <code class="language-plaintext highlighter-rouge">MapperID</code> 0 is reserved for
the <code class="language-plaintext highlighter-rouge">DefaultMapper</code>, but applications can replace the default with their own mapper
by calling <code class="language-plaintext highlighter-rouge">replace_default_mapper</code> (lines 57-58). By replacing the default mapper, any tasks in the application will
automatically use the new <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>. We register <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> with
the <code class="language-plaintext highlighter-rouge">add_mapper</code> method and assign it a non-zero ID
<code class="language-plaintext highlighter-rouge">PARTITIONING_MAPPER_ID</code>. We’ll show how to use
mapper IDs to determine which mapper is invoked
momentarily. Finally, notice that we iterate over
all the processors in the set of <code class="language-plaintext highlighter-rouge">local_procs</code>
to create a distinct instances of both <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>
and <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> for each processor (lines 57-60).</p>

<h4 id="legion-machine-model">Legion Machine Model</h4>

<p>In order to target a specific architecture, mappers need
access to a description of the underlying hardware.
Legion provides a static singleton <code class="language-plaintext highlighter-rouge">Machine</code> object
that can be used to make queries concerning the
underlying hardware. We show how to make some of these
queries as part of the constructor for our <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>
object (lines 64-218).</p>

<p>The <code class="language-plaintext highlighter-rouge">Machine</code> object is passed as part
of the arguments to any mapper constructor, but it
can also always be obtained by calling the static method
<code class="language-plaintext highlighter-rouge">Machine::get_machine</code> from anywhere in the
application. In our constructor
we begin by obtaining the set of
all the processors in the machine (line 69). The
<code class="language-plaintext highlighter-rouge">Processor</code> objects are simply light-weight handles
that name the various processors (CPUs, GPUs, etc.) in the
machine. Generally speaking, the number and kind of processors
available in the Legion runtime are configured by passsing
command-line flags such as <code class="language-plaintext highlighter-rouge">-ll:cpu &lt;C&gt;</code> and <code class="language-plaintext highlighter-rouge">-ll:gpu &lt;G&gt;</code> (which
would create <code class="language-plaintext highlighter-rouge">C</code> CPU and <code class="language-plaintext highlighter-rouge">G</code> GPU processors). Note that certain flags
are only available when the appropriate module has been compiled into
Legion (e.g. the use of GPUs depends on <code class="language-plaintext highlighter-rouge">USE_CUDA</code> at
compile-time). More details on the available flags can be found at the
<a href="/profiling/index.html#machine-configuration">machine configuration
page</a>.</p>

<p>For illustration, we print the list of processors and memories for our
machine (lines 71-201). Note that in order to avoid seeing multiple
copies of this output, we only run this code on the first mapper (line
70). Recall a separate instance of the <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>
will be made for every processor. We then
iterate over the set of all processors and print out
their ID and type (lines 75-104). Most objects
obtained from the <code class="language-plaintext highlighter-rouge">Machine</code> object have an associated
<code class="language-plaintext highlighter-rouge">id</code> field that can uniquely identify them (the special constant
<code class="language-plaintext highlighter-rouge">IDFMT</code> contains the appropriate format code for printing an ID).
There are a variety of processor types supported
by the Legion runtime: latency-optimized processors
(<code class="language-plaintext highlighter-rouge">LOC_PROC</code>) are CPU processors, throughput-optimized
processors (<code class="language-plaintext highlighter-rouge">TOC_PROC</code>) are GPUs, and utility processors
are special CPU processors used for performing Legion runtime
tasks. Legion also supports special-purpose processors for I/O,
OpenMP, and Python (not shown in this tutorial).</p>

<p>We then print the list of memories (lines 113-201).
Note that memory sizes are controlled by command-line
flags as well and may not accurately reflect the actual
underlying hardware. Again, the list of supported flags can be found
on the <a href="/profiling/index.html#machine-configuration">machine configuration
page</a>.</p>

<p>A useful way to think about the Legion machine model is that the
machine is a graph between processors and memories. Processors and
memories can have different affinities that describe the relative
speeds at which the various processors can access the available
memories. A processor can only access the contents of memories for
which it has an affinity. And similar, edges between memories describe
the paths along which data can be copied around the system. Note that
the exact affinity values are only approximations and do not reflect
the actual transfer bandwidth of the machine.</p>

<p>Line 205 uses
the <code class="language-plaintext highlighter-rouge">get_visible_memories</code> method to obtain the
set of memories that are visible from the local processor.
We then print out the affinities between the local
processor and each of these memories using the
<code class="language-plaintext highlighter-rouge">get_proc_mem_affinity</code> method (line 212).</p>

<h4 id="selecting-task-options">Selecting Task Options</h4>

<p>The first mapper call that we override is the
<code class="language-plaintext highlighter-rouge">select_task_options</code> call (lines 220-228). This
mapper call is performed on every task launch
immediately after it is made, and is used to configure certain
important aspects of task execution that the runtime needs to know up
front.</p>

<p>In general, mapper calls in Legion use a well-defined set of inputs
and outputs. The inputs are provided by one or more <code class="language-plaintext highlighter-rouge">const</code>
references, while the output is provided in a single non-<code class="language-plaintext highlighter-rouge">const</code>
reference struct. In this way, it is possible to determine what fields
a mapper is expected to set simply by looking at the signature of the
mapper call.</p>

<p>In the case of the <code class="language-plaintext highlighter-rouge">select_task_options</code> call, the following output
fields are provided to the mapper:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inline_task</code> determines whether the child task should be executed
directly in the parent tasks’s context, using the parent task’s
physical regions. (This is option is usually left to <code class="language-plaintext highlighter-rouge">false</code> as it
is desirable for the child to execute asynchronously with the
parent.)</li>
  <li><code class="language-plaintext highlighter-rouge">stealable</code> is used for work-stealing load balancing and controls
whether the task is available to be stolen by another</li>
  <li><code class="language-plaintext highlighter-rouge">map_locally</code> determines whether subsequent mapper calls (such as
<code class="language-plaintext highlighter-rouge">map_task</code>) should be processed by the current mapper, or the
mapper for the processor to which the task is to be assigned.</li>
  <li><code class="language-plaintext highlighter-rouge">initial_proc</code> is used to send the task to be mapped on another
processor. Note that the task may not necessarily execute on
<code class="language-plaintext highlighter-rouge">initial_proc</code>, since the mapper can still use the <code class="language-plaintext highlighter-rouge">map_task</code> call
to send it to a different final destination.</li>
</ul>

<p>For our adversarial mapper, to demonstrate that Legion can handle any
possible mapping strategy, we just choose a random processor for the
<code class="language-plaintext highlighter-rouge">initial_proc</code>. We use two <code class="language-plaintext highlighter-rouge">DefaultMapper</code> utility methods,
<code class="language-plaintext highlighter-rouge">select_random_processor</code> and <code class="language-plaintext highlighter-rouge">select_random_processor_kind</code> to do
this (lines 226-227).</p>

<h4 id="slicing-index-task-spaces">Slicing Index Task Spaces</h4>

<p>The second call that we override is the <code class="language-plaintext highlighter-rouge">slice_task</code>
method (lines 230-277). The <code class="language-plaintext highlighter-rouge">slice_task</code> method is used to determine
how to distribute the tasks within an index space launch around the</p>

<p>machine. The mapper is given as input a set of slices (which initially
contains a single element representing the entire launch), and is
expected to produce as output a set of slices. In this case, since we
are attempting to stress the runtime, we create a slice for each point
task and assign it to another processor. In more typical usage, the
slices would be chosen to maximize locality in the application.</p>

<p>The <code class="language-plaintext highlighter-rouge">slice_task</code> method can optionally be called recursively until the
index space launch has been decomposed down to slices of the desired
size. In this case we disable this feature and only perform one level
of slicing.</p>

<h4 id="task-mapping">Task Mapping</h4>

<p>The next mapping call, <code class="language-plaintext highlighter-rouge">map_task</code> (lines 279-338) is one of the most
important methods. The call has a number of responsibilities:</p>

<ul>
  <li>Select the final (set of) processor(s) that the task will be executed on.</li>
  <li>Select the variant of the task to execute.</li>
  <li>Select the physical instances to hold the data for each logical region.</li>
  <li>Optionally select the task priority.</li>
  <li>Optionally select profiling information to collect.</li>
</ul>

<p>On line 298, we select the final processor that the task will execute
on. In this case, we simply keep the processor that was chosen by
<code class="language-plaintext highlighter-rouge">select_task_options</code>, which is stored in the <code class="language-plaintext highlighter-rouge">task.target_proc</code>
field. Note that <code class="language-plaintext highlighter-rouge">output.target_procs</code> is a set and if multiple
processors, task will be load balanced between the selected
processors. It is a common pattern to select all of the processors on
the local node that have the appropriate type. For the adversarial
example, we only choose a single processor.</p>

<p>In general, a task can have multiple variants (e.g. for CPU or GPU, or
for a CPU that supports AVX instructions, or that assumes a specific
memory layout for its physical instances). Lines 283-297 select the
task variant to execute. It is important to choose a variant that is
capable of executing on the selected kind of processor. First we find
the list of available variants (lines 283-284). Then we filter this
down to those that are compatible with the kind of processor we intend
to map on (lines 286-290). Finally, since this is an adversarial
example, we select a random variant from among the valid choices. A
more typical example might use application-specific knowledge to
choose the appropriate variant to use.</p>

<p>Having chosen the target processor and variant, we map all the logical
regions of the task to specific physical instances (lines
299-337).</p>

<p>Note in certain cases, regions may already be mapped. Such regions are
said to be <em>premapped</em>. We find a list of such regions on lines
299-304; we’ll just skip them in the code below.</p>

<p>Certain variants of tasks may assume that the data has a specific
layout. In order to ensure that the mapping is correct for the given
variant, we use <code class="language-plaintext highlighter-rouge">find_task_layout_constraints</code> to look up the <em>layout
constraints</em> for the given variant (lines 305-307). Layout constraints
describe the layout that the variant expects to receive.</p>

<p>Legion is very flexible with respect to data layout and provide the
data in C or Fortran array order, in array-of-structs (AOS) or
struct-of-arrays (SOA), or in arbitrary hybrid combinations of those
layouts. Legion will transpose the data as necessary to ensure that it
always provided in the correct layout. The mapper is simply
responsible for choosing the layout that it wants for the data.</p>

<p>To simplify the process of choosing an appropriate layout, we use two
helper methods <code class="language-plaintext highlighter-rouge">map_constrained_requirement</code> (lines 322-323) and
<code class="language-plaintext highlighter-rouge">map_random_requirement</code> (lines 326-328) that handle the cases where
the variant specifies constraints on the layout, or leaves the layout
unconstrained, respectively. In an application-specific mapper, the
mapper might have more knowledge of the desired layout and might
include additional code here to choose a specific data layout for the
task.</p>

<p>Note that there are two special cases. First, as noted above, if a
task is premapped we need not (and cannot) map it (lines
309-310). Second, if the instance is <em>restricted</em> then we know a valid
instance already exists and we can simply use this (lines
311-314). Restricted instances occur primarily as a result of
simultaneous coherence, which is an advanced feature of Legion that is
not commonly used. Since this adversarial mapper is striving to be
general-purpose, we must handle all these cases, but an
application-specific mapper could potentially skip them.</p>

<p>On line 330 we assign the task with a random prioritiy. In more
typical usage, the mapper would assign higher priority to tasks along
the critical path of the application, to ensure that those tasks
execute as soon as they are ready.</p>

<p>Finally, <code class="language-plaintext highlighter-rouge">map_task</code> can request various profiling information about a
task, such as the status (success or failure) of a task, the execution
time, and the overhead incurred (lines 332-337). These results are
then passed back to the mapper via the <code class="language-plaintext highlighter-rouge">report_profiling</code> callback
once the task completed.</p>

<h4 id="reporting-results">Reporting Results</h4>

<p>The last mapper call that we override for our <code class="language-plaintext highlighter-rouge">AdversarialMapper</code> is
the <code class="language-plaintext highlighter-rouge">report_profiling</code> method (lines 340-410). This method prints out
the profiling information obtained from the task execution that was
requested in <code class="language-plaintext highlighter-rouge">map_task</code>.</p>

<h4 id="handling-tunable-variables">Handling Tunable Variables</h4>

<p>When writing tasks, there are often many cases where
variables depend on the underlying nature of the
machine. In Legion we refer to these variables as
<em>tunable</em> because they often need
to be specifically tuned for different architectures.
Since these variables are machine dependent and likely
to affect performance, we prefer to make these variables
explicit. To do this we provide a separate mapping call
<code class="language-plaintext highlighter-rouge">select_tunable_value</code> to explicitly request that the
mapper pick the value for this variable. We override
this call in our <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> on lines 410-430.</p>

<p>We make a slight modification to our DAXPY code to
make the number of sub-regions to create a tunable
variable so that the mapper can pick a value based
on the number of processors on the target machine. Note that the
<code class="language-plaintext highlighter-rouge">top_level_task</code> explicitly invokes the <code class="language-plaintext highlighter-rouge">select_tunable_value</code>
to find the number of sub-regions to create. (Instead of showing the
full example again, we show only the relevant snippet below.) When
this call is made, we
pass the <code class="language-plaintext highlighter-rouge">PARTITIONING_MAPPER_ID</code> as the value to the
<code class="language-plaintext highlighter-rouge">MapperID</code> field, indicating that an instance of
our <code class="language-plaintext highlighter-rouge">PartitioningMapper</code> should be used to handle
the request and not an instance of the <code class="language-plaintext highlighter-rouge">AdversarialMapper</code>.
When we make the call we also pass in a <code class="language-plaintext highlighter-rouge">TunableID</code>
which is used to identify the name of the tunable
variable that should be set. The <code class="language-plaintext highlighter-rouge">TunableID</code>
can be arbitrary, so long as the mapper that it
is being sent to knows what to do with it. In
this case we pass <code class="language-plaintext highlighter-rouge">SUBREGION_TUNABLE</code> as the
integer name for tunable variable. The <code class="language-plaintext highlighter-rouge">PartitioningMapper</code>
instance looks up the total number of processors
in the machine and returns that as the number
of sub-regions to create.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">num_subregions</span> <span class="o">=</span>
        <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">get_tunable_value</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SUBREGION_TUNABLE</span><span class="p">,</span>
                                   <span class="n">PARTITIONING_MAPPER_ID</span><span class="p">).</span><span class="n">get_result</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">();</span></code></pre></figure>

<p>Tunable variables are returned as a future, so if the application code
needs to use the result it must call <code class="language-plaintext highlighter-rouge">get_result&lt;T&gt;</code> to get the value.</p>

<h4 id="what-next">What Next?</h4>

<p>Congratulations! You’ve reached the end of the
Legion tutorial as it currently exists. There
are many features already implemented in Legion
which are not covered by this tutorial including:</p>

<ul>
  <li>reduction operations, reduction privileges,
and reduction instances</li>
  <li>special accessors to obtain raw pointers and strides from physical instances</li>
  <li>runtime debugging modes and flags</li>
  <li>runtime performance tuning knobs</li>
  <li>unmapping and remapping optimizations</li>
  <li>explicit cross-region copy operations</li>
  <li>additional mapping calls and settings</li>
  <li>close operations and composite instances (pending)</li>
  <li>profiling and debugging tools</li>
  <li>relaxed coherence modes</li>
  <li>acquire and release operations for simultaneous coherence</li>
  <li>reservations and phase barriers for synchronization
in a deferred execution model</li>
  <li>predicated operations</li>
  <li>support for speculative execution (in progress)</li>
  <li>inner and idempotent tasks</li>
  <li>efficient data-centric resiliency and recovery (in progress)</li>
</ul>

<p>If you are interested in learning more about how to
use these features of Legion or you have questions
regarding how to use them, please post to the
<a href="http://legion.stanford.edu/resources">mailing list</a>.</p>

<p>Previous Example: <a href="/legion-website-test/tutorial/multiple.html">Multiple Partitions</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
#include</span> <span class="cpf">"legion.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"test_mapper.h"</span><span class="cp">
#include</span> <span class="cpf">"default_mapper.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">Legion</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">Legion</span><span class="o">::</span><span class="n">Mapping</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
  <span class="n">SUBREGION_TUNABLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
  <span class="n">PARTITIONING_MAPPER_ID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AdversarialMapper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TestMapper</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="n">machine</span><span class="p">,</span>
      <span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">local</span><span class="p">);</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_task_options</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>    <span class="n">ctx</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>            <span class="n">task</span><span class="p">,</span>
				         <span class="n">TaskOptions</span><span class="o">&amp;</span>     <span class="n">output</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">slice_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">SliceTaskInput</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span>
                                <span class="n">SliceTaskOutput</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">map_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">MapTaskInput</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span>
                              <span class="n">MapTaskOutput</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">report_profiling</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>      <span class="n">ctx</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">TaskProfilingInfo</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PartitioningMapper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultMapper</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="n">machine</span><span class="p">,</span>
      <span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">local</span><span class="p">);</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_tunable_value</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">SelectTunableInput</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span>
                                          <span class="n">SelectTunableOutput</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">mapper_registration</span><span class="p">(</span><span class="n">Machine</span> <span class="n">machine</span><span class="p">,</span> <span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">local_procs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">replace_default_mapper</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">),</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">add_mapper</span><span class="p">(</span><span class="n">PARTITIONING_MAPPER_ID</span><span class="p">,</span>
        <span class="k">new</span> <span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">),</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="n">m</span><span class="p">,</span>
                                     <span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TestMapper</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">get_mapper_runtime</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="n">all_procs</span><span class="p">;</span>
  <span class="n">machine</span><span class="p">.</span><span class="n">get_all_processors</span><span class="p">(</span><span class="n">all_procs</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">all_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">local_proc</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %zd processors:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Processor</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">();</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Latency-optimized cores (LOCs) are CPUs</span>
        <span class="k">case</span> <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID "</span> <span class="n">IDFMT</span> <span class="s">" is CPU</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Throughput-optimized cores (TOCs) are GPUs</span>
        <span class="k">case</span> <span class="n">Processor</span><span class="o">::</span><span class="n">TOC_PROC</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID "</span> <span class="n">IDFMT</span> <span class="s">" is GPU</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Processor for doing I/O</span>
        <span class="k">case</span> <span class="n">Processor</span><span class="o">::</span><span class="n">IO_PROC</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID "</span> <span class="n">IDFMT</span> <span class="s">" is I/O Proc</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Utility processors are helper processors for</span>
        <span class="c1">// running Legion runtime meta-level tasks and</span>
        <span class="c1">// should not be used for running application tasks</span>
        <span class="k">case</span> <span class="n">Processor</span><span class="o">::</span><span class="n">UTIL_PROC</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID "</span> <span class="n">IDFMT</span> <span class="s">" is utility</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="nl">default:</span>
          <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="n">all_mems</span><span class="p">;</span>
    <span class="n">machine</span><span class="p">.</span><span class="n">get_all_memories</span><span class="p">(</span><span class="n">all_mems</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %zd memories:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Memory</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">();</span>
      <span class="kt">size_t</span> <span class="n">memory_size_in_kb</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// RDMA addressable memory when running with GASNet</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">GLOBAL_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  GASNet Global Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// DRAM on a single node</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">SYSTEM_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  System Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Pinned memory on a single node</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">REGDMA_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Pinned Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// A memory associated with a single socket</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">SOCKET_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Socket Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Zero-copy memory betweeen CPU DRAM and</span>
        <span class="c1">// all GPUs on a single node</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">Z_COPY_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Zero-Copy Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// GPU framebuffer memory for a single GPU</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">GPU_FB_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  GPU Frame Buffer Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Disk memory on a single node</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">DISK_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Disk Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// HDF framebuffer memory for a single GPU</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">HDF_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  HDF Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// File memory on a single node</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">FILE_MEM</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  File Memory ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L3 cache</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">LEVEL3_CACHE</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 3 Cache ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L2 cache</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">LEVEL2_CACHE</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 2 Cache ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L1 cache</span>
        <span class="k">case</span> <span class="n">Memory</span><span class="o">::</span><span class="n">LEVEL1_CACHE</span><span class="p">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 1 Cache ID "</span> <span class="n">IDFMT</span> <span class="s">" has %zd KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="nl">default:</span>
          <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="n">vis_mems</span><span class="p">;</span>
    <span class="n">machine</span><span class="p">.</span><span class="n">get_visible_memories</span><span class="p">(</span><span class="n">local_proc</span><span class="p">,</span> <span class="n">vis_mems</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %zd memories visible from processor "</span> <span class="n">IDFMT</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">vis_mems</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">local_proc</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vis_mems</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">vis_mems</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ProcessorMemoryAffinity</span><span class="o">&gt;</span> <span class="n">affinities</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">results</span> <span class="o">=</span>
        <span class="n">machine</span><span class="p">.</span><span class="n">get_proc_mem_affinity</span><span class="p">(</span><span class="n">affinities</span><span class="p">,</span> <span class="n">local_proc</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">results</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  Memory "</span> <span class="n">IDFMT</span> <span class="s">" has bandwidth %d and latency %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">affinities</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">affinities</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">latency</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">select_task_options</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">,</span>
                                                  <span class="n">TaskOptions</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">output</span><span class="p">.</span><span class="n">inline_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">output</span><span class="p">.</span><span class="n">stealable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">output</span><span class="p">.</span><span class="n">map_locally</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">Processor</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">select_random_processor_kind</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">task_id</span><span class="p">);</span>
  <span class="n">output</span><span class="p">.</span><span class="n">initial_proc</span> <span class="o">=</span> <span class="n">select_random_processor</span><span class="p">(</span><span class="n">kind</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">slice_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>      <span class="n">ctx</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">SliceTaskInput</span><span class="o">&amp;</span>    <span class="n">input</span><span class="p">,</span>
                                         <span class="n">SliceTaskOutput</span><span class="o">&amp;</span>   <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Iterate over all the points and send them all over the world</span>
  <span class="n">output</span><span class="p">.</span><span class="n">slices</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">domain</span><span class="p">.</span><span class="n">get_volume</span><span class="p">());</span>
  <span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">domain</span><span class="p">.</span><span class="n">get_dim</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
      <span class="p">{</span>
        <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">domain</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">PointInRectIterator</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">pir</span><span class="p">(</span><span class="n">rect</span><span class="p">);</span> <span class="n">pir</span><span class="p">();</span> <span class="n">pir</span><span class="o">++</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">pir</span><span class="p">,</span> <span class="o">*</span><span class="n">pir</span><span class="p">);</span>
          <span class="n">output</span><span class="p">.</span><span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskSlice</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span>
              <span class="n">select_random_processor</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">.</span><span class="n">kind</span><span class="p">()),</span>
              <span class="nb">false</span><span class="cm">/*recurse*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*stealable*/</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
      <span class="p">{</span>
        <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">domain</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">PointInRectIterator</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">pir</span><span class="p">(</span><span class="n">rect</span><span class="p">);</span> <span class="n">pir</span><span class="p">();</span> <span class="n">pir</span><span class="o">++</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">pir</span><span class="p">,</span> <span class="o">*</span><span class="n">pir</span><span class="p">);</span>
          <span class="n">output</span><span class="p">.</span><span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskSlice</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span>
              <span class="n">select_random_processor</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">.</span><span class="n">kind</span><span class="p">()),</span>
              <span class="nb">false</span><span class="cm">/*recurse*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*stealable*/</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
      <span class="p">{</span>
        <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">domain</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">PointInRectIterator</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">pir</span><span class="p">(</span><span class="n">rect</span><span class="p">);</span> <span class="n">pir</span><span class="p">();</span> <span class="n">pir</span><span class="o">++</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">pir</span><span class="p">,</span> <span class="o">*</span><span class="n">pir</span><span class="p">);</span>
          <span class="n">output</span><span class="p">.</span><span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskSlice</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span>
              <span class="n">select_random_processor</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">.</span><span class="n">kind</span><span class="p">()),</span>
              <span class="nb">false</span><span class="cm">/*recurse*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*stealable*/</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="nl">default:</span>
      <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">map_task</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>         <span class="n">ctx</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>                 <span class="n">task</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">MapTaskInput</span><span class="o">&amp;</span>         <span class="n">input</span><span class="p">,</span>
                                       <span class="n">MapTaskOutput</span><span class="o">&amp;</span>        <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">VariantID</span><span class="p">,</span><span class="n">Processor</span><span class="o">::</span><span class="n">Kind</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">variant_kinds</span> <span class="o">=</span>
    <span class="n">find_task_variants</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">task_id</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VariantID</span><span class="o">&gt;</span> <span class="n">variants</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">VariantID</span><span class="p">,</span><span class="n">Processor</span><span class="o">::</span><span class="n">Kind</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span>
        <span class="n">variant_kinds</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">variant_kinds</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span>
      <span class="n">variants</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">variants</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">variants</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">chosen</span> <span class="o">=</span> <span class="n">default_generate_random_integer</span><span class="p">()</span> <span class="o">%</span> <span class="n">variants</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">output</span><span class="p">.</span><span class="n">chosen_variant</span> <span class="o">=</span> <span class="n">variants</span><span class="p">[</span><span class="n">chosen</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">output</span><span class="p">.</span><span class="n">chosen_variant</span> <span class="o">=</span> <span class="n">variants</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">output</span><span class="p">.</span><span class="n">target_procs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">premapped</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">regions</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">premapped_regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">index</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">premapped_regions</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="n">output</span><span class="p">.</span><span class="n">chosen_instances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">valid_instances</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">premapped</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">TaskLayoutConstraintSet</span> <span class="o">&amp;</span><span class="n">layout_constraints</span> <span class="o">=</span>
    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">find_task_layout_constraints</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">task_id</span><span class="p">,</span>
                                          <span class="n">output</span><span class="p">.</span><span class="n">chosen_variant</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">task</span><span class="p">.</span><span class="n">regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">premapped</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">is_restricted</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">output</span><span class="p">.</span><span class="n">chosen_instances</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">valid_instances</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layout_constraints</span><span class="p">.</span><span class="n">layouts</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span>
          <span class="n">layout_constraints</span><span class="p">.</span><span class="n">layouts</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LayoutConstraintID</span><span class="o">&gt;</span> <span class="n">constraints</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span><span class="n">LayoutConstraintID</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span>
            <span class="n">layout_constraints</span><span class="p">.</span><span class="n">layouts</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span> <span class="n">it</span> <span class="o">!=</span>
            <span class="n">layout_constraints</span><span class="p">.</span><span class="n">layouts</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
      <span class="n">map_constrained_requirement</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">TASK_MAPPING</span><span class="p">,</span>
          <span class="n">constraints</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">chosen_instances</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">map_random_requirement</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                             <span class="n">output</span><span class="p">.</span><span class="n">chosen_instances</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                             <span class="n">task</span><span class="p">.</span><span class="n">target_proc</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">output</span><span class="p">.</span><span class="n">task_priority</span> <span class="o">=</span> <span class="n">default_generate_random_integer</span><span class="p">();</span>

  <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">ProfilingMeasurements</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">task_prof_requests</span><span class="p">.</span><span class="n">add_measurement</span><span class="o">&lt;</span><span class="n">OperationStatus</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">output</span><span class="p">.</span><span class="n">task_prof_requests</span><span class="p">.</span><span class="n">add_measurement</span><span class="o">&lt;</span><span class="n">OperationTimeline</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">output</span><span class="p">.</span><span class="n">task_prof_requests</span><span class="p">.</span><span class="n">add_measurement</span><span class="o">&lt;</span><span class="n">RuntimeOverhead</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">report_profiling</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span>      <span class="n">ctx</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span>              <span class="n">task</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">TaskProfilingInfo</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">ProfilingMeasurements</span><span class="p">;</span>

  <span class="n">OperationStatus</span> <span class="o">*</span><span class="n">status</span> <span class="o">=</span>
    <span class="n">input</span><span class="p">.</span><span class="n">profiling_responses</span><span class="p">.</span><span class="n">get_measurement</span><span class="o">&lt;</span><span class="n">OperationStatus</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">OperationStatus</span><span class="o">::</span><span class="n">COMPLETED_SUCCESSFULLY</span><span class="p">:</span>
        <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Task %s COMPLETED SUCCESSFULLY</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">case</span> <span class="n">OperationStatus</span><span class="o">::</span><span class="n">COMPLETED_WITH_ERRORS</span><span class="p">:</span>
        <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Task %s COMPLETED WITH ERRORS</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">case</span> <span class="n">OperationStatus</span><span class="o">::</span><span class="n">INTERRUPT_REQUESTED</span><span class="p">:</span>
        <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Task %s was INTERRUPTED</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">case</span> <span class="n">OperationStatus</span><span class="o">::</span><span class="n">TERMINATED_EARLY</span><span class="p">:</span>
        <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Task %s TERMINATED EARLY</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">case</span> <span class="n">OperationStatus</span><span class="o">::</span><span class="n">CANCELLED</span><span class="p">:</span>
        <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Task %s was CANCELLED</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="nl">default:</span>
        <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="c1">// shouldn't get any of the rest currently</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="n">status</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"No operation status for task %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>

  <span class="n">OperationTimeline</span> <span class="o">*</span><span class="n">timeline</span> <span class="o">=</span>
    <span class="n">input</span><span class="p">.</span><span class="n">profiling_responses</span><span class="p">.</span><span class="n">get_measurement</span><span class="o">&lt;</span><span class="n">OperationTimeline</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">timeline</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Operation timeline for task %s: ready=%lld start=%lld stop=%lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	   <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">(),</span>
	   <span class="n">timeline</span><span class="o">-&gt;</span><span class="n">ready_time</span><span class="p">,</span>
	   <span class="n">timeline</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">,</span>
	   <span class="n">timeline</span><span class="o">-&gt;</span><span class="n">end_time</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">timeline</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"No operation timeline for task %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>

  <span class="n">RuntimeOverhead</span> <span class="o">*</span><span class="n">overhead</span> <span class="o">=</span>
    <span class="n">input</span><span class="p">.</span><span class="n">profiling_responses</span><span class="p">.</span><span class="n">get_measurement</span><span class="o">&lt;</span><span class="n">RuntimeOverhead</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">overhead</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="p">(</span><span class="n">overhead</span><span class="o">-&gt;</span><span class="n">application_time</span> <span class="o">+</span>
		       <span class="n">overhead</span><span class="o">-&gt;</span><span class="n">runtime_time</span> <span class="o">+</span>
		       <span class="n">overhead</span><span class="o">-&gt;</span><span class="n">wait_time</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Runtime overhead for task %s: runtime=%.1f%% wait=%.1f%%</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	   <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">(),</span>
	   <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="n">overhead</span><span class="o">-&gt;</span><span class="n">runtime_time</span> <span class="o">/</span> <span class="n">total</span><span class="p">),</span>
	   <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="n">overhead</span><span class="o">-&gt;</span><span class="n">wait_time</span> <span class="o">/</span> <span class="n">total</span><span class="p">));</span>
    <span class="k">delete</span> <span class="n">overhead</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"No runtime overhead data for task %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">get_task_name</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">PartitioningMapper</span><span class="o">::</span><span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="n">m</span><span class="p">,</span>
                                       <span class="n">Runtime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span>
                                       <span class="n">Processor</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">DefaultMapper</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">get_mapper_runtime</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">PartitioningMapper</span><span class="o">::</span><span class="n">select_tunable_value</span><span class="p">(</span><span class="k">const</span> <span class="n">MapperContext</span> <span class="n">ctx</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">SelectTunableInput</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span>
                                                    <span class="n">SelectTunableOutput</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">tunable_id</span> <span class="o">==</span> <span class="n">SUBREGION_TUNABLE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Machine</span><span class="o">::</span><span class="n">ProcessorQuery</span> <span class="n">all_procs</span><span class="p">(</span><span class="n">machine</span><span class="p">);</span>
    <span class="n">all_procs</span><span class="p">.</span><span class="n">only_kind</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">);</span>
    <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">pack_tunable</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">all_procs</span><span class="p">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">output</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * Everything below here except main is the standard daxpy example and
 * is elided for brevity....
 */</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Runtime</span><span class="o">::</span><span class="n">set_top_level_task_id</span><span class="p">(</span><span class="n">TOP_LEVEL_TASK_ID</span><span class="p">);</span>

  <span class="p">{</span>
    <span class="n">TaskVariantRegistrar</span> <span class="n">registrar</span><span class="p">(</span><span class="n">TOP_LEVEL_TASK_ID</span><span class="p">,</span> <span class="s">"top_level"</span><span class="p">);</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">ProcessorConstraint</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">));</span>
    <span class="n">Runtime</span><span class="o">::</span><span class="n">preregister_task_variant</span><span class="o">&lt;</span><span class="n">top_level_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">registrar</span><span class="p">,</span> <span class="s">"top_level"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">TaskVariantRegistrar</span> <span class="n">registrar</span><span class="p">(</span><span class="n">INIT_FIELD_TASK_ID</span><span class="p">,</span> <span class="s">"init_field"</span><span class="p">);</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">ProcessorConstraint</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">));</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">set_leaf</span><span class="p">();</span>
    <span class="n">Runtime</span><span class="o">::</span><span class="n">preregister_task_variant</span><span class="o">&lt;</span><span class="n">init_field_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">registrar</span><span class="p">,</span> <span class="s">"init_field"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">TaskVariantRegistrar</span> <span class="n">registrar</span><span class="p">(</span><span class="n">DAXPY_TASK_ID</span><span class="p">,</span> <span class="s">"daxpy"</span><span class="p">);</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">ProcessorConstraint</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">));</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">set_leaf</span><span class="p">();</span>
    <span class="n">Runtime</span><span class="o">::</span><span class="n">preregister_task_variant</span><span class="o">&lt;</span><span class="n">daxpy_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">registrar</span><span class="p">,</span> <span class="s">"daxpy"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span>
    <span class="n">TaskVariantRegistrar</span> <span class="n">registrar</span><span class="p">(</span><span class="n">CHECK_TASK_ID</span><span class="p">,</span> <span class="s">"check"</span><span class="p">);</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">ProcessorConstraint</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">));</span>
    <span class="n">registrar</span><span class="p">.</span><span class="n">set_leaf</span><span class="p">();</span>
    <span class="n">Runtime</span><span class="o">::</span><span class="n">preregister_task_variant</span><span class="o">&lt;</span><span class="n">check_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">registrar</span><span class="p">,</span> <span class="s">"check"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Here is where we register the callback function for</span>
  <span class="c1">// creating custom mappers.</span>
  <span class="n">Runtime</span><span class="o">::</span><span class="n">add_registration_callback</span><span class="p">(</span><span class="n">mapper_registration</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">Runtime</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2023 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/legion-website-test/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/legion-website-test/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>
