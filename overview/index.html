<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Legion Overview &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Legion Overview">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/overview/index.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/overview/index.html">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="icon" sizes="16x16" href="/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" href="/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" href="/images/favicon/favicon-48x48.png">
<link rel="icon" sizes="96x96" href="/images/favicon/favicon-96x96.png">
<link rel="icon" sizes="144x144" href="/images/favicon/favicon-144x144.png">
<link rel="icon" sizes="192x192" href="/images/favicon/favicon-192x192.png">
<link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
<link rel="apple-touch-icon-precomposed" sizes="192x192" href="/images/favicon/apple-icon-precomposed.png">
<meta name="msapplication-config" content="/images/favicon/browserconfig.xml" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<link rel="manifest" href="/images/favicon/manifest.json">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/overview/" >Overview</a></li>
		        
				<li><a href="/starting/" >Getting Started</a></li>
		        
				<li><a href="/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/events/" >Events</a></li>
		        
				<li><a href="/documentation/" >Documentation</a></li>
		        
				<li><a href="/publications/" >Publications</a></li>
		        
				<li><a href="/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <a href="https://www.stanford.edu/"><img src="/images/logos/stanford.png" class="bio-photo" alt="Stanford University logo"></a>
<a href="https://www6.slac.stanford.edu/"><img src="/images/logos/slac.jpg" class="bio-photo" alt="SLAC National Accelerator Laboratory logo"></a>
<a href="https://www.lanl.gov/"><img src="/images/logos/los-alamos.png" class="bio-photo" alt="Los Alamos National Laboratory logo"></a>
<a href="https://www.nvidia.com/"><img src="/images/logos/nvidia.png" class="bio-photo" alt="NVIDIA logo"></a>
<a href="https://www.rdworldonline.com/rd-100-award-winners-announced-in-analytical-test-it-electrical-categories/"><img src="/images/logos/rd100.png" class="bio-photo" alt="Winner of the R&D 100 Award"></a>

<h3>Legion</h3>
<p>High Productivity High Performance Computing</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>



  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Legion Overview</h1>
    <div class="article-wrap" itemprop="text">
      <h2 id="motivation">Motivation</h2>

<p>Modern computer architectures are increasingly composed
of heterogeneous processors and deep complex memory
hierarchies. Furthermore, the cost of data movement
within these architectures is now coming to dominate
the overall cost of computation, both in terms of power
and performance. Despite these conditions, most machines 
are still programmed using an eclectic mix of programming systems
that focus only on describing parallelism (MPI,Pthreads,
OpenMP,OpenCL,OpenACC,CUDA). Achieving high performance and
power efficiency on future architectures will require 
programming systems capable of reasoning about the
structure of program data to facilitate efficient
placement and movement of data.</p>

<h2 id="programming-model">Programming Model</h2>

<p>Legion is a data-centric programming model for writing
high-performance applications for distributed heterogeneous
architectures. Making the programming system aware of
the structure of program data gives Legion programs
three advantages:</p>

<ul>
  <li><strong>User-Specification of Data Properties</strong>: Legion 
provides abstractions for programmers to explicitly 
declare properties of program data including
organization, partitioning, privileges, and 
coherence. Unlike current programming systems in
which these properties are implicitly managed
by programmers, Legion makes them explicit and provides
the implementation for programmers.</li>
  <li><strong>Automated Mechanisms</strong>: current programming
models require developers to explicitly specify parallelism
and issue data movement operations. Both responsibilities
can easily lead to the introduction of bugs in complex
applications. By understanding the structure of program
data and how it is used, Legion can implicitly extract
parallelism and issue the necessary data movement operations
in accordance with the application-specified data properties,
thereby removing a significant burden from the programmer.</li>
  <li><strong>User-Controlled Mapping</strong>: by providing abstractions for
representing both tasks and data, Legion makes it easy to
describe how to map applications onto different architectures. Legion
provides a mapping interface which gives programmers direct
control over all the details of how an application is mapped
and executed. Furthermore, Legion’s understanding of program
data makes the mapping process orthogonal to correctness.
This simplifies program performance tuning and enables
easy porting of applications to new architectures.</li>
</ul>

<p>There are three important abstractions in the Legion
programming model:</p>

<ul>
  <li><strong>Logical Regions</strong>: Logical regions are the fundamental
abstraction used for describing program data in 
Legion applications. Logical regions support a relational
model for data. Each logical region is described by an
index space of rows (either unstructured pointers or 
structured 1D, 2D, or 3D arrays) and a field space of
columns. Unlike other relational models, Legion
supports a different class of operations on logical
regions: logical regions can be arbitrarily <em>partitioned</em> 
into sub-regions based on index space or <em>sliced</em> on
their field space. Data structures can be encoded in
logical regions to express locality with partitioning
and slicing describing data independence.</li>
  <li><strong>Tree of Tasks using Regions</strong>: Every Legion program
executes as a tree of tasks with a top-level task
spawning sub-tasks which can recursively spawn further
sub-tasks. All tasks in Legion must specify the logical
regions they will access as well as the <em>privileges</em> and
<em>coherence</em> for each logical region. Legion enforces a
functional requirement on privileges which enables a
hierarchical and distributed scheduling algorithm that 
is essential for scalability.</li>
  <li><strong>Mapping Interface</strong>: Legion makes no implicit decisions
concerning how applications are mapped onto target
hardware. Instead mapping decisions regarding how tasks
are assigned to processors and how <em>physical instances</em>
of logical regions are assigned to memories are made
entirely by <em>mappers</em>. Mappers are part of application
code and implement a mapping interface. Mappers are 
queried by the Legion runtime whenever any mapping decision
needs to be made. Legion guarantees that mapping
decisions only impact performance and are orthogonal
to correctness which simplifies tuning of Legion
applications and enables easy porting to different
architectures.</li>
</ul>

<p>There are many more details to the Legion programming
model and we encourage you to learn more about them
by reading our <a href="/publications/">publications</a>.</p>

<h2 id="target-users">Target Users</h2>

<p>Legion is designed for two classes of users:</p>

<ul>
  <li><strong>Advanced application developers</strong>: programmers
who traditionally have used combinations of MPI,
GASNet, Pthreads, OpenCL, and/or CUDA to develop their
applications and always re-write applications 
from scratch for maximum performance on each 
new architecture.</li>
  <li><strong>Domain specific language and library authors</strong>:
tool writers who develop high-level productivity
languages and libraries that support separate
implementations for every target architecture
for maximum performance.</li>
</ul>

<p>In both cases, Legion provides a common framework
for implementing applications which can achieve
portable performance across a range of architectures.
The target class of users also dictates that productivity
in Legion will always be a second-class design constraint 
behind performance. Instead Legion is designed to be 
extensible and to support higher-level productivity 
languages and libraries.</p>

<h2 id="design-principles">Design Principles</h2>

<p>There are several principles which have driven
the design and implementation of Legion based on
our own experience writing applications for the
target class of architectures.</p>

<ul>
  <li><strong>User control of decomposition</strong>: it is impossible to 
develop a general algorithm capable of automatically 
inferring the optimal decomposition of data and computation
for every program. Consequently the Legion programming model 
explicitly puts control of how data is decomposed
into logical regions and how algorithms are decomposed
into tasks in the hands of the application developer.</li>
  <li><strong>Handle irregularity</strong>: Legion is designed so that all
decisions can be made dynamically to handle irregularity.
This includes the ability to make dynamic decisions regarding 
how data is partitioned, algorithms are decomposed into
tasks, where data and tasks are placed, how hard and
soft-errors are managed, etc.</li>
  <li><strong>Hybrid programming model</strong>: tasks in Legion are functional
with controlled side effects on logical regions which the
Legion runtime can understand. Individual tasks consist
of traditional imperative code. The coarse-grained functional
model enables Legion’s distributed scheduling algorithm,
while still supporting fine-grained imperative code within
tasks that is more familiar to most application developers.</li>
  <li><strong>Deferred execution</strong>: all runtime calls in Legion are
<em>deferred</em> which means that they can be 
launched asynchronously and Legion is responsible for
computing the necessary dependences and not performing
operations until it is safe to do so. This is only possible
because Legion understands the structure of program data
for deferring data movement operations and because Legion 
can reason about task’s side-effects on logical regions.</li>
  <li><strong>Provide mechanism but not policy</strong>: Legion is designed
to give programmers total control over the policy of how
an application is executed, while still automating any operations 
which can uniquely be inferred from the given policy. For
example, Legion provides total control over where tasks and
data are run, but the runtime automatically infers the 
necessary copies and data movement operations to conform to 
the specified privilege and coherence annotations
on the logical regions arguments to each task.</li>
  <li><strong>Decouple correctness from performance</strong>: In conjunction
with the previous design principle, Legion ensures that
policy decisions never impact the correctness of an 
application. Policy decisions about how to map applications
only impact performance allowing applications to customize
mappings to particular architectures without needing to
be concerned with affecting correctness.</li>
</ul>

<p>In addition to our design principles for Legion, there
were are several challenges which we explicitly avoided
in designing Legion.</p>

<ul>
  <li>Leaf task generator: Legion is not designed to solve
the problem of emitting high performance leaf tasks for
heterogeneous processors. Legion aids in managing 
multiple functionally-equivalent variants of a task
on different processor kinds, but does not help
with implementing them. Current Legion applications use
kernels that have either been hand-written for each
processor kind or JIT-compiled with 
<a href="http://terralang.org">Terra</a>.</li>
  <li>Magic mapper/performance optimizer: while Legion
provides a default mapper, it will never be possible
for it to perform an optimal mapping for all
applications. High performance will require custom
mappings. The Legion mapper interface is intentionally
extensible to support both custom mappers, and the
creation of mapping tools for building custom mappers.</li>
  <li>Automatic decomposition: decisions regarding how and 
at what granularity to partition logical regions is
the responsibility of the application. Similarly the
choice of how to decompose algorithms into tasks is
also the responsibility of the application. In both
cases, Legion could never make the correct decisions
for all applications and architectures.</li>
  <li>High productivity: based on the target users for Legion
productivity will always be a second-class design
consideration for the Legion. Instead Legion is
designed to be extensible and targeted by higher-level
productivity compilers and libraries.</li>
</ul>

<h2 id="system-architecture">System Architecture</h2>

<p><img src="/images/legion_arch.svg" alt="" /></p>

<p>The above figure shows the architecture of the Legion programming
system. Applications targeting Legion have the option of either being
written in the Regent programming language or written directly to the
Legion C++ runtime interface. Applications written in Regent are
compiled to LLVM (and call a C wrapper for the C++ runtime API).</p>

<p>The Legion runtime system implements the
Legion programming model and supports all the necessary
API calls for writing Legion applications. Mappers are
special C++ objects that are built on top of the
Legion mapping interface which is queried by the 
Legion runtime system to make all mapping decisions
when executing a Legion program. Applications can 
either chose to use the default Legion mapper or
write custom mappers for higher performance.</p>

<p>The Legion runtime system sits on top of a
low-level runtime interface called <em>Realm</em>. The Realm interface
is designed to provide portability to the entire
Legion system by providing primitives which can be
implemented on a wide range of architectures. Realm is a modular
runtime and supports a variety of underlying technologies for
portability across a variety of machines, including GASNet for
high-performance networking on a variety of interconnects and CUDA for
GPUs.</p>

    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2023 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>
