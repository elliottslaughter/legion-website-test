<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Legion Runtime: Deprecated List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Deprecated List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_deprecated000004"></a>Class <a class="el" href="struct_legion_1_1_colored_points.html">Legion::ColoredPoints&lt; T &gt;</a>  </dt>
<dd><p class="startdd"></p>
<p class="enddd">Colored points struct for describing colorings.  </p>
</dd>
<dt><a class="anchor" id="_deprecated000003"></a>Class <a class="el" href="struct_legion_1_1_field_space_requirement.html">Legion::FieldSpaceRequirement</a>  </dt>
<dd>Field space requirements can be used to specify that a task requires additional privileges on a field spaces such as the ability to allocate and free fields. </dd>
<dt><a class="anchor" id="_deprecated000002"></a>Class <a class="el" href="class_legion_1_1_index_allocator.html">Legion::IndexAllocator</a>  </dt>
<dd>Index allocators provide objects for doing allocation on index spaces. They must be explicitly created by the runtime so that they can be linked back to the runtime. Index allocators can be passed by value to functions and stored in data structures, but should not escape the enclosing context in which they were created. </dd>
<dt><a class="anchor" id="_deprecated000005"></a>Member <a class="el" href="class_legion_1_1_index_allocator.html#accd5c2693803601eace347e9ec15fe13">Legion::IndexAllocator::alloc</a>  (unsigned num_elements=1)</dt>
<dd><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_elements</td><td>number of elements to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element in the allocated block  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000006"></a>Member <a class="el" href="class_legion_1_1_index_allocator.html#a85187376e85cc3f6717242652a1c4247">Legion::IndexAllocator::free</a>  (ptr_t ptr, unsigned num_elements=1)</dt>
<dd><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the first element to free </td></tr>
    <tr><td class="paramname">num_elements</td><td>number of elements to be freed  </td></tr>
  </table>
  </dd>
</dl>
</dd>
<dt><a class="anchor" id="_deprecated000007"></a>Member <a class="el" href="class_legion_1_1_index_allocator.html#ac1471fd6219ee3300acb1e108ae38bab">Legion::IndexAllocator::get_index_space</a>  (void) const </dt>
<dd><dl class="section return"><dt>Returns</dt><dd>the index space associated with this allocator  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000001"></a>Class <a class="el" href="class_legion_1_1_index_iterator.html">Legion::IndexIterator</a>  </dt>
<dd>This is a helper class for iterating over the points within an index space or the index space of a given logical region. It should never be copied and will assert fail if a copy is made of it.  </dd>
<dt><a class="anchor" id="_deprecated000008"></a>Member <a class="el" href="class_legion_1_1_physical_region.html#ad05cc4795ff35597494d6ca22695b03b">Legion::PhysicalRegion::get_accessor</a>  (bool silence_warnings=false) const </dt>
<dd>Return a generic accessor for the entire physical region. This method is now deprecated. Please use the 'get_field_accessor' method instead. You can silence warnings about this blocking call with the 'silence_warnings' parameter.  </dd>
<dt><a class="anchor" id="_deprecated000009"></a>Member <a class="el" href="class_legion_1_1_physical_region.html#aed30abc7b6438666205e34c1e27d736e">Legion::PhysicalRegion::get_field_accessor</a>  (FieldID field, bool silence_warnings=false) const </dt>
<dd>You should be able to create accessors by passing this object directly to the constructor of an accessor Return a field accessor for a specific field within the region. You can silence warnings regarding this blocking call with the 'silence_warnings' parameter.  </dd>
<dt><a class="anchor" id="_deprecated000010"></a>Member <a class="el" href="class_legion_1_1_projection_functor.html#a35eba1e956eb8773b18cc693dd066c98">Legion::ProjectionFunctor::project</a>  (Context ctx, Task *task, unsigned index, LogicalRegion upper_bound, const DomainPoint &amp;point)</dt>
<dd>Compute the projection for a logical region projection requirement down to a specific logical region. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context for this projection </td></tr>
    <tr><td class="paramname">task</td><td>the task for the requested projection </td></tr>
    <tr><td class="paramname">index</td><td>which region requirement we are projecting </td></tr>
    <tr><td class="paramname">upper_bound</td><td>the upper bound logical region </td></tr>
    <tr><td class="paramname">point</td><td>the point of the task in the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logical region to be used by the child task  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000011"></a>Member <a class="el" href="class_legion_1_1_projection_functor.html#a665df65ed06932056e098162fed6787d">Legion::ProjectionFunctor::project</a>  (Context ctx, Task *task, unsigned index, LogicalPartition upper_bound, const DomainPoint &amp;point)</dt>
<dd>Compute the projection for a logical partition projection requirement down to a specific logical region. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context for this projection </td></tr>
    <tr><td class="paramname">task</td><td>the task for the requested projection </td></tr>
    <tr><td class="paramname">index</td><td>which region requirement we are projecting </td></tr>
    <tr><td class="paramname">upper_bound</td><td>the upper bound logical partition </td></tr>
    <tr><td class="paramname">point</td><td>the point of the task in the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logical region to be used by the child task  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000032"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a80f4f7c08d42f4607e79df8a20a55146">Legion::Runtime::attach_file</a>  (Context ctx, const char *file_name, LogicalRegion handle, LogicalRegion parent, const std::vector&lt; FieldID &gt; &amp;field_vec, LegionFileMode mode)</dt>
<dd>Attach an normal file as a physical region. This attach is similar to attach_hdf5 operation, except that the file has exact same data format as in-memory physical region. Data lays out as SOA in file.  </dd>
<dt><a class="anchor" id="_deprecated000030"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a18a9db6622557604ab9687729cfa89b6">Legion::Runtime::attach_hdf5</a>  (Context ctx, const char *file_name, LogicalRegion handle, LogicalRegion parent, const std::map&lt; FieldID, const char * &gt; &amp;field_map, LegionFileMode mode)</dt>
<dd>Attach an HDF5 file as a physical region. The file must already exist. <a class="el" href="namespace_legion.html">Legion</a> will defer the attach operation until all other operations on the logical region are finished. After the attach operation succeeds, then all other physical instances for the logical region will be invalidated, making the physical instance the only valid version of the logical region. The resulting physical instance is attached with restricted coherence (the same as logical regions mapped with simultaneous coherence). All operations using the logical region will be required to use the physical instance until the restricted coherence is removed using an acquire operation. The restricted coherence can be reinstated by performing a release operation. Just like other physical regions, the HDF5 file can be both mapped and unmapped after it is created. The runtime will report an error for an attempt to attach an file to a logical region which is already mapped in the enclosing parent task's context. The runtime will also report an error if the task launching the attach operation does not have the necessary privileges (read-write) on the logical region. The resulting physical region is unmapped, but can be mapped using the standard inline mapping calls. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">file_name</td><td>the path to an existing HDF5 file </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region with which to associate the file </td></tr>
    <tr><td class="paramname">parent</td><td>the parent logical region containing privileges </td></tr>
    <tr><td class="paramname">field_map</td><td>mapping for field IDs to HDF5 dataset names </td></tr>
    <tr><td class="paramname">mode</td><td>the access mode for attaching the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new physical instance corresponding to the HDF5 file  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000026"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a387ad10ef63b243e9edbb1c1622fc4e7">Legion::Runtime::create_argument_map</a>  (Context ctx)</dt>
<dd>Create an argument map in the given context. This method is deprecated as argument maps can now be created directly by a simple declaration. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new argument map  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000025"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a1550f7305763dadb37ce5a42572425b9">Legion::Runtime::create_index_allocator</a>  (Context ctx, IndexSpace handle)</dt>
<dd>Create an index allocator object for a given index space This method is deprecated becasue index spaces no longer support dynamic allocation. This will still work only if there is exactly one allocator made for the index space throughout the duration of its lifetime. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the index space to create an allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index space allocator for the given index space  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000014"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a51cb6acd03b57e45fd3857704ffcb0a7">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, const Domain &amp;color_space, const PointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, bool allocable=false)</dt>
<dd>Create an index partition from a point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
    <tr><td class="paramname">allocable</td><td>whether the child index spaces are allocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000015"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a70dc84f7aae18e1c437e01d6498a433e">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, const Coloring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>See the previous create_index_partition call Create an index partition. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000021"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a4e44777b685baa2b21f0bf04ed516c13">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, LegionRuntime::Accessor::RegionAccessor&lt; LegionRuntime::Accessor::AccessorType::Generic &gt; field_accessor, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd><dl class="section see"><dt>See Also</dt><dd>create_partition_by_field instead Create an index partitioning from an existing field in a physical instance. This requires that the field accessor be valid for the entire parent index space. By definition colors are always non-negative. The runtime will iterate over the field accessor and interpret values as signed integers. Any locations less than zero will be ignored. Values greater than or equal to zero will be colored and placed in the appropriate subregion. By definition this partitioning mechanism has to disjoint since each pointer value has at most one color. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">field_accessor</td><td>field accessor for the coloring field </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">complete</td><td>whether the partitioning is complete or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000016"></a>Member <a class="el" href="class_legion_1_1_runtime.html#ae76572904db634ccda408fd3e85bc555">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, const Domain &amp;color_space, const DomainPointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>Create an index partition from a domain point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000017"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a1089cb44f5721ddfa8539107ef96983b">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, Domain color_space, const DomainColoring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>See the previous create index partition call Create an index partition from a domain color space and coloring. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>the domain of colors </td></tr>
    <tr><td class="paramname">coloring</td><td>the domain coloring of the parent index space </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000018"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a11784fd73bdd77db112bcf8e14d73d8c">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, const Domain &amp;color_space, const MultiDomainPointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>Create an index partition from a multi-domain point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000019"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a702eb790c35bcbd2a8c8497226c6f8c6">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, Domain color_space, const MultiDomainColoring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>See the previous create index partition call Create an index partitiong from a domain color space and a multi-domain coloring which allows multiple domains to be associated with each color. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>the domain of colors </td></tr>
    <tr><td class="paramname">coloring</td><td>the multi-domain coloring </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000020"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a5a673027fda1ad8b8749cb37a6aa8c49">Legion::Runtime::create_index_partition</a>  (Context ctx, IndexSpace parent, const T &amp;mapping, Color color=LEGION_AUTO_GENERATE_ID)</dt>
<dd>Create an index partitioning from a typed mapping. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">mapping</td><td>the mapping of points to colors </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000012"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a4bfb413efd2de89152ad9e930769e46f">Legion::Runtime::create_index_space</a>  (Context ctx, size_t max_num_elmts)</dt>
<dd>Create a new top-level index space with the maximum number of elements <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">max_num_elmts</td><td>maximum number of elements in the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000013"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a0ccb642113a2bad26c3b4ec900633d24">Legion::Runtime::create_index_space</a>  (Context ctx, const std::set&lt; Domain &gt; &amp;domains)</dt>
<dd>Create a new top-level index space based on a set of domains <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">domains</td><td>the set of domains </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000033"></a>Member <a class="el" href="class_legion_1_1_runtime.html#af840cc317084b2faccf5321557755c8e">Legion::Runtime::detach_file</a>  (Context ctx, PhysicalRegion region)</dt>
<dd>Detach an normal file. THis detach operation is similar to detach_hdf5  </dd>
<dt><a class="anchor" id="_deprecated000031"></a>Member <a class="el" href="class_legion_1_1_runtime.html#ad93bf3b151012fb90aac52137eaf652f">Legion::Runtime::detach_hdf5</a>  (Context ctx, PhysicalRegion region)</dt>
<dd>Detach an HDF5 file. This can only be performed on a physical region that was created by calling attach_hdf5. The runtime will properly defer the detach call until all other operations on the logical region are complete. It is the responsibility of the user to perform the necessary operations to flush any data back to the physical instance before detaching (e.g. releasing coherence, etc). If the physical region is still mapped when this function is called, then it will be unmapped by this call. Note that this file may not actually get detached until much later in the execution of the program due to <a class="el" href="namespace_legion.html">Legion</a>'s deferred execution model. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>the physical region for an HDF5 file to detach  </td></tr>
  </table>
  </dd>
</dl>
</dd>
<dt><a class="anchor" id="_deprecated000029"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a041162c3fe46047c46e9e00a26f75528">Legion::Runtime::execute_index_space</a>  (Context ctx, TaskID task_id, const Domain domain, const std::vector&lt; IndexSpaceRequirement &gt; &amp;indexes, const std::vector&lt; FieldSpaceRequirement &gt; &amp;fields, const std::vector&lt; RegionRequirement &gt; &amp;regions, const UntypedBuffer &amp;global_arg, const ArgumentMap &amp;arg_map, ReductionOpID reduction, const UntypedBuffer &amp;initial_value, const Predicate &amp;predicate=Predicate::TRUE_PRED, bool must_parallelism=false, MapperID id=0, MappingTagID tag=0)</dt>
<dd>An older method for launching an index space of tasks that reduce all of their values by a reduction operation down to a single future. Maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">domain</td><td>for the set of points in the index space to create </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the tasks </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the tasks </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the tasks </td></tr>
    <tr><td class="paramname">global_arg</td><td>untyped arguments passed by value to all tasks </td></tr>
    <tr><td class="paramname">arg_map</td><td>argument map containing point arguments for tasks </td></tr>
    <tr><td class="paramname">reduction</td><td>operation to be used for reducing return values </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">must_parallelism</td><td>are tasks required to be run concurrently </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future containing reduced return value of all tasks  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000028"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a7e5e4f0c7a374673017c11c064bae7c3">Legion::Runtime::execute_index_space</a>  (Context ctx, TaskID task_id, const Domain domain, const std::vector&lt; IndexSpaceRequirement &gt; &amp;indexes, const std::vector&lt; FieldSpaceRequirement &gt; &amp;fields, const std::vector&lt; RegionRequirement &gt; &amp;regions, const UntypedBuffer &amp;global_arg, const ArgumentMap &amp;arg_map, const Predicate &amp;predicate=Predicate::TRUE_PRED, bool must_paralleism=false, MapperID id=0, MappingTagID tag=0)</dt>
<dd>An older method for launching an index space of tasks maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">domain</td><td>for the set of points in the index space to create </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the tasks </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the tasks </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the tasks </td></tr>
    <tr><td class="paramname">global_arg</td><td>untyped arguments passed by value to all tasks </td></tr>
    <tr><td class="paramname">arg_map</td><td>argument map containing point arguments for tasks </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">must_parallelism</td><td>are tasks required to be run concurrently </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future map containing results for all tasks  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000027"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a9a607c1fa178a6f1369b4471ec1414b0">Legion::Runtime::execute_task</a>  (Context ctx, TaskID task_id, const std::vector&lt; IndexSpaceRequirement &gt; &amp;indexes, const std::vector&lt; FieldSpaceRequirement &gt; &amp;fields, const std::vector&lt; RegionRequirement &gt; &amp;regions, const UntypedBuffer &amp;arg, const Predicate &amp;predicate=Predicate::TRUE_PRED, MapperID id=0, MappingTagID tag=0)</dt>
<dd>An older method for launching a single task maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the task </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the task </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the task </td></tr>
    <tr><td class="paramname">arg</td><td>untyped arguments passed by value to the task </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future representing return value of the task  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000023"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a1afb2c536734219c0f4c8973219c1e1e">Legion::Runtime::get_index_space_domains</a>  (Context ctx, IndexSpace handle, std::vector&lt; Domain &gt; &amp;domains)</dt>
<dd>Return the domains that represent the index space. While the previous call only works when there is a single domain for the index space, this call will work in all circumstances. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">vector</td><td>to populate with domains  </td></tr>
  </table>
  </dd>
</dl>
</dd>
<dt><a class="anchor" id="_deprecated000024"></a>Member <a class="el" href="class_legion_1_1_runtime.html#ab69648bdfc893258e57b6d0e75cab8d4">Legion::Runtime::get_index_subspace</a>  (Context ctx, IndexPartition p, LegionRuntime::Arrays::Point&lt; DIM &gt; color_point)</dt>
<dd>Get an index subspace from a partition with a given color point. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>parent index partition handle </td></tr>
    <tr><td class="paramname">color_point</td><td>point containing color value of index subspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding index space to the specified color point  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000034"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a183d30f63de89ea1f1becf1b3a36fda1">Legion::Runtime::get_tunable_value</a>  (Context ctx, TunableID tid, MapperID mapper=0, MappingTagID tag=0)</dt>
<dd>This is the old method for asking the mapper to specify a tunable value. It will assume that the resulting tunable future can be interpreted as an integer.  </dd>
<dt><a class="anchor" id="_deprecated000022"></a>Member <a class="el" href="class_legion_1_1_runtime.html#adb0ee94d82c36b374cf3804a48f7a16b">Legion::Runtime::has_multiple_domains</a>  (Context ctx, IndexSpace handle)</dt>
<dd>Return if the given index space is represented by multiple domains or just a single one. If multiple domains represent the index space then 'get_index_space_domains' should be used for getting the set of domains. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index space has multiple domains  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000040"></a>Member <a class="el" href="class_legion_1_1_runtime.html#abc41657d63ef3c5587288a5fdba376e5">Legion::Runtime::register_legion_task</a>  (TaskID id, Processor::Kind proc_kind, bool single, bool index, const UDT &amp;user_data, VariantID vid=LEGION_AUTO_GENERATE_ID, TaskConfigOptions options=TaskConfigOptions(), const char *task_name=NULL)</dt>
<dd>Same as the register_legion_task above, but allow for users to pass some static data that will be passed as an argument to all invocations of the function. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID at which to assign the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">user_data</td><td>user data type to pass to all invocations of the task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
Same as the register_legion_task above, but allow for users to pass some static data that will be passed as an argument to all invocations of the function. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID at which to assign the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">user_data</td><td>user data type to pass to all invocations of the task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000038"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a6d51b64f40ce794ff98b1403994c11f3">Legion::Runtime::register_legion_task</a>  (TaskID id, Processor::Kind proc_kind, bool single, bool index, VariantID vid=LEGION_AUTO_GENERATE_ID, TaskConfigOptions options=TaskConfigOptions(), const char *task_name=NULL)</dt>
<dd>Register a task with a template return type for the given kind of processor. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID to assign to the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
Register a task with a void return type for the given kind of processor. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID to assign to the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000036"></a>Member <a class="el" href="class_legion_1_1_runtime.html#aa01797f8368215038e3ace3a5e84a277">Legion::Runtime::register_partition_function</a>  (ProjectionID handle)</dt>
<dd>Register a partition projection function that can be used to map from an upper bound of a logical partition down to a specific logical sub-region for a given domain point during index task execution. The projection ID zero is reserved for runtime use. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the projection ID to register the function at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID where the function was registered  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000035"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a9a152e69794766a5565eec12eefca80c">Legion::Runtime::register_region_function</a>  (ProjectionID handle)</dt>
<dd>Register a region projection function that can be used to map from an upper bound of a logical region down to a specific logical sub-region for a given domain point during index task execution. The projection ID zero is reserved for runtime use. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the projection ID to register the function at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID where the function was registered  </dd></dl>
</dd>
<dt><a class="anchor" id="_deprecated000037"></a>Member <a class="el" href="class_legion_1_1_runtime.html#a7ae93947622a78e885a5a8b36811bb79">Legion::Runtime::set_registration_callback</a>  (RegistrationCallbackFnptr callback)</dt>
<dd>This call allows the application to register a callback function that will be run prior to beginning any task execution on every runtime in the system. It can be used to register or update the mapping between mapper IDs and mappers, register reductions, register projection function, register coloring functions, or configure any other static runtime variables prior to beginning the application. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>function pointer to the callback function to be run </td></tr>
  </table>
  </dd>
</dl>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 23 2023 09:06:55 for Legion Runtime by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
