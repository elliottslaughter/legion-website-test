<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Legion Runtime: Legion::Future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_legion.html">Legion</a></li><li class="navelem"><a class="el" href="class_legion_1_1_future.html">Future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_legion_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Legion::Future Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="legion_8h_source.html">legion.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Legion::Future:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_legion_1_1_future.png" usemap="#Legion::Future_map" alt=""/>
  <map id="Legion::Future_map" name="Legion::Future_map">
<area href="class_legion_1_1_unserializable.html" alt="Legion::Unserializable&lt; Future &gt;" shape="rect" coords="0,0,196,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10a3d3e23bd7c52825311dc88762236a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a3d3e23bd7c52825311dc88762236a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a10a3d3e23bd7c52825311dc88762236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6198dd516436f68d2b48d60b0247632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6198dd516436f68d2b48d60b0247632"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&amp;f)</td></tr>
<tr class="separator:ac6198dd516436f68d2b48d60b0247632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed60935d20925adccd4191c2555a85c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed60935d20925adccd4191c2555a85c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const </td></tr>
<tr class="separator:a0ed60935d20925adccd4191c2555a85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0119229b21262e9467fcb845e2b8f152"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0119229b21262e9467fcb845e2b8f152"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const </td></tr>
<tr class="separator:a0119229b21262e9467fcb845e2b8f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d9fdbf419203ec480f2dc4af4280f86"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0e80486857ee44bd005b642964e926"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f0e80486857ee44bd005b642964e926"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&amp;f)</td></tr>
<tr class="separator:a1f0e80486857ee44bd005b642964e926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e210aaedc53acea599973cd1834943"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0e210aaedc53acea599973cd1834943"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ad0e210aaedc53acea599973cd1834943">get_result</a> (bool silence_warnings=false, const char *warning_string=NULL) const </td></tr>
<tr class="separator:ad0e210aaedc53acea599973cd1834943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92aa82ed1ee8db3127ab554bd83baca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#aa92aa82ed1ee8db3127ab554bd83baca">get_void_result</a> (bool silence_warnings=false, const char *warning_string=NULL) const </td></tr>
<tr class="separator:aa92aa82ed1ee8db3127ab554bd83baca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafa0ef32944aa91f88b3b94d1a889be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#adafa0ef32944aa91f88b3b94d1a889be">is_empty</a> (bool block=false, bool silence_warnings=false, const char *warning_string=NULL) const </td></tr>
<tr class="separator:adafa0ef32944aa91f88b3b94d1a889be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9336b82c9d661c9054387c9b0280f26d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a9336b82c9d661c9054387c9b0280f26d">is_ready</a> (bool subscribe=false) const </td></tr>
<tr class="separator:a9336b82c9d661c9054387c9b0280f26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68597021325a28e5354a575a1540f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd68597021325a28e5354a575a1540f6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#afd68597021325a28e5354a575a1540f6">get_reference</a> (bool silence_warnings=false, const char *warning_string=NULL) const </td></tr>
<tr class="separator:afd68597021325a28e5354a575a1540f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e0f5f83fe5d8b5ffeff730846ffc13"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ab3e0f5f83fe5d8b5ffeff730846ffc13">get_untyped_pointer</a> (bool silence_warnings=false, const char *warning_string=NULL) const </td></tr>
<tr class="separator:ab3e0f5f83fe5d8b5ffeff730846ffc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d9b11f215f085754daa2c5736cca49"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ad8d9b11f215f085754daa2c5736cca49">get_untyped_size</a> (void) const </td></tr>
<tr class="separator:ad8d9b11f215f085754daa2c5736cca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2261502adba46d36318c7756abc16ff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (void)</td></tr>
<tr class="separator:a2261502adba46d36318c7756abc16ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49e8be1aec5c2be2b64952ae5a95d1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa49e8be1aec5c2be2b64952ae5a95d1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> (void) const </td></tr>
<tr class="separator:aa49e8be1aec5c2be2b64952ae5a95d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8be33620668a3248ba5970028bcc530"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8be33620668a3248ba5970028bcc530"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (void) const </td></tr>
<tr class="separator:af8be33620668a3248ba5970028bcc530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_legion_1_1_unserializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_legion_1_1_unserializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_legion_1_1_unserializable.html">Legion::Unserializable&lt; Future &gt;</a></td></tr>
<tr class="memitem:a5130925a9ea7a47cd5d3956fcdb3ce12 inherit pub_methods_class_legion_1_1_unserializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5130925a9ea7a47cd5d3956fcdb3ce12"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_buffer_size</b> (void)</td></tr>
<tr class="separator:a5130925a9ea7a47cd5d3956fcdb3ce12 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d124cde8565c2b2d2dc35892ef1a6 inherit pub_methods_class_legion_1_1_unserializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a242d124cde8565c2b2d2dc35892ef1a6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_serialize</b> (void *buffer)</td></tr>
<tr class="separator:a242d124cde8565c2b2d2dc35892ef1a6 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b127071f09541607c16fa9e39f0196 inherit pub_methods_class_legion_1_1_unserializable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b127071f09541607c16fa9e39f0196"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_deserialize</b> (const void *buffer)</td></tr>
<tr class="separator:ae8b127071f09541607c16fa9e39f0196 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a8a5f95c981e5e2ed8f5119c037f93290">from_value</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const T &amp;value)</td></tr>
<tr class="separator:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cf065d38332f8d0c77053e77439e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a748cf065d38332f8d0c77053e77439e0">from_untyped_pointer</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const void *buffer, size_t bytes)</td></tr>
<tr class="separator:a748cf065d38332f8d0c77053e77439e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa66588a7cce77ed52dfca26593abcbc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66588a7cce77ed52dfca26593abcbc1"></a>
FRIEND_ALL_RUNTIME_CLASSES&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (Internal::FutureImpl *impl, bool need_reference=true)</td></tr>
<tr class="separator:aa66588a7cce77ed52dfca26593abcbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Futures are the objects returned from asynchronous task launches. Applications can wait on futures to get their values, pass futures as arguments and preconditions to other tasks, or use them to create predicates if they are boolean futures. Futures are lightweight handles that can be passed by value or stored in data structures. However, futures should not escape the context in which they are created as the runtime garbage collects them after the enclosing task context completes execution.</p>
<p>Since futures can be the result of predicated tasks we also provide a mechanism for checking whether the future contains an empty result. An empty future will be returned for all futures which come from tasks which predicates that resolve to false. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a748cf065d38332f8d0c77053e77439e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a future from an untyped pointer. No serialization is performed. </p>

</div>
</div>
<a class="anchor" id="a8a5f95c981e5e2ed8f5119c037f93290"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow users to generate their own futures. These futures are guaranteed to always have completed and to always have concrete values. </p>

</div>
</div>
<a class="anchor" id="afd68597021325a28e5354a575a1540f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; Legion::Future::get_reference </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference to the future. WARNING: these method is unsafe as the underlying buffer containing the future result can be deleted if the <a class="el" href="class_legion_1_1_future.html">Future</a> handle is lost even a reference to the underlying buffer is maitained. This scenario can lead to seg-faults. Use at your own risk. Note also that this call will not properly deserialize buffers that were serialized with a 'legion_serialize' method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0e210aaedc53acea599973cd1834943"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Legion::Future::get_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait on the result of this future. Return the value of the future as the specified template type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the future cast as the template type </dd></dl>

</div>
</div>
<a class="anchor" id="ab3e0f5f83fe5d8b5ffeff730846ffc13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* Legion::Future::get_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an untyped pointer to the future result. WARNING: this method is unsafe for the same reasons as get_reference. It also will not deserialize anything serialized with a legion_serialize method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8d9b11f215f085754daa2c5736cca49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Future::get_untyped_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes contained in the future. </p>

</div>
</div>
<a class="anchor" id="aa92aa82ed1ee8db3127ab554bd83baca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Future::get_void_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until the future completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adafa0ef32944aa91f88b3b94d1a889be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_empty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is empty. The user can specify whether to block and wait for the future to complete first before returning. If the non-blocking version of the call will return true, until the future actually completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>indicate whether to block for the result </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9336b82c9d661c9054387c9b0280f26d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_ready </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is ready. This will return true if the future can be used without blocking to wait on the computation that the future represents, otherwise it will return false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscribe</td><td>ask for the payload to be brought here when ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="legion_8h_source.html">legion.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 13 2023 15:55:51 for Legion Runtime by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
