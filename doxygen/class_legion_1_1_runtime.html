<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Legion Runtime: Legion::Runtime Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_legion.html">Legion</a></li><li class="navelem"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_legion_1_1_runtime-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Legion::Runtime Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="legion_8h_source.html">legion.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bfb413efd2de89152ad9e930769e46f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4bfb413efd2de89152ad9e930769e46f">create_index_space</a> (Context ctx, size_t max_num_elmts)</td></tr>
<tr class="separator:a4bfb413efd2de89152ad9e930769e46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb642113a2bad26c3b4ec900633d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0ccb642113a2bad26c3b4ec900633d24">create_index_space</a> (Context ctx, const std::set&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;domains)</td></tr>
<tr class="separator:a0ccb642113a2bad26c3b4ec900633d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c1b802f7bfb0c85e8192053cf9abfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a33c1b802f7bfb0c85e8192053cf9abfb">create_shared_ownership</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a33c1b802f7bfb0c85e8192053cf9abfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20209f3cd0ba38d596257d05d6b34164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a20209f3cd0ba38d596257d05d6b34164">destroy_index_space</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, const bool unordered=false, const bool recurse=true, const char *provenance=NULL)</td></tr>
<tr class="separator:a20209f3cd0ba38d596257d05d6b34164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cb6acd03b57e45fd3857704ffcb0a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a51cb6acd03b57e45fd3857704ffcb0a7">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;color_space, const PointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, bool allocable=false)</td></tr>
<tr class="separator:a51cb6acd03b57e45fd3857704ffcb0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc84f7aae18e1c437e01d6498a433e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a70dc84f7aae18e1c437e01d6498a433e">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const Coloring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a70dc84f7aae18e1c437e01d6498a433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76572904db634ccda408fd3e85bc555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae76572904db634ccda408fd3e85bc555">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;color_space, const DomainPointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:ae76572904db634ccda408fd3e85bc555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1089cb44f5721ddfa8539107ef96983b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1089cb44f5721ddfa8539107ef96983b">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_domain.html">Domain</a> color_space, const DomainColoring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a1089cb44f5721ddfa8539107ef96983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11784fd73bdd77db112bcf8e14d73d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a11784fd73bdd77db112bcf8e14d73d8c">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;color_space, const MultiDomainPointColoring &amp;coloring, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a11784fd73bdd77db112bcf8e14d73d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702eb790c35bcbd2a8c8497226c6f8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a702eb790c35bcbd2a8c8497226c6f8c6">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_domain.html">Domain</a> color_space, const MultiDomainColoring &amp;coloring, bool disjoint, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a702eb790c35bcbd2a8c8497226c6f8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a673027fda1ad8b8749cb37a6aa8c49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a673027fda1ad8b8749cb37a6aa8c49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5a673027fda1ad8b8749cb37a6aa8c49">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const T &amp;mapping, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a5a673027fda1ad8b8749cb37a6aa8c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e44777b685baa2b21f0bf04ed516c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4e44777b685baa2b21f0bf04ed516c13">create_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, LegionRuntime::Accessor::RegionAccessor&lt; LegionRuntime::Accessor::AccessorType::Generic &gt; field_accessor, Color color=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a4e44777b685baa2b21f0bf04ed516c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8690291c53e667b2dc50fca6ea5dae0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8690291c53e667b2dc50fca6ea5dae0a">create_shared_ownership</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a8690291c53e667b2dc50fca6ea5dae0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b0a87f19f1d6ceb1aca434dfd6d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af43b0a87f19f1d6ceb1aca434dfd6d16">destroy_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, const bool unordered=false, const bool recurse=true, const char *provenance=NULL)</td></tr>
<tr class="separator:af43b0a87f19f1d6ceb1aca434dfd6d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69648bdfc893258e57b6d0e75cab8d4"><td class="memTemplParams" colspan="2">template&lt;unsigned DIM&gt; </td></tr>
<tr class="memitem:ab69648bdfc893258e57b6d0e75cab8d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab69648bdfc893258e57b6d0e75cab8d4">get_index_subspace</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, LegionRuntime::Arrays::Point&lt; DIM &gt; color_point)</td></tr>
<tr class="separator:ab69648bdfc893258e57b6d0e75cab8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103e10f383ee4ec5d3f04ffcc4cc6ac1"><td class="memItemLeft" align="right" valign="top">ptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a103e10f383ee4ec5d3f04ffcc4cc6ac1">safe_cast</a> (Context ctx, ptr_t pointer, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> region)</td></tr>
<tr class="separator:a103e10f383ee4ec5d3f04ffcc4cc6ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158340668c0d8becc481ca648cc9782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9158340668c0d8becc481ca648cc9782">safe_cast</a> (Context ctx, <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> point, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> region)</td></tr>
<tr class="separator:a9158340668c0d8becc481ca648cc9782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4184bff14eff459b500fc356da61a63c"><td class="memTemplParams" colspan="2">template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a4184bff14eff459b500fc356da61a63c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4184bff14eff459b500fc356da61a63c">safe_cast</a> (Context ctx, Point&lt; DIM, COORD_T &gt; point, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; region)</td></tr>
<tr class="separator:a4184bff14eff459b500fc356da61a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8b0cee719f8b8bd779b35642affc70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4d8b0cee719f8b8bd779b35642affc70">create_field_space</a> (Context ctx, const char *provenance=NULL)</td></tr>
<tr class="separator:a4d8b0cee719f8b8bd779b35642affc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78dae9a93c71a1592fe247090366ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad78dae9a93c71a1592fe247090366ca8">create_field_space</a> (Context ctx, const std::vector&lt; size_t &gt; &amp;field_sizes, std::vector&lt; FieldID &gt; &amp;resulting_fields, CustomSerdezID serdez_id=0, const char *provenance=NULL)</td></tr>
<tr class="separator:ad78dae9a93c71a1592fe247090366ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2b45279d8e1d14281182bbfa434f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#acd2b45279d8e1d14281182bbfa434f2b">create_field_space</a> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_future.html">Future</a> &gt; &amp;field_sizes, std::vector&lt; FieldID &gt; &amp;resulting_fields, CustomSerdezID serdez_id=0, const char *provenance=NULL)</td></tr>
<tr class="separator:acd2b45279d8e1d14281182bbfa434f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ce52d630c4f0b8820e46ce39e5b221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a50ce52d630c4f0b8820e46ce39e5b221">create_shared_ownership</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle)</td></tr>
<tr class="separator:a50ce52d630c4f0b8820e46ce39e5b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345455341864d8c45f9743c05fdb2dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a345455341864d8c45f9743c05fdb2dff">destroy_field_space</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, const bool unordered=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a345455341864d8c45f9743c05fdb2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a571b535af50b8f7fbf88c5d88054f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2a571b535af50b8f7fbf88c5d88054f5">create_logical_region</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> index, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fields, bool task_local=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a2a571b535af50b8f7fbf88c5d88054f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8434008243f9a7dfa88a1afeb7b94789"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8434008243f9a7dfa88a1afeb7b94789"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a8434008243f9a7dfa88a1afeb7b94789"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_logical_region</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; index, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fields, bool task_local=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a8434008243f9a7dfa88a1afeb7b94789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b99b00f2adb30766adc73fd116241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8f2b99b00f2adb30766adc73fd116241">create_shared_ownership</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a8f2b99b00f2adb30766adc73fd116241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4d7b61fd5b0ffd1a34fa4ebfdb689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a47d4d7b61fd5b0ffd1a34fa4ebfdb689">destroy_logical_region</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, const bool unordered=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a47d4d7b61fd5b0ffd1a34fa4ebfdb689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9349fe8247c32783efe2c30b2b43f7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae9349fe8247c32783efe2c30b2b43f7b">destroy_logical_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle, const bool unordered=false)</td></tr>
<tr class="separator:ae9349fe8247c32783efe2c30b2b43f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1550f7305763dadb37ce5a42572425b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_allocator.html">IndexAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1550f7305763dadb37ce5a42572425b9">create_index_allocator</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a1550f7305763dadb37ce5a42572425b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819fe6203528d2e753f3a09325eec8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_field_allocator.html">FieldAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3819fe6203528d2e753f3a09325eec8c">create_field_allocator</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle)</td></tr>
<tr class="separator:a3819fe6203528d2e753f3a09325eec8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387ad10ef63b243e9edbb1c1622fc4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a387ad10ef63b243e9edbb1c1622fc4e7">create_argument_map</a> (Context ctx)</td></tr>
<tr class="separator:a387ad10ef63b243e9edbb1c1622fc4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d00659246b245b91410987e65eea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7b7d00659246b245b91410987e65eea0">execute_task</a> (Context ctx, const <a class="el" href="struct_legion_1_1_task_launcher.html">TaskLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a7b7d00659246b245b91410987e65eea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d31f02a06b0b63824d1eb9f79b4eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0e8d31f02a06b0b63824d1eb9f79b4eb">execute_index_space</a> (Context ctx, const <a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a0e8d31f02a06b0b63824d1eb9f79b4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f07a1164d549f044af6db3f0830008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa6f07a1164d549f044af6db3f0830008">execute_index_space</a> (Context ctx, const <a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> &amp;launcher, ReductionOpID redop, bool deterministic=false)</td></tr>
<tr class="separator:aa6f07a1164d549f044af6db3f0830008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc6d21a6ae61814eecd74bf6fdf17bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4cc6d21a6ae61814eecd74bf6fdf17bb">reduce_future_map</a> (Context ctx, const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;future_map, ReductionOpID redop, bool deterministic=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a4cc6d21a6ae61814eecd74bf6fdf17bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ef382f66b480e80d87607641912573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a04ef382f66b480e80d87607641912573">construct_future_map</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> domain, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &gt; &amp;data, bool collective=false, ShardingID sid=0, bool implicit_sharding=false)</td></tr>
<tr class="separator:a04ef382f66b480e80d87607641912573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44a830e573aea91f8b471b282e11320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac44a830e573aea91f8b471b282e11320"></a>
<a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct_future_map</b> (Context ctx, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;domain, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &gt; &amp;data, bool collective=false, ShardingID sid=0, bool implicit_sharding=false)</td></tr>
<tr class="separator:ac44a830e573aea91f8b471b282e11320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a26344ad772345a6544dadd5e2df3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad7a26344ad772345a6544dadd5e2df3d">construct_future_map</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> domain, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_future.html">Future</a> &gt; &amp;futures, bool collective=false, ShardingID sid=0, bool implicit_sharding=false, const char *provenance=NULL)</td></tr>
<tr class="separator:ad7a26344ad772345a6544dadd5e2df3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3843e832f7959937430dd22656fe7c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3843e832f7959937430dd22656fe7c69"></a>
<a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>construct_future_map</b> (Context ctx, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;domain, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_future.html">Future</a> &gt; &amp;futures, bool collective=false, ShardingID sid=0, bool implicit_sharding=false)</td></tr>
<tr class="separator:a3843e832f7959937430dd22656fe7c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a607c1fa178a6f1369b4471ec1414b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9a607c1fa178a6f1369b4471ec1414b0">execute_task</a> (Context ctx, TaskID task_id, const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;indexes, const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;fields, const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;regions, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;arg, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;predicate=Predicate::TRUE_PRED, MapperID id=0, MappingTagID tag=0)</td></tr>
<tr class="separator:a9a607c1fa178a6f1369b4471ec1414b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5e4f0c7a374673017c11c064bae7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7e5e4f0c7a374673017c11c064bae7c3">execute_index_space</a> (Context ctx, TaskID task_id, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> domain, const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;indexes, const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;fields, const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;regions, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;global_arg, const <a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a> &amp;arg_map, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;predicate=Predicate::TRUE_PRED, bool must_paralleism=false, MapperID id=0, MappingTagID tag=0)</td></tr>
<tr class="separator:a7e5e4f0c7a374673017c11c064bae7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041162c3fe46047c46e9e00a26f75528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a041162c3fe46047c46e9e00a26f75528">execute_index_space</a> (Context ctx, TaskID task_id, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> domain, const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;indexes, const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;fields, const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;regions, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;global_arg, const <a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a> &amp;arg_map, ReductionOpID reduction, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;initial_value, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;predicate=Predicate::TRUE_PRED, bool must_parallelism=false, MapperID id=0, MappingTagID tag=0)</td></tr>
<tr class="separator:a041162c3fe46047c46e9e00a26f75528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a56d287882bf9d1b937dd9a909b409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a72a56d287882bf9d1b937dd9a909b409">map_region</a> (Context ctx, const <a class="el" href="struct_legion_1_1_inline_launcher.html">InlineLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a72a56d287882bf9d1b937dd9a909b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b8d2c9bdf3f2cd0bd0402461b383e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a86b8d2c9bdf3f2cd0bd0402461b383e1">map_region</a> (Context ctx, const <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &amp;req, MapperID id=0, MappingTagID tag=0, const char *provenance=NULL)</td></tr>
<tr class="separator:a86b8d2c9bdf3f2cd0bd0402461b383e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35289dab953525dd68eb1a872ba19611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a35289dab953525dd68eb1a872ba19611">map_region</a> (Context ctx, unsigned idx, MapperID id=0, MappingTagID tag=0, const char *provenance=NULL)</td></tr>
<tr class="separator:a35289dab953525dd68eb1a872ba19611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c0ab14c57618b4e4fd317a0b8862b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aac1c0ab14c57618b4e4fd317a0b8862b">remap_region</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region, const char *provenance=NULL)</td></tr>
<tr class="separator:aac1c0ab14c57618b4e4fd317a0b8862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d36874abe2077cd4ea544a357c336b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4d36874abe2077cd4ea544a357c336b4">unmap_region</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region)</td></tr>
<tr class="separator:a4d36874abe2077cd4ea544a357c336b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27b33e7667fa68655141d7bdc68965e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab27b33e7667fa68655141d7bdc68965e">unmap_all_regions</a> (Context ctx)</td></tr>
<tr class="separator:ab27b33e7667fa68655141d7bdc68965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140bb70e85c103a86fab13e7d496eb7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a140bb70e85c103a86fab13e7d496eb7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a140bb70e85c103a86fab13e7d496eb7c">fill_field</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, const T &amp;value, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:a140bb70e85c103a86fab13e7d496eb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a6d23c86a02ec305561be1ba20b9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a889a6d23c86a02ec305561be1ba20b9f">fill_field</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, const void *value, size_t value_size, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:a889a6d23c86a02ec305561be1ba20b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0b72552910db25303cd67970d584e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aba0b72552910db25303cd67970d584e2">fill_field</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_future.html">Future</a> f, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:aba0b72552910db25303cd67970d584e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113667a31d9e922b56cd95d2f5409b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a113667a31d9e922b56cd95d2f5409b58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a113667a31d9e922b56cd95d2f5409b58">fill_fields</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const std::set&lt; FieldID &gt; &amp;fields, const T &amp;value, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:a113667a31d9e922b56cd95d2f5409b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8953222069a4b25004f7d67f58acda3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8953222069a4b25004f7d67f58acda3b">fill_fields</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const std::set&lt; FieldID &gt; &amp;fields, const void *value, size_t value_size, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:a8953222069a4b25004f7d67f58acda3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e26e3821b804151fe5773c1f7e31066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5e26e3821b804151fe5773c1f7e31066">fill_fields</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const std::set&lt; FieldID &gt; &amp;fields, <a class="el" href="class_legion_1_1_future.html">Future</a> f, <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> pred=Predicate::TRUE_PRED)</td></tr>
<tr class="separator:a5e26e3821b804151fe5773c1f7e31066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e5fbafa51f0d505fb4878db79d9fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae6e5fbafa51f0d505fb4878db79d9fb0">fill_fields</a> (Context ctx, const <a class="el" href="struct_legion_1_1_fill_launcher.html">FillLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:ae6e5fbafa51f0d505fb4878db79d9fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92453823db486b1a23ff6e1017da2bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a92453823db486b1a23ff6e1017da2bd3">fill_fields</a> (Context ctx, const <a class="el" href="struct_legion_1_1_index_fill_launcher.html">IndexFillLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a92453823db486b1a23ff6e1017da2bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0b11fbbbd98d975ae1472ea1d25cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abf0b11fbbbd98d975ae1472ea1d25cec">attach_external_resource</a> (Context ctx, const <a class="el" href="struct_legion_1_1_attach_launcher.html">AttachLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:abf0b11fbbbd98d975ae1472ea1d25cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5cfc4047ce453b5b6642ed23803770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abf5cfc4047ce453b5b6642ed23803770">detach_external_resource</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region, const bool flush=true, const bool unordered=false, const char *provenance=NULL)</td></tr>
<tr class="separator:abf5cfc4047ce453b5b6642ed23803770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f01d9189d26f07ad2e4f8db2dc55bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_external_resources.html">ExternalResources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a85f01d9189d26f07ad2e4f8db2dc55bd">attach_external_resources</a> (Context ctx, const <a class="el" href="struct_legion_1_1_index_attach_launcher.html">IndexAttachLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a85f01d9189d26f07ad2e4f8db2dc55bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a58772ee8c20b794f915650a2e812be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4a58772ee8c20b794f915650a2e812be">detach_external_resources</a> (Context ctx, <a class="el" href="class_legion_1_1_external_resources.html">ExternalResources</a> external, const bool flush=true, const bool unordered=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a4a58772ee8c20b794f915650a2e812be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81aaaf17046eba245b86c345dbb0e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af81aaaf17046eba245b86c345dbb0e53">progress_unordered_operations</a> (Context ctx)</td></tr>
<tr class="separator:af81aaaf17046eba245b86c345dbb0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a9db6622557604ab9687729cfa89b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a18a9db6622557604ab9687729cfa89b6">attach_hdf5</a> (Context ctx, const char *file_name, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const std::map&lt; FieldID, const char * &gt; &amp;field_map, LegionFileMode mode)</td></tr>
<tr class="separator:a18a9db6622557604ab9687729cfa89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93bf3b151012fb90aac52137eaf652f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad93bf3b151012fb90aac52137eaf652f">detach_hdf5</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region)</td></tr>
<tr class="separator:ad93bf3b151012fb90aac52137eaf652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4f7c08d42f4607e79df8a20a55146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a80f4f7c08d42f4607e79df8a20a55146">attach_file</a> (Context ctx, const char *file_name, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const std::vector&lt; FieldID &gt; &amp;field_vec, LegionFileMode mode)</td></tr>
<tr class="separator:a80f4f7c08d42f4607e79df8a20a55146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af840cc317084b2faccf5321557755c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af840cc317084b2faccf5321557755c8e">detach_file</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region)</td></tr>
<tr class="separator:af840cc317084b2faccf5321557755c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44776b6543dac1f165b5148831e341b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a44776b6543dac1f165b5148831e341b8">issue_copy_operation</a> (Context ctx, const <a class="el" href="struct_legion_1_1_copy_launcher.html">CopyLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a44776b6543dac1f165b5148831e341b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986853cf7b7747c747f664d04e05a4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a986853cf7b7747c747f664d04e05a4dd">issue_copy_operation</a> (Context ctx, const <a class="el" href="struct_legion_1_1_index_copy_launcher.html">IndexCopyLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a986853cf7b7747c747f664d04e05a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1eb2a680dce9e2dcd4c03093cb75e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#afd1eb2a680dce9e2dcd4c03093cb75e8">create_predicate</a> (Context ctx, const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f, const char *provenance=NULL)</td></tr>
<tr class="separator:afd1eb2a680dce9e2dcd4c03093cb75e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36140f9ce5045dfa588d11fe5835026f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a36140f9ce5045dfa588d11fe5835026f">predicate_not</a> (Context ctx, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p, const char *provenance=NULL)</td></tr>
<tr class="separator:a36140f9ce5045dfa588d11fe5835026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aac64c5c44fb580598a8c1a4bea175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a00aac64c5c44fb580598a8c1a4bea175">predicate_and</a> (Context ctx, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p1, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p2, const char *provenance=NULL)</td></tr>
<tr class="separator:a00aac64c5c44fb580598a8c1a4bea175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba44e7bfcbc9f7dbf78fd3865fcc8122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aba44e7bfcbc9f7dbf78fd3865fcc8122">predicate_or</a> (Context ctx, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p1, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p2, const char *provenance=NULL)</td></tr>
<tr class="separator:aba44e7bfcbc9f7dbf78fd3865fcc8122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54270c655c3a1f30d38e8370b732f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abe54270c655c3a1f30d38e8370b732f0">create_predicate</a> (Context ctx, const <a class="el" href="struct_legion_1_1_predicate_launcher.html">PredicateLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:abe54270c655c3a1f30d38e8370b732f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f8b658d5534f78088c7e268567b0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a35f8b658d5534f78088c7e268567b0e0">get_predicate_future</a> (Context ctx, const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;p)</td></tr>
<tr class="separator:a35f8b658d5534f78088c7e268567b0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaffbe858643c9083a6a9ef39e472e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_lock.html">Lock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aeaffbe858643c9083a6a9ef39e472e7e">create_lock</a> (Context ctx)</td></tr>
<tr class="separator:aeaffbe858643c9083a6a9ef39e472e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c3a2fca0f3456220fde2736431712a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a55c3a2fca0f3456220fde2736431712a">destroy_lock</a> (Context ctx, <a class="el" href="class_legion_1_1_lock.html">Lock</a> l)</td></tr>
<tr class="separator:a55c3a2fca0f3456220fde2736431712a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96cf3328e9b69c7df53c25982286b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_grant.html">Grant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae96cf3328e9b69c7df53c25982286b13">acquire_grant</a> (Context ctx, const std::vector&lt; <a class="el" href="struct_legion_1_1_lock_request.html">LockRequest</a> &gt; &amp;requests)</td></tr>
<tr class="separator:ae96cf3328e9b69c7df53c25982286b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c37ef0a98db690f4933457eeaa853e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a25c37ef0a98db690f4933457eeaa853e">release_grant</a> (Context ctx, <a class="el" href="class_legion_1_1_grant.html">Grant</a> grant)</td></tr>
<tr class="separator:a25c37ef0a98db690f4933457eeaa853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfcf5e6fc52dc9bcbb5d0eb76087472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2dfcf5e6fc52dc9bcbb5d0eb76087472">create_phase_barrier</a> (Context ctx, unsigned arrivals)</td></tr>
<tr class="separator:a2dfcf5e6fc52dc9bcbb5d0eb76087472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb709efc503d8500f9710cb892b45a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7fb709efc503d8500f9710cb892b45a7">destroy_phase_barrier</a> (Context ctx, <a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a> pb)</td></tr>
<tr class="separator:a7fb709efc503d8500f9710cb892b45a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92381209ec4d73bae91236cf77da5fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a92381209ec4d73bae91236cf77da5fb3">advance_phase_barrier</a> (Context ctx, <a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a> pb)</td></tr>
<tr class="separator:a92381209ec4d73bae91236cf77da5fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c9f25e047233fefbf75ab200e42af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab0c9f25e047233fefbf75ab200e42af0">create_dynamic_collective</a> (Context ctx, unsigned arrivals, ReductionOpID redop, const void *init_value, size_t init_size)</td></tr>
<tr class="separator:ab0c9f25e047233fefbf75ab200e42af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a37a1dbbbfafef022fc55463d807b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7a37a1dbbbfafef022fc55463d807b9c">destroy_dynamic_collective</a> (Context ctx, <a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> dc)</td></tr>
<tr class="separator:a7a37a1dbbbfafef022fc55463d807b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125adaa5cd839477ccd82a3e29ed5512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a125adaa5cd839477ccd82a3e29ed5512">arrive_dynamic_collective</a> (Context ctx, <a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> dc, const void *buffer, size_t size, unsigned count=1)</td></tr>
<tr class="separator:a125adaa5cd839477ccd82a3e29ed5512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e67a25827ba66bc3b58cd6748edce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a714e67a25827ba66bc3b58cd6748edce">defer_dynamic_collective_arrival</a> (Context ctx, <a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> dc, const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f, unsigned count=1)</td></tr>
<tr class="separator:a714e67a25827ba66bc3b58cd6748edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27211b0ad6a4087bb97de66f8fa44f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a27211b0ad6a4087bb97de66f8fa44f20">get_dynamic_collective_result</a> (Context ctx, <a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> dc, const char *provenance=NULL)</td></tr>
<tr class="separator:a27211b0ad6a4087bb97de66f8fa44f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d742dec7f16386ecaa85a451766eadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0d742dec7f16386ecaa85a451766eadf">advance_dynamic_collective</a> (Context ctx, <a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> dc)</td></tr>
<tr class="separator:a0d742dec7f16386ecaa85a451766eadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1a34f794934fda97473fcbd8de8c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1d1a34f794934fda97473fcbd8de8c8c">issue_acquire</a> (Context ctx, const <a class="el" href="struct_legion_1_1_acquire_launcher.html">AcquireLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a1d1a34f794934fda97473fcbd8de8c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ceedaee7b9e3be8cd045b30a98212d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa1ceedaee7b9e3be8cd045b30a98212d">issue_release</a> (Context ctx, const <a class="el" href="struct_legion_1_1_release_launcher.html">ReleaseLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:aa1ceedaee7b9e3be8cd045b30a98212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68392f02f7fa6ccfdb0a5be66b839e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af68392f02f7fa6ccfdb0a5be66b839e7">issue_mapping_fence</a> (Context ctx, const char *provenance=NULL)</td></tr>
<tr class="separator:af68392f02f7fa6ccfdb0a5be66b839e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0136c0bb23695eaa3b36fcd3d410208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab0136c0bb23695eaa3b36fcd3d410208">issue_execution_fence</a> (Context ctx, const char *provenance=NULL)</td></tr>
<tr class="separator:ab0136c0bb23695eaa3b36fcd3d410208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac742f795af88189854aa921f247bdc76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac742f795af88189854aa921f247bdc76">begin_trace</a> (Context ctx, TraceID tid, bool logical_only=false, bool static_trace=false, const std::set&lt; RegionTreeID &gt; *managed=NULL, const char *provenance=NULL)</td></tr>
<tr class="separator:ac742f795af88189854aa921f247bdc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f0dfc27d00a33bc914332f658e98fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab3f0dfc27d00a33bc914332f658e98fd">end_trace</a> (Context ctx, TraceID tid, const char *provenance=NULL)</td></tr>
<tr class="separator:ab3f0dfc27d00a33bc914332f658e98fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41876356255505a4600a987fd3e2730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad41876356255505a4600a987fd3e2730">begin_static_trace</a> (Context ctx, const std::set&lt; RegionTreeID &gt; *managed=NULL)</td></tr>
<tr class="separator:ad41876356255505a4600a987fd3e2730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bdf19645572d9fd250156aad5a383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac89bdf19645572d9fd250156aad5a383">end_static_trace</a> (Context ctx)</td></tr>
<tr class="separator:ac89bdf19645572d9fd250156aad5a383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e0571bd9be25788063ded6303189a"><td class="memItemLeft" align="right" valign="top">TraceID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a676e0571bd9be25788063ded6303189a">generate_dynamic_trace_id</a> (void)</td></tr>
<tr class="separator:a676e0571bd9be25788063ded6303189a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11042f09a94d61949dae96d611eb944"><td class="memItemLeft" align="right" valign="top">TraceID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab11042f09a94d61949dae96d611eb944">generate_library_trace_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:ab11042f09a94d61949dae96d611eb944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ac9a3b4f949dff7aed8def14a2d113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a80ac9a3b4f949dff7aed8def14a2d113">complete_frame</a> (Context ctx, const char *provenance=NULL)</td></tr>
<tr class="separator:a80ac9a3b4f949dff7aed8def14a2d113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f219e544094fa61ddea088645482e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4f219e544094fa61ddea088645482e98">execute_must_epoch</a> (Context ctx, const <a class="el" href="struct_legion_1_1_must_epoch_launcher.html">MustEpochLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a4f219e544094fa61ddea088645482e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1d9bbfcccc42d178f51ff2da2da94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a63c1d9bbfcccc42d178f51ff2da2da94">select_tunable_value</a> (Context ctx, TunableID tid, MapperID mapper=0, MappingTagID tag=0, const void *args=NULL, size_t argsize=0)</td></tr>
<tr class="separator:a63c1d9bbfcccc42d178f51ff2da2da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0efd43c0a3da36c722e568fa14d470"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d0efd43c0a3da36c722e568fa14d470"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><b>select_tunable_value</b> (Context ctx, const <a class="el" href="struct_legion_1_1_tunable_launcher.html">TunableLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a4d0efd43c0a3da36c722e568fa14d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d30f63de89ea1f1becf1b3a36fda1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a183d30f63de89ea1f1becf1b3a36fda1">get_tunable_value</a> (Context ctx, TunableID tid, MapperID mapper=0, MappingTagID tag=0)</td></tr>
<tr class="separator:a183d30f63de89ea1f1becf1b3a36fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d2097717587b6843d2a3bd7edbef1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_legion_1_1_task.html">Task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a580d2097717587b6843d2a3bd7edbef1">get_local_task</a> (Context ctx)</td></tr>
<tr class="separator:a580d2097717587b6843d2a3bd7edbef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f1b71c70eaaa525ecf6dd54e6690a7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab9f1b71c70eaaa525ecf6dd54e6690a7">get_local_task_variable_untyped</a> (Context ctx, LocalVariableID id)</td></tr>
<tr class="separator:ab9f1b71c70eaaa525ecf6dd54e6690a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42111429a7210af2758c5a1ea90a6672"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42111429a7210af2758c5a1ea90a6672"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42111429a7210af2758c5a1ea90a6672"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_local_task_variable</b> (Context ctx, LocalVariableID id)</td></tr>
<tr class="separator:a42111429a7210af2758c5a1ea90a6672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb95bedd55d53c83b9117f4ac31dca09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adb95bedd55d53c83b9117f4ac31dca09">set_local_task_variable_untyped</a> (Context ctx, LocalVariableID id, const void *value, void(*destructor)(void *)=NULL)</td></tr>
<tr class="separator:adb95bedd55d53c83b9117f4ac31dca09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f410391a251111f9653409285e502dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f410391a251111f9653409285e502dd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f410391a251111f9653409285e502dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_local_task_variable</b> (Context ctx, LocalVariableID id, const T *value, void(*destructor)(void *)=NULL)</td></tr>
<tr class="separator:a0f410391a251111f9653409285e502dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c740ac313e5a6bb1e986d334a345ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac1c740ac313e5a6bb1e986d334a345ac">get_current_time</a> (Context ctx, <a class="el" href="class_legion_1_1_future.html">Future</a> precondition=<a class="el" href="class_legion_1_1_future.html">Future</a>())</td></tr>
<tr class="separator:ac1c740ac313e5a6bb1e986d334a345ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ff08366d6e945735015c228595f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af81ff08366d6e945735015c228595f52">get_current_time_in_microseconds</a> (Context ctx, <a class="el" href="class_legion_1_1_future.html">Future</a> precondition=<a class="el" href="class_legion_1_1_future.html">Future</a>())</td></tr>
<tr class="separator:af81ff08366d6e945735015c228595f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a4e3e7621d3f8bc12b4c54e2c13001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a08a4e3e7621d3f8bc12b4c54e2c13001">get_current_time_in_nanoseconds</a> (Context ctx, <a class="el" href="class_legion_1_1_future.html">Future</a> precondition=<a class="el" href="class_legion_1_1_future.html">Future</a>())</td></tr>
<tr class="separator:a08a4e3e7621d3f8bc12b4c54e2c13001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08079d49f5ca63e3254864c3c91827b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa08079d49f5ca63e3254864c3c91827b">issue_timing_measurement</a> (Context ctx, const <a class="el" href="struct_legion_1_1_timing_launcher.html">TimingLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:aa08079d49f5ca63e3254864c3c91827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c6816e049c49ce25e6196b15535d5"><td class="memItemLeft" align="right" valign="top">Mapping::Mapper *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a888c6816e049c49ce25e6196b15535d5">get_mapper</a> (Context ctx, MapperID id, Processor target=Processor::NO_PROC)</td></tr>
<tr class="separator:a888c6816e049c49ce25e6196b15535d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcf2b0d9fb51e2a25b1b2f3bed2e9d2"><td class="memItemLeft" align="right" valign="top">Mapping::MapperContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#affcf2b0d9fb51e2a25b1b2f3bed2e9d2">begin_mapper_call</a> (Context ctx, MapperID id, Processor target=Processor::NO_PROC)</td></tr>
<tr class="separator:affcf2b0d9fb51e2a25b1b2f3bed2e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087efef8f6dde153b6419a591334d82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a087efef8f6dde153b6419a591334d82d">end_mapper_call</a> (Mapping::MapperContext ctx)</td></tr>
<tr class="separator:a087efef8f6dde153b6419a591334d82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae005a8b8c1f513af1c52029d22bbf9d"><td class="memItemLeft" align="right" valign="top">Processor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aae005a8b8c1f513af1c52029d22bbf9d">get_executing_processor</a> (Context ctx)</td></tr>
<tr class="separator:aae005a8b8c1f513af1c52029d22bbf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74371677d9d67f800329ac5c770c54c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_legion_1_1_task.html">Task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a74371677d9d67f800329ac5c770c54c4">get_current_task</a> (Context ctx)</td></tr>
<tr class="separator:a74371677d9d67f800329ac5c770c54c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae436d1051bfac794d153ea776aca9f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae436d1051bfac794d153ea776aca9f93">raise_region_exception</a> (Context ctx, <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> region, bool nuclear)</td></tr>
<tr class="separator:ae436d1051bfac794d153ea776aca9f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ef2dd2dff921f5ad8dd208aac18333"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad7ef2dd2dff921f5ad8dd208aac18333">yield</a> (Context ctx)</td></tr>
<tr class="separator:ad7ef2dd2dff921f5ad8dd208aac18333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd9a2972ac9b068d579ac15379d72f2"><td class="memItemLeft" align="right" valign="top">ShardID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abfd9a2972ac9b068d579ac15379d72f2">local_shard</a> (Context ctx)</td></tr>
<tr class="separator:abfd9a2972ac9b068d579ac15379d72f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af322e2707640ed384e51b642ed9e3ac0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af322e2707640ed384e51b642ed9e3ac0">total_shards</a> (Context ctx)</td></tr>
<tr class="separator:af322e2707640ed384e51b642ed9e3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51590b28041537778aab81d790ebdbe2"><td class="memItemLeft" align="right" valign="top">const std::map&lt; int, <br class="typebreak"/>
AddressSpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a51590b28041537778aab81d790ebdbe2">find_forward_MPI_mapping</a> (void)</td></tr>
<tr class="separator:a51590b28041537778aab81d790ebdbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27b2638c8aa39d366886a678f63749d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; AddressSpace, <br class="typebreak"/>
int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac27b2638c8aa39d366886a678f63749d">find_reverse_MPI_mapping</a> (void)</td></tr>
<tr class="separator:ac27b2638c8aa39d366886a678f63749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b6769d9ee8de7892f0b5d5c3cc4ab3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa2b6769d9ee8de7892f0b5d5c3cc4ab3">find_local_MPI_rank</a> (void)</td></tr>
<tr class="separator:aa2b6769d9ee8de7892f0b5d5c3cc4ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7065b4e925dd6a6f7402840e7bde2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9d7065b4e925dd6a6f7402840e7bde2c">is_MPI_interop_configured</a> (void)</td></tr>
<tr class="separator:a9d7065b4e925dd6a6f7402840e7bde2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02665b2e9420a73f96b5b2ca0bedcbae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a02665b2e9420a73f96b5b2ca0bedcbae">attach_semantic_information</a> (TaskID task_id, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false, bool local_only=false)</td></tr>
<tr class="separator:a02665b2e9420a73f96b5b2ca0bedcbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650321803a3a960e89ef809f346e64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3650321803a3a960e89ef809f346e64c">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:a3650321803a3a960e89ef809f346e64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd048a1345ec6c5e877f1eb95d45959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aecd048a1345ec6c5e877f1eb95d45959">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:aecd048a1345ec6c5e877f1eb95d45959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44ffbd80bf5a589d96896c4ea680836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae44ffbd80bf5a589d96896c4ea680836">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:ae44ffbd80bf5a589d96896c4ea680836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ed5acedef1c738c9975fcde1f4242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a781ed5acedef1c738c9975fcde1f4242">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:a781ed5acedef1c738c9975fcde1f4242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c172c1fe694d1b814363c09c3a9fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa1c172c1fe694d1b814363c09c3a9fe9">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:aa1c172c1fe694d1b814363c09c3a9fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dce427fc17f11ac738faf86b18e348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a34dce427fc17f11ac738faf86b18e348">attach_semantic_information</a> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle, SemanticTag tag, const void *buffer, size_t size, bool is_mutable=false)</td></tr>
<tr class="separator:a34dce427fc17f11ac738faf86b18e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9033b3a82953c9991b14a2a3002a47e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9033b3a82953c9991b14a2a3002a47e6">attach_name</a> (TaskID task_id, const char *name, bool is_mutable=false, bool local_only=false)</td></tr>
<tr class="separator:a9033b3a82953c9991b14a2a3002a47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422e9329647f5477dc54a2ae5af0c0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a422e9329647f5477dc54a2ae5af0c0a1">attach_name</a> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:a422e9329647f5477dc54a2ae5af0c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e857566eaffcdca175b3a23175c217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a75e857566eaffcdca175b3a23175c217">attach_name</a> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:a75e857566eaffcdca175b3a23175c217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1ccdd03cbc18919f081b96761bfb3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2f1ccdd03cbc18919f081b96761bfb3b">attach_name</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:a2f1ccdd03cbc18919f081b96761bfb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5165fcf2d6b6d5bc60026155fa15ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac5165fcf2d6b6d5bc60026155fa15ce9">attach_name</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:ac5165fcf2d6b6d5bc60026155fa15ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01312959577f6d3598b7a7c60aede3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae01312959577f6d3598b7a7c60aede3a">attach_name</a> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:ae01312959577f6d3598b7a7c60aede3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ed85fcc8151cbf16e20d56de5cc604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a62ed85fcc8151cbf16e20d56de5cc604">attach_name</a> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle, const char *name, bool is_mutable=false)</td></tr>
<tr class="separator:a62ed85fcc8151cbf16e20d56de5cc604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a16b950fc9fb7893ca5b5dfc001e8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a83a16b950fc9fb7893ca5b5dfc001e8f">retrieve_semantic_information</a> (TaskID task_id, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:a83a16b950fc9fb7893ca5b5dfc001e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5fdb8686a7fe4743d84d2c7a6578db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0e5fdb8686a7fe4743d84d2c7a6578db">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:a0e5fdb8686a7fe4743d84d2c7a6578db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95b639e7a140d4606a39492b3dd4455"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa95b639e7a140d4606a39492b3dd4455">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:aa95b639e7a140d4606a39492b3dd4455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4714cba71c744df963874d0792b2a761"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4714cba71c744df963874d0792b2a761">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:a4714cba71c744df963874d0792b2a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81722db7ba91b62757143a293471ceb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a81722db7ba91b62757143a293471ceb4">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:a81722db7ba91b62757143a293471ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725a2e5b711bfdb47c64be8dfbd2909e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a725a2e5b711bfdb47c64be8dfbd2909e">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:a725a2e5b711bfdb47c64be8dfbd2909e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4ff9033f16cf0ec6c3fd2e3c8ba631"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abc4ff9033f16cf0ec6c3fd2e3c8ba631">retrieve_semantic_information</a> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle, SemanticTag tag, const void *&amp;result, size_t &amp;size, bool can_fail=false, bool wait_until_ready=false)</td></tr>
<tr class="separator:abc4ff9033f16cf0ec6c3fd2e3c8ba631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0cd42dd4eace605fd30e31ece8b7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adb0cd42dd4eace605fd30e31ece8b7ee">retrieve_name</a> (TaskID task_id, const char *&amp;result)</td></tr>
<tr class="separator:adb0cd42dd4eace605fd30e31ece8b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd3b1f63106adf00cb07e08aae3cbaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aebd3b1f63106adf00cb07e08aae3cbaf">retrieve_name</a> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, const char *&amp;result)</td></tr>
<tr class="separator:aebd3b1f63106adf00cb07e08aae3cbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2f0223794f00eed6fab2c5540a499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a64c2f0223794f00eed6fab2c5540a499">retrieve_name</a> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, const char *&amp;result)</td></tr>
<tr class="separator:a64c2f0223794f00eed6fab2c5540a499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bbc60633b79321905756d0bb9f20c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a84bbc60633b79321905756d0bb9f20c1">retrieve_name</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, const char *&amp;result)</td></tr>
<tr class="separator:a84bbc60633b79321905756d0bb9f20c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2b11b863cf5b95223cf699decf55f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adb2b11b863cf5b95223cf699decf55f6">retrieve_name</a> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid, const char *&amp;result)</td></tr>
<tr class="separator:adb2b11b863cf5b95223cf699decf55f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf9724b6f03af6cd266cb1639fedf56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5cf9724b6f03af6cd266cb1639fedf56">retrieve_name</a> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, const char *&amp;result)</td></tr>
<tr class="separator:a5cf9724b6f03af6cd266cb1639fedf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f912fbbb69931f7739916db546578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#acc8f912fbbb69931f7739916db546578">retrieve_name</a> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle, const char *&amp;result)</td></tr>
<tr class="separator:acc8f912fbbb69931f7739916db546578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c83c4c48550b75c3c0676bed306de0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a22c83c4c48550b75c3c0676bed306de0">print_once</a> (Context ctx, FILE *f, const char *message)</td></tr>
<tr class="separator:a22c83c4c48550b75c3c0676bed306de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eda2e1e351ddb779295fd6d6313edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a71eda2e1e351ddb779295fd6d6313edd">log_once</a> (Context ctx, Realm::LoggerMessage &amp;message)</td></tr>
<tr class="separator:a71eda2e1e351ddb779295fd6d6313edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899e01c313c6ef26865f873e9232887"><td class="memItemLeft" align="right" valign="top">Mapping::MapperRuntime *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad899e01c313c6ef26865f873e9232887">get_mapper_runtime</a> (void)</td></tr>
<tr class="separator:ad899e01c313c6ef26865f873e9232887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710dd7fbc03f776789c4b0ee538a50f9"><td class="memItemLeft" align="right" valign="top">MapperID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a710dd7fbc03f776789c4b0ee538a50f9">generate_dynamic_mapper_id</a> (void)</td></tr>
<tr class="separator:a710dd7fbc03f776789c4b0ee538a50f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfa9087b19781f3a645e7dba9d45557"><td class="memItemLeft" align="right" valign="top">MapperID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1cfa9087b19781f3a645e7dba9d45557">generate_library_mapper_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:a1cfa9087b19781f3a645e7dba9d45557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c2cb81609323acebc086f0da983ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a099c2cb81609323acebc086f0da983ee">add_mapper</a> (MapperID map_id, Mapping::Mapper *mapper, Processor proc=Processor::NO_PROC)</td></tr>
<tr class="separator:a099c2cb81609323acebc086f0da983ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d346beb15757301ecd5bc51395361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a6c7d346beb15757301ecd5bc51395361">replace_default_mapper</a> (Mapping::Mapper *mapper, Processor proc=Processor::NO_PROC)</td></tr>
<tr class="separator:a6c7d346beb15757301ecd5bc51395361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff251c3730c6ef38345121889807c879"><td class="memItemLeft" align="right" valign="top">ProjectionID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aff251c3730c6ef38345121889807c879">generate_dynamic_projection_id</a> (void)</td></tr>
<tr class="separator:aff251c3730c6ef38345121889807c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8752180deb9b0547d2eaab51e78a45f"><td class="memItemLeft" align="right" valign="top">ProjectionID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa8752180deb9b0547d2eaab51e78a45f">generate_library_projection_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:aa8752180deb9b0547d2eaab51e78a45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed570eb66ecffb1772de58c122d521dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aed570eb66ecffb1772de58c122d521dd">register_projection_functor</a> (ProjectionID pid, <a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a> *functor, bool silence_warnings=false, const char *warning_string=NULL)</td></tr>
<tr class="separator:aed570eb66ecffb1772de58c122d521dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218b7f14c3a92c47be12d0ddcb77694"><td class="memItemLeft" align="right" valign="top">ShardingID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3218b7f14c3a92c47be12d0ddcb77694">generate_dynamic_sharding_id</a> (void)</td></tr>
<tr class="separator:a3218b7f14c3a92c47be12d0ddcb77694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3cbdfa056de737b5187c350a0000a8"><td class="memItemLeft" align="right" valign="top">ShardingID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ace3cbdfa056de737b5187c350a0000a8">generate_library_sharding_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:ace3cbdfa056de737b5187c350a0000a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e7851463eecc0773ca7e3b70a7f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aaf4e7851463eecc0773ca7e3b70a7f04">register_sharding_functor</a> (ShardingID sid, <a class="el" href="class_legion_1_1_sharding_functor.html">ShardingFunctor</a> *functor, bool silence_warnings=false, const char *warning_string=NULL)</td></tr>
<tr class="separator:aaf4e7851463eecc0773ca7e3b70a7f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb54cd8076ac9a0604bba29bff183bc"><td class="memItemLeft" align="right" valign="top">ReductionOpID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#affb54cd8076ac9a0604bba29bff183bc">generate_dynamic_reduction_id</a> (void)</td></tr>
<tr class="separator:affb54cd8076ac9a0604bba29bff183bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96be12e76153f4dc356421f7072db801"><td class="memItemLeft" align="right" valign="top">ReductionOpID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a96be12e76153f4dc356421f7072db801">generate_library_reduction_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:a96be12e76153f4dc356421f7072db801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c70f76c03a26412e89206df8103e5a1"><td class="memItemLeft" align="right" valign="top">CustomSerdezID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4c70f76c03a26412e89206df8103e5a1">generate_dynamic_serdez_id</a> (void)</td></tr>
<tr class="separator:a4c70f76c03a26412e89206df8103e5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2e4e8576f3b6408824b643b79f79b2"><td class="memItemLeft" align="right" valign="top">CustomSerdezID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8d2e4e8576f3b6408824b643b79f79b2">generate_library_serdez_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:a8d2e4e8576f3b6408824b643b79f79b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b45946044f7672c734111a4960d4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a97b45946044f7672c734111a4960d4c2">launch_top_level_task</a> (const <a class="el" href="struct_legion_1_1_task_launcher.html">TaskLauncher</a> &amp;launcher)</td></tr>
<tr class="separator:a97b45946044f7672c734111a4960d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd4333221923bb6e88d8ab6da24cea9"><td class="memItemLeft" align="right" valign="top">Context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1fd4333221923bb6e88d8ab6da24cea9">begin_implicit_task</a> (TaskID top_task_id, MapperID mapper_id, Processor::Kind proc_kind, const char *task_name=NULL, bool control_replicable=false, unsigned shard_per_address_space=1, int shard_id=-1)</td></tr>
<tr class="separator:a1fd4333221923bb6e88d8ab6da24cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c72c6636df75996f3719961fdea4716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3c72c6636df75996f3719961fdea4716">unbind_implicit_task_from_external_thread</a> (Context ctx)</td></tr>
<tr class="separator:a3c72c6636df75996f3719961fdea4716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba31e40f227459297e0d98901582af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aacba31e40f227459297e0d98901582af">bind_implicit_task_to_external_thread</a> (Context ctx)</td></tr>
<tr class="separator:aacba31e40f227459297e0d98901582af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64e8a16a1b5769cd8542338f0200100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa64e8a16a1b5769cd8542338f0200100">finish_implicit_task</a> (Context ctx)</td></tr>
<tr class="separator:aa64e8a16a1b5769cd8542338f0200100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc6acec0e7ede9fd3e052b3c3e2df6b"><td class="memItemLeft" align="right" valign="top">LayoutConstraintID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aadc6acec0e7ede9fd3e052b3c3e2df6b">register_layout</a> (const <a class="el" href="struct_legion_1_1_layout_constraint_registrar.html">LayoutConstraintRegistrar</a> &amp;registrar)</td></tr>
<tr class="separator:aadc6acec0e7ede9fd3e052b3c3e2df6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495979ba6641b365c2c0b9ee4be7818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae495979ba6641b365c2c0b9ee4be7818">release_layout</a> (LayoutConstraintID layout_id)</td></tr>
<tr class="separator:ae495979ba6641b365c2c0b9ee4be7818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997dbe4572afcee60009c90f10f01e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a997dbe4572afcee60009c90f10f01e6c">get_layout_constraint_field_space</a> (LayoutConstraintID layout_id)</td></tr>
<tr class="separator:a997dbe4572afcee60009c90f10f01e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d59c74088bf40aac44f4ac6e67bf09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a6d59c74088bf40aac44f4ac6e67bf09e">get_layout_constraints</a> (LayoutConstraintID layout_id, LayoutConstraintSet &amp;layout_constraints)</td></tr>
<tr class="separator:a6d59c74088bf40aac44f4ac6e67bf09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365a5387d02cedee6a70d89d883f0cb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac365a5387d02cedee6a70d89d883f0cb">get_layout_constraints_name</a> (LayoutConstraintID layout_id)</td></tr>
<tr class="separator:ac365a5387d02cedee6a70d89d883f0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a6a1cd0c1a87157a916681b0c6a21"><td class="memItemLeft" align="right" valign="top">TaskID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a249a6a1cd0c1a87157a916681b0c6a21">generate_dynamic_task_id</a> (void)</td></tr>
<tr class="separator:a249a6a1cd0c1a87157a916681b0c6a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9e3ca9a0efc36d04bc2bd7e2c8ae4"><td class="memItemLeft" align="right" valign="top">TaskID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8cc9e3ca9a0efc36d04bc2bd7e2c8ae4">generate_library_task_ids</a> (const char *name, size_t count)</td></tr>
<tr class="separator:a8cc9e3ca9a0efc36d04bc2bd7e2c8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9208ecb02d6fce840202193227fe1250"><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a9208ecb02d6fce840202193227fe1250"><td class="memTemplItemLeft" align="right" valign="top">VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9208ecb02d6fce840202193227fe1250">register_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a9208ecb02d6fce840202193227fe1250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62da327be82232e97077f207805e01ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:a62da327be82232e97077f207805e01ec"><td class="memTemplItemLeft" align="right" valign="top">VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a62da327be82232e97077f207805e01ec">register_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const UDT &amp;user_data, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a62da327be82232e97077f207805e01ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25379d3ea373e9c9e1eeb6c06fbfa8ed"><td class="memTemplParams" colspan="2">template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a25379d3ea373e9c9e1eeb6c06fbfa8ed"><td class="memTemplItemLeft" align="right" valign="top">VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a25379d3ea373e9c9e1eeb6c06fbfa8ed">register_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a25379d3ea373e9c9e1eeb6c06fbfa8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5838b3cc5e9ce88b9e37b6790179cc1d"><td class="memTemplParams" colspan="2">template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:a5838b3cc5e9ce88b9e37b6790179cc1d"><td class="memTemplItemLeft" align="right" valign="top">VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5838b3cc5e9ce88b9e37b6790179cc1d">register_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const UDT &amp;user_data, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a5838b3cc5e9ce88b9e37b6790179cc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de4e1d191026fd2d0af78a6495e4d43"><td class="memItemLeft" align="right" valign="top">VariantID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4de4e1d191026fd2d0af78a6495e4d43">register_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const CodeDescriptor &amp;codedesc, const void *user_data=NULL, size_t user_len=0, size_t return_type_size=LEGION_MAX_RETURN_SIZE, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a4de4e1d191026fd2d0af78a6495e4d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d5f51281659e1ced9b2c43ac2cfbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a331d5f51281659e1ced9b2c43ac2cfbd"></a>
ShardID&#160;</td><td class="memItemRight" valign="bottom"><b>get_shard_id</b> (Context ctx, bool I_know_what_I_am_doing=false)</td></tr>
<tr class="separator:a331d5f51281659e1ced9b2c43ac2cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52660c9bb2c9630a3c445b8028609035"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52660c9bb2c9630a3c445b8028609035"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_shards</b> (Context ctx, bool I_know_what_I_am_doing=false)</td></tr>
<tr class="separator:a52660c9bb2c9630a3c445b8028609035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0b3d4e90852fe581ec4cbcab476baa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac0b3d4e90852fe581ec4cbcab476baa7">create_index_space</a> (Context ctx, const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;bounds, TypeTag type_tag=0, const char *provenance=NULL)</td></tr>
<tr class="separator:ac0b3d4e90852fe581ec4cbcab476baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970347542627ec74c5b177ec67f40ba3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a970347542627ec74c5b177ec67f40ba3"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a970347542627ec74c5b177ec67f40ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space</b> (Context ctx, const Rect&lt; DIM, COORD_T &gt; &amp;bounds, const char *provenance=NULL)</td></tr>
<tr class="separator:a970347542627ec74c5b177ec67f40ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497232a26d782002aab1ad1ab0b82c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8497232a26d782002aab1ad1ab0b82c4"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a8497232a26d782002aab1ad1ab0b82c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space</b> (Context ctx, const DomainT&lt; DIM, COORD_T &gt; &amp;bounds, const char *provenance=NULL)</td></tr>
<tr class="separator:a8497232a26d782002aab1ad1ab0b82c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a588d11c58c54b46aec62bd0e3edb1fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a588d11c58c54b46aec62bd0e3edb1fd4">create_index_space</a> (Context ctx, size_t dimensions, const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f, TypeTag type_tag=0, const char *provenance=NULL)</td></tr>
<tr class="separator:a588d11c58c54b46aec62bd0e3edb1fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a501a99535276a39c0e9fe58722d52"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42a501a99535276a39c0e9fe58722d52"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a42a501a99535276a39c0e9fe58722d52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space</b> (Context ctx, const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f, const char *provenance=NULL)</td></tr>
<tr class="separator:a42a501a99535276a39c0e9fe58722d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ebd8334917853b4abdf391ffeaa31aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3ebd8334917853b4abdf391ffeaa31aa">create_index_space</a> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &gt; &amp;points, const char *provenance=NULL)</td></tr>
<tr class="separator:a3ebd8334917853b4abdf391ffeaa31aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3330850b274a2a291f5e4efcc60366"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f3330850b274a2a291f5e4efcc60366"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a2f3330850b274a2a291f5e4efcc60366"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space</b> (Context ctx, const std::vector&lt; Point&lt; DIM, COORD_T &gt; &gt; &amp;points, const char *provenance=NULL)</td></tr>
<tr class="separator:a2f3330850b274a2a291f5e4efcc60366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3c91c5dd72c1beae812fcf9887aa307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa3c91c5dd72c1beae812fcf9887aa307">create_index_space</a> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;rects, const char *provenance=NULL)</td></tr>
<tr class="separator:aa3c91c5dd72c1beae812fcf9887aa307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09302152747e4eb79b009e0f65a520e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09302152747e4eb79b009e0f65a520e6"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a09302152747e4eb79b009e0f65a520e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space</b> (Context ctx, const std::vector&lt; Rect&lt; DIM, COORD_T &gt; &gt; &amp;rects, const char *provenance=NULL)</td></tr>
<tr class="separator:a09302152747e4eb79b009e0f65a520e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a813dde334a85eb30bed007240dac5a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a813dde334a85eb30bed007240dac5a56">union_index_spaces</a> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;spaces, const char *provenance=NULL)</td></tr>
<tr class="separator:a813dde334a85eb30bed007240dac5a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb8193d3d7b3d0d385f4b91d8f6623"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34eb8193d3d7b3d0d385f4b91d8f6623"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a34eb8193d3d7b3d0d385f4b91d8f6623"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>union_index_spaces</b> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; &gt; &amp;spaces, const char *provenance=NULL)</td></tr>
<tr class="separator:a34eb8193d3d7b3d0d385f4b91d8f6623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5b676fe6ae1a35b50ba0c1bd649428b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa5b676fe6ae1a35b50ba0c1bd649428b">intersect_index_spaces</a> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;spaces, const char *provenance=NULL)</td></tr>
<tr class="separator:aa5b676fe6ae1a35b50ba0c1bd649428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4239c2b3d1969c9795be63dc4e9a16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a4239c2b3d1969c9795be63dc4e9a16"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a4a4239c2b3d1969c9795be63dc4e9a16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>intersect_index_spaces</b> (Context ctx, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; &gt; &amp;spaces, const char *provenance=NULL)</td></tr>
<tr class="separator:a4a4239c2b3d1969c9795be63dc4e9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abe24b579ab20fa57baafd450ab116ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abe24b579ab20fa57baafd450ab116ce1">subtract_index_spaces</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> left, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> right, const char *provenance=NULL)</td></tr>
<tr class="separator:abe24b579ab20fa57baafd450ab116ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db6f79317685394a1afd745b69735aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0db6f79317685394a1afd745b69735aa"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a0db6f79317685394a1afd745b69735aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract_index_spaces</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; left, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; right, const char *provenance=NULL)</td></tr>
<tr class="separator:a0db6f79317685394a1afd745b69735aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67493d677a98031068cec3d81895b0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a67493d677a98031068cec3d81895b0e2">create_equal_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a67493d677a98031068cec3d81895b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b73b1f1601a9b107d3fcb62b7c31b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b9b73b1f1601a9b107d3fcb62b7c31b"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a6b9b73b1f1601a9b107d3fcb62b7c31b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_equal_partition</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a6b9b73b1f1601a9b107d3fcb62b7c31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc39d964f62c5c923a09a11de58ceca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adc39d964f62c5c923a09a11de58ceca8">create_partition_by_weights</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, int &gt; &amp;weights, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:adc39d964f62c5c923a09a11de58ceca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef1615216d593902726072a907aa02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a23ef1615216d593902726072a907aa02"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a23ef1615216d593902726072a907aa02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_weights</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, const std::map&lt; Point&lt; COLOR_DIM, COLOR_COORD_T &gt;, int &gt; &amp;weights, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a23ef1615216d593902726072a907aa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8e81fa56b500ba256ac1bf92e885b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca8e81fa56b500ba256ac1bf92e885b1"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_partition_by_weights</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, size_t &gt; &amp;weights, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:aca8e81fa56b500ba256ac1bf92e885b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5470b7a4503d59f81d5e49f95c4db3f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5470b7a4503d59f81d5e49f95c4db3f"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:ab5470b7a4503d59f81d5e49f95c4db3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_weights</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, const std::map&lt; Point&lt; COLOR_DIM, COLOR_COORD_T &gt;, size_t &gt; &amp;weights, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:ab5470b7a4503d59f81d5e49f95c4db3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192bc86b99e2d8f663a6e6b94f278fda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192bc86b99e2d8f663a6e6b94f278fda"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_partition_by_weights</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;weights, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a192bc86b99e2d8f663a6e6b94f278fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18ad78e86cc093d47e6c0cc7fe8d32f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af18ad78e86cc093d47e6c0cc7fe8d32f"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:af18ad78e86cc093d47e6c0cc7fe8d32f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_weights</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;weights, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, size_t granularity=1, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:af18ad78e86cc093d47e6c0cc7fe8d32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2316d17a8248cedd61b0b6f6910838f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2316d17a8248cedd61b0b6f6910838f4">create_partition_by_union</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle1, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle2, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a2316d17a8248cedd61b0b6f6910838f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e7a5db88dc216c7bdeb5e501579bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa23e7a5db88dc216c7bdeb5e501579bc"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:aa23e7a5db88dc216c7bdeb5e501579bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_union</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle1, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle2, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:aa23e7a5db88dc216c7bdeb5e501579bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2f83d2e58f036b2e2d2ad653752d7417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2f83d2e58f036b2e2d2ad653752d7417">create_partition_by_intersection</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle1, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle2, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a2f83d2e58f036b2e2d2ad653752d7417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dbfec38c0529f4c8f0c203ad5df237"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14dbfec38c0529f4c8f0c203ad5df237"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a14dbfec38c0529f4c8f0c203ad5df237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_intersection</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle1, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle2, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a14dbfec38c0529f4c8f0c203ad5df237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9aa4ddd1be0da7dba779021f2daa1faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9aa4ddd1be0da7dba779021f2daa1faf">create_partition_by_intersection</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> partition, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, bool dominates=false, const char *provenance=NULL)</td></tr>
<tr class="separator:a9aa4ddd1be0da7dba779021f2daa1faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4708bb2c52fa6d29de9d9c238fae7"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5a4708bb2c52fa6d29de9d9c238fae7"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:af5a4708bb2c52fa6d29de9d9c238fae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_intersection</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; partition, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, bool dominates=false, const char *provenance=NULL)</td></tr>
<tr class="separator:af5a4708bb2c52fa6d29de9d9c238fae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb1d5252724c1165b6951b4c40f1b898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#afb1d5252724c1165b6951b4c40f1b898">create_partition_by_difference</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle1, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle2, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:afb1d5252724c1165b6951b4c40f1b898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5eacd2c86dc0d52920e085508ed405"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e5eacd2c86dc0d52920e085508ed405"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a0e5eacd2c86dc0d52920e085508ed405"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_difference</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle1, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle2, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a0e5eacd2c86dc0d52920e085508ed405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a930307028502cdb18bcfb56039745d4f"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a930307028502cdb18bcfb56039745d4f">create_cross_product_partitions</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle1, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle2, std::map&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> &gt; &amp;handles, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a930307028502cdb18bcfb56039745d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14c38d10a7c1be30d98f7b16d56c08b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab14c38d10a7c1be30d98f7b16d56c08b"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:ab14c38d10a7c1be30d98f7b16d56c08b"><td class="memTemplItemLeft" align="right" valign="top">Color&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_cross_product_partitions</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle1, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle2, typename std::map&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; &gt; &amp;handles, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:ab14c38d10a7c1be30d98f7b16d56c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af7ea5dfe590c909afdb1ab534b3fcfe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af7ea5dfe590c909afdb1ab534b3fcfe1">create_association</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> domain, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> domain_parent, FieldID domain_fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> range, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:af7ea5dfe590c909afdb1ab534b3fcfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68baf14b6af8366d79b58ce75f366c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a68baf14b6af8366d79b58ce75f366c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_bidirectional_association</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> domain, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> domain_parent, FieldID domain_fid, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> range, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> range_parent, FieldID range_fid, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a1a68baf14b6af8366d79b58ce75f366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5aa0695ed799346487f3f245b801df"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed5aa0695ed799346487f3f245b801df"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 &gt; </td></tr>
<tr class="memitem:aed5aa0695ed799346487f3f245b801df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_association</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; domain, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; domain_parent, FieldID domain_fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM2, COORD_T2 &gt; range, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:aed5aa0695ed799346487f3f245b801df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8034de52feca9194368803cdbed02f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f8034de52feca9194368803cdbed02f"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 &gt; </td></tr>
<tr class="memitem:a0f8034de52feca9194368803cdbed02f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_bidirectional_association</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; domain, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; domain_parent, FieldID domain_fid, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM2, COORD_T2 &gt; range, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM2, COORD_T2 &gt; range_parent, FieldID range_fid, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a0f8034de52feca9194368803cdbed02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad75fd95f229d19ada30337832ca8f3ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad75fd95f229d19ada30337832ca8f3ca">create_partition_by_restriction</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, <a class="el" href="class_legion_1_1_domain_transform.html">DomainTransform</a> transform, <a class="el" href="class_legion_1_1_domain.html">Domain</a> extent, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:ad75fd95f229d19ada30337832ca8f3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252bf4eae7e233f4beae0496b77dd15b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a252bf4eae7e233f4beae0496b77dd15b"></a>
template&lt;int DIM, int COLOR_DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a252bf4eae7e233f4beae0496b77dd15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_restriction</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COORD_T &gt; color_space, Transform&lt; DIM, COLOR_DIM, COORD_T &gt; transform, Rect&lt; DIM, COORD_T &gt; extent, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a252bf4eae7e233f4beae0496b77dd15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac878d96de9f646c4d9e98da3950d7a1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac878d96de9f646c4d9e98da3950d7a1f">create_partition_by_blockify</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> blocking_factor, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:ac878d96de9f646c4d9e98da3950d7a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dd81e489f1997325228cd2230c722"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd4dd81e489f1997325228cd2230c722"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:acd4dd81e489f1997325228cd2230c722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_blockify</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; DIM, COORD_T &gt; blocking_factor, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:acd4dd81e489f1997325228cd2230c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aef6fe949121cc5675bc30b9a271f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a50aef6fe949121cc5675bc30b9a271f7">create_partition_by_blockify</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> blockify_factor, <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> origin, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a50aef6fe949121cc5675bc30b9a271f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa977ae85940f411e6fbb1d1254222765"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa977ae85940f411e6fbb1d1254222765"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:aa977ae85940f411e6fbb1d1254222765"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_blockify</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; DIM, COORD_T &gt; blocking_factor, Point&lt; DIM, COORD_T &gt; origin, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:aa977ae85940f411e6fbb1d1254222765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f30c909133a89f0c5ae99a92d54d1f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5f30c909133a89f0c5ae99a92d54d1f6">create_partition_by_domain</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;domains, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, bool perform_intersections=true, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a5f30c909133a89f0c5ae99a92d54d1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990495b721616503785bb70ce4827777"><td class="memTemplParams" colspan="2"><a class="anchor" id="a990495b721616503785bb70ce4827777"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a990495b721616503785bb70ce4827777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_domain</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, const std::map&lt; Point&lt; COLOR_DIM, COLOR_COORD_T &gt;, DomainT&lt; DIM, COORD_T &gt; &gt; &amp;domains, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, bool perform_intersections=true, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a990495b721616503785bb70ce4827777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f028a0614677a5f9fab2c700dfde3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a98f028a0614677a5f9fab2c700dfde3c">create_partition_by_domain</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;domain_future_map, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, bool perform_intersections=true, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a98f028a0614677a5f9fab2c700dfde3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544f4384cb5009d1ba42eacf1c37c811"><td class="memTemplParams" colspan="2"><a class="anchor" id="a544f4384cb5009d1ba42eacf1c37c811"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a544f4384cb5009d1ba42eacf1c37c811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_domain</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;domain_future_map, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, bool perform_intersections=true, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a544f4384cb5009d1ba42eacf1c37c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac3eff619ee6af41d64afc6dcfab212f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac3eff619ee6af41d64afc6dcfab212f1">create_partition_by_field</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, PartitionKind part_kind=LEGION_DISJOINT_KIND, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:ac3eff619ee6af41d64afc6dcfab212f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38224a48b0571c10f20860af166b5e"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe38224a48b0571c10f20860af166b5e"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:afe38224a48b0571c10f20860af166b5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_field</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; handle, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, PartitionKind part_kind=LEGION_DISJOINT_KIND, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:afe38224a48b0571c10f20860af166b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a990d3750e296d56d146bf5d67f4e49c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a990d3750e296d56d146bf5d67f4e49c4">create_partition_by_image</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> projection, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a990d3750e296d56d146bf5d67f4e49c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fa482a295cce56db1d60af7360f54f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01fa482a295cce56db1d60af7360f54f"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a01fa482a295cce56db1d60af7360f54f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM2, COORD_T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_image</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM2, COORD_T2 &gt; handle, <a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM1, COORD_T1 &gt; projection, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a01fa482a295cce56db1d60af7360f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add45f4eaa7d6e40322310a65c4dad838"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add45f4eaa7d6e40322310a65c4dad838"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_partition_by_image_range</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> projection, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:add45f4eaa7d6e40322310a65c4dad838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60d69acf10f575765faa600b4f21762"><td class="memTemplParams" colspan="2"><a class="anchor" id="af60d69acf10f575765faa600b4f21762"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:af60d69acf10f575765faa600b4f21762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM2, COORD_T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_image_range</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM2, COORD_T2 &gt; handle, <a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM1, COORD_T1 &gt; projection, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:af60d69acf10f575765faa600b4f21762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae479d425cb2ce28ca0e5f8c4352803b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae479d425cb2ce28ca0e5f8c4352803b7">create_partition_by_preimage</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> projection, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:ae479d425cb2ce28ca0e5f8c4352803b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebaf2e5aae067e06912c75732546c96"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ebaf2e5aae067e06912c75732546c96"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a9ebaf2e5aae067e06912c75732546c96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM1, COORD_T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_preimage</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM2, COORD_T2 &gt; projection, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; handle, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a9ebaf2e5aae067e06912c75732546c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c1e2987bc9bca181db1a6294f61292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22c1e2987bc9bca181db1a6294f61292"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_partition_by_preimage_range</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> projection, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:a22c1e2987bc9bca181db1a6294f61292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade4f13f7d4deea7f70e30696bae0f7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aade4f13f7d4deea7f70e30696bae0f7c"></a>
template&lt;int DIM1, typename COORD_T1 , int DIM2, typename COORD_T2 , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:aade4f13f7d4deea7f70e30696bae0f7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM1, COORD_T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_partition_by_preimage_range</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM2, COORD_T2 &gt; projection, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; handle, <a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM1, COORD_T1 &gt; parent, FieldID fid, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, MapperID id=0, MappingTagID tag=0, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> map_arg=<a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>(), const char *provenance=NULL)</td></tr>
<tr class="separator:aade4f13f7d4deea7f70e30696bae0f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3f216d0f931bf8e8192d8d4fc2205278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3f216d0f931bf8e8192d8d4fc2205278">create_pending_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a3f216d0f931bf8e8192d8d4fc2205278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777af344354d7cf1ffa8a865a9a6b73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3777af344354d7cf1ffa8a865a9a6b73"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a3777af344354d7cf1ffa8a865a9a6b73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_pending_partition</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, COLOR_COORD_T &gt; color_space, PartitionKind part_kind=LEGION_COMPUTE_KIND, Color color=LEGION_AUTO_GENERATE_ID, const char *provenance=NULL)</td></tr>
<tr class="separator:a3777af344354d7cf1ffa8a865a9a6b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abdee40ed6877e577ef4c4a62f775230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abdee40ed6877e577ef4c4a62f775230e">create_index_space_union</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;handles, const char *provenance=NULL)</td></tr>
<tr class="separator:abdee40ed6877e577ef4c4a62f775230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f20559edd1cb3827e4aaa481121df6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63f20559edd1cb3827e4aaa481121df6"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a63f20559edd1cb3827e4aaa481121df6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space_union</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color, const typename std::vector&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; &gt; &amp;handles, const char *provenance=NULL)</td></tr>
<tr class="separator:a63f20559edd1cb3827e4aaa481121df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af46287bec00ed15ebd7d50fa6ba1a55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af46287bec00ed15ebd7d50fa6ba1a55d">create_index_space_union</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, const char *provenance=NULL)</td></tr>
<tr class="separator:af46287bec00ed15ebd7d50fa6ba1a55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb4c10b2c3c37c57919f4c1507b894a"><td class="memTemplParams" colspan="2"><a class="anchor" id="affb4c10b2c3c37c57919f4c1507b894a"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:affb4c10b2c3c37c57919f4c1507b894a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space_union</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle, const char *provenance=NULL)</td></tr>
<tr class="separator:affb4c10b2c3c37c57919f4c1507b894a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7e49eee0e9cac0f4cd363b30bf5b68ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7e49eee0e9cac0f4cd363b30bf5b68ea">create_index_space_intersection</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;handles, const char *provenance=NULL)</td></tr>
<tr class="separator:a7e49eee0e9cac0f4cd363b30bf5b68ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57ad22ead7fa710fa9d42ce56d11c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f57ad22ead7fa710fa9d42ce56d11c0"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a6f57ad22ead7fa710fa9d42ce56d11c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space_intersection</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color, const typename std::vector&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; &gt; &amp;handles, const char *provenance=NULL)</td></tr>
<tr class="separator:a6f57ad22ead7fa710fa9d42ce56d11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a703ed6a38c874e44d1d2cde2c7d2d9de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a703ed6a38c874e44d1d2cde2c7d2d9de">create_index_space_intersection</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, const char *provenannce=NULL)</td></tr>
<tr class="separator:a703ed6a38c874e44d1d2cde2c7d2d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add02670d51e7505d5e381e3a8b3f8e56"><td class="memTemplParams" colspan="2"><a class="anchor" id="add02670d51e7505d5e381e3a8b3f8e56"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:add02670d51e7505d5e381e3a8b3f8e56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space_intersection</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle, const char *provenance=NULL)</td></tr>
<tr class="separator:add02670d51e7505d5e381e3a8b3f8e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e29f710aa1a3b4a68f2fdaf47fbc57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1e29f710aa1a3b4a68f2fdaf47fbc57e">create_index_space_difference</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> initial, const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;handles, const char *provenancne=NULL)</td></tr>
<tr class="separator:a1e29f710aa1a3b4a68f2fdaf47fbc57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0216dbc439b42a340a8c3081967292"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd0216dbc439b42a340a8c3081967292"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:acd0216dbc439b42a340a8c3081967292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_index_space_difference</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; initial, const typename std::vector&lt; <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; &gt; &amp;handles, const char *provenance=NULL)</td></tr>
<tr class="separator:acd0216dbc439b42a340a8c3081967292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2500d5ff24ddb3dd51ed72fa27059092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2500d5ff24ddb3dd51ed72fa27059092">get_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, Color color)</td></tr>
<tr class="separator:a2500d5ff24ddb3dd51ed72fa27059092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057db0ec3262c1f0aaee03d295fef53b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a057db0ec3262c1f0aaee03d295fef53b"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:a057db0ec3262c1f0aaee03d295fef53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9607edb7ee631d584076058e2a6301c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9607edb7ee631d584076058e2a6301c7"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, Color color)</td></tr>
<tr class="separator:a9607edb7ee631d584076058e2a6301c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dab2bd9d4c4f141d6593b5d39a43bc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dab2bd9d4c4f141d6593b5d39a43bc7"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:a1dab2bd9d4c4f141d6593b5d39a43bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcda8e23a2a23deda88e602303b83af"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5fcda8e23a2a23deda88e602303b83af"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a5fcda8e23a2a23deda88e602303b83af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_partition</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, Color color)</td></tr>
<tr class="separator:a5fcda8e23a2a23deda88e602303b83af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2db78ed39353a434fad6b403c52fb5a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2db78ed39353a434fad6b403c52fb5a8">has_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, Color color)</td></tr>
<tr class="separator:a2db78ed39353a434fad6b403c52fb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791df269b4a31a4da9a0bb1bb588f46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5791df269b4a31a4da9a0bb1bb588f46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_index_partition</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:a5791df269b4a31a4da9a0bb1bb588f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5fbcf8aa4747719a112921c243b093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5fbcf8aa4747719a112921c243b093"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, Color color)</td></tr>
<tr class="separator:aaa5fbcf8aa4747719a112921c243b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd11c32778364d95c0d32578ab7ab727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd11c32778364d95c0d32578ab7ab727"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:acd11c32778364d95c0d32578ab7ab727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef40839300a53c2fcfd99992ecedf54"><td class="memTemplParams" colspan="2"><a class="anchor" id="acef40839300a53c2fcfd99992ecedf54"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:acef40839300a53c2fcfd99992ecedf54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_index_partition</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; parent, Color color)</td></tr>
<tr class="separator:acef40839300a53c2fcfd99992ecedf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaf32a26bbbbf07ba7f7aca9d4109d589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aaf32a26bbbbf07ba7f7aca9d4109d589">get_index_subspace</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, Color color)</td></tr>
<tr class="separator:aaf32a26bbbbf07ba7f7aca9d4109d589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d085c7da5f675ec7be5a63b256cde0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5d085c7da5f675ec7be5a63b256cde0"></a>
<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_subspace</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:af5d085c7da5f675ec7be5a63b256cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0c8c4a4df814803d00ea41eab236d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b0c8c4a4df814803d00ea41eab236d8"></a>
<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_subspace</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, Color color)</td></tr>
<tr class="separator:a1b0c8c4a4df814803d00ea41eab236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0501d05c4a849e5a68a66c90d231ca54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0501d05c4a849e5a68a66c90d231ca54"></a>
<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_subspace</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:a0501d05c4a849e5a68a66c90d231ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1096791031f495098e652c442bf4cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a1096791031f495098e652c442bf4cc"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a3a1096791031f495098e652c442bf4cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_subspace</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; p, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color)</td></tr>
<tr class="separator:a3a1096791031f495098e652c442bf4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3614582fe1829077771a7c6003654dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa3614582fe1829077771a7c6003654dc">has_index_subspace</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:aa3614582fe1829077771a7c6003654dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6938297a785780672e563d23eaae5aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6938297a785780672e563d23eaae5aa0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_index_subspace</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;color)</td></tr>
<tr class="separator:a6938297a785780672e563d23eaae5aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bb49dc9e646c1748905de9c723aa67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a35bb49dc9e646c1748905de9c723aa67"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a35bb49dc9e646c1748905de9c723aa67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_index_subspace</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; p, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color)</td></tr>
<tr class="separator:a35bb49dc9e646c1748905de9c723aa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb0ee94d82c36b374cf3804a48f7a16b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adb0ee94d82c36b374cf3804a48f7a16b">has_multiple_domains</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:adb0ee94d82c36b374cf3804a48f7a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b476d85a5242c497aca04e7b7eacdfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b476d85a5242c497aca04e7b7eacdfe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_multiple_domains</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a5b476d85a5242c497aca04e7b7eacdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafd8990d5deccad8024d786a4f9c44ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aafd8990d5deccad8024d786a4f9c44ed">get_index_space_domain</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:aafd8990d5deccad8024d786a4f9c44ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6e0a09051d249afbae1d3eee6cf9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf6e0a09051d249afbae1d3eee6cf9a"></a>
<a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_domain</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a2cf6e0a09051d249afbae1d3eee6cf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2a7ff68fac6c5ffe51bd24a7768fa0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f2a7ff68fac6c5ffe51bd24a7768fa0"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a7f2a7ff68fac6c5ffe51bd24a7768fa0"><td class="memTemplItemLeft" align="right" valign="top">DomainT&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_space_domain</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a7f2a7ff68fac6c5ffe51bd24a7768fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1afb2c536734219c0f4c8973219c1e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1afb2c536734219c0f4c8973219c1e1e">get_index_space_domains</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, std::vector&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;domains)</td></tr>
<tr class="separator:a1afb2c536734219c0f4c8973219c1e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450b796ad88e97db6b72442650087cfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a450b796ad88e97db6b72442650087cfe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_domains</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, std::vector&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;domains)</td></tr>
<tr class="separator:a450b796ad88e97db6b72442650087cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac5a30d26bbe0213364d650a180c91259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac5a30d26bbe0213364d650a180c91259">get_index_partition_color_space</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:ac5a30d26bbe0213364d650a180c91259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ab54296aec0b41f889e1c7d9d23557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1ab54296aec0b41f889e1c7d9d23557"></a>
<a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_color_space</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:ae1ab54296aec0b41f889e1c7d9d23557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9b12ea4ac211db1f23b4d8c42c0ce9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca9b12ea4ac211db1f23b4d8c42c0ce9"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:aca9b12ea4ac211db1f23b4d8c42c0ce9"><td class="memTemplItemLeft" align="right" valign="top">DomainT&lt; COLOR_DIM, COLOR_COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_partition_color_space</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; p)</td></tr>
<tr class="separator:aca9b12ea4ac211db1f23b4d8c42c0ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a442a5007d55a2fc1bec4ebfd9d847670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a442a5007d55a2fc1bec4ebfd9d847670">get_index_partition_color_space_name</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:a442a5007d55a2fc1bec4ebfd9d847670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeed8fee2ac560f3c65f8b5d000c3cd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeed8fee2ac560f3c65f8b5d000c3cd6"></a>
<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_color_space_name</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:adeed8fee2ac560f3c65f8b5d000c3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e003cbcb2088dbc628787b94ac055b"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2e003cbcb2088dbc628787b94ac055b"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:af2e003cbcb2088dbc628787b94ac055b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; COLOR_DIM, <br class="typebreak"/>
COLOR_COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_partition_color_space_name</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; p)</td></tr>
<tr class="separator:af2e003cbcb2088dbc628787b94ac055b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a166661797fec45438f9e87a778bcb143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a166661797fec45438f9e87a778bcb143">get_index_space_partition_colors</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> sp, std::set&lt; Color &gt; &amp;colors)</td></tr>
<tr class="separator:a166661797fec45438f9e87a778bcb143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928ac29f99353a6ac90b9abe6271bf0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a928ac29f99353a6ac90b9abe6271bf0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_partition_colors</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> sp, std::set&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &gt; &amp;colors)</td></tr>
<tr class="separator:a928ac29f99353a6ac90b9abe6271bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedff863050a958a1e82fe9b3b982f26a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedff863050a958a1e82fe9b3b982f26a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_partition_colors</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> sp, std::set&lt; Color &gt; &amp;colors)</td></tr>
<tr class="separator:aedff863050a958a1e82fe9b3b982f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76241d1403cc69705dcf04581e6508a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae76241d1403cc69705dcf04581e6508a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_partition_colors</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> sp, std::set&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &gt; &amp;colors)</td></tr>
<tr class="separator:ae76241d1403cc69705dcf04581e6508a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2d5acf558aa75f074a816c9e897a9777"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2d5acf558aa75f074a816c9e897a9777">is_index_partition_disjoint</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:a2d5acf558aa75f074a816c9e897a9777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff41aa878ce5b8a95afb4ad2b0fbd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ff41aa878ce5b8a95afb4ad2b0fbd5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_index_partition_disjoint</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:a80ff41aa878ce5b8a95afb4ad2b0fbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36af197f72cc33ba83d0ada197002bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a36af197f72cc33ba83d0ada197002bb5">is_index_partition_complete</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:a36af197f72cc33ba83d0ada197002bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d22c59c4dcd93ed450f1243aa2ab5a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d22c59c4dcd93ed450f1243aa2ab5a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_index_partition_complete</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> p)</td></tr>
<tr class="separator:a6d22c59c4dcd93ed450f1243aa2ab5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8d6888ccb6eebe2f6451ae4bae7f5e4d"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8d6888ccb6eebe2f6451ae4bae7f5e4d">get_index_space_color</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a8d6888ccb6eebe2f6451ae4bae7f5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b57afe7f1c39e2bf4053f73bed0063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18b57afe7f1c39e2bf4053f73bed0063"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_color_point</b> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a18b57afe7f1c39e2bf4053f73bed0063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a05cc9f00040b46123d0c1afa2ae55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4a05cc9f00040b46123d0c1afa2ae55"></a>
Color&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_color</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:ad4a05cc9f00040b46123d0c1afa2ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484d6bb38eb263c19b61998d93d39863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484d6bb38eb263c19b61998d93d39863"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_color_point</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a484d6bb38eb263c19b61998d93d39863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4668988cd8a8111b25a56a6a622d613b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4668988cd8a8111b25a56a6a622d613b"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a4668988cd8a8111b25a56a6a622d613b"><td class="memTemplItemLeft" align="right" valign="top">Point&lt; COLOR_DIM, COLOR_COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_space_color</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a4668988cd8a8111b25a56a6a622d613b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7d69bd699220851a3b5ac75b281dbd62"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7d69bd699220851a3b5ac75b281dbd62">get_index_partition_color</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a7d69bd699220851a3b5ac75b281dbd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3492803f872b6543acc4ae8ba8f6d713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3492803f872b6543acc4ae8ba8f6d713"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_color_point</b> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a3492803f872b6543acc4ae8ba8f6d713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b3198c0b745e23a27d13b15cca04bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b3198c0b745e23a27d13b15cca04bf"></a>
Color&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_color</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a12b3198c0b745e23a27d13b15cca04bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff19d2a8d55256562c28352f5f232c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ff19d2a8d55256562c28352f5f232c2"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_color_point</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a2ff19d2a8d55256562c28352f5f232c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac3eda0d64b2aced859894d2967e26ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac3eda0d64b2aced859894d2967e26ccb">get_parent_index_space</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:ac3eda0d64b2aced859894d2967e26ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe435036d39ab50097b350f1a5ebd764"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe435036d39ab50097b350f1a5ebd764"></a>
<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_parent_index_space</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:afe435036d39ab50097b350f1a5ebd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490d123b67f747f79c7e34002fcd3101"><td class="memTemplParams" colspan="2"><a class="anchor" id="a490d123b67f747f79c7e34002fcd3101"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a490d123b67f747f79c7e34002fcd3101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_parent_index_space</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a490d123b67f747f79c7e34002fcd3101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1be0f5a074a6df83b283fc0acd5f3e83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a1be0f5a074a6df83b283fc0acd5f3e83">has_parent_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a1be0f5a074a6df83b283fc0acd5f3e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7d9f81183835ee141db6612ec26b7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7d9f81183835ee141db6612ec26b7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_parent_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a3f7d9f81183835ee141db6612ec26b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ca198b6c23f72a8e0269e50d49ae556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9ca198b6c23f72a8e0269e50d49ae556">get_parent_index_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a9ca198b6c23f72a8e0269e50d49ae556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3826beb1a53c16e9898a05e27329d0f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3826beb1a53c16e9898a05e27329d0f7"></a>
<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_parent_index_partition</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a3826beb1a53c16e9898a05e27329d0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c20422271cdfec6b5e3d461d2e57b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b4c20422271cdfec6b5e3d461d2e57b"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a6b4c20422271cdfec6b5e3d461d2e57b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_parent_index_partition</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a6b4c20422271cdfec6b5e3d461d2e57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae96ebe79753c43b45029c5b29e6d2182"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae96ebe79753c43b45029c5b29e6d2182">get_index_space_depth</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:ae96ebe79753c43b45029c5b29e6d2182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d4c4335deeeb57917429e46f210e50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d4c4335deeeb57917429e46f210e50"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_space_depth</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a18d4c4335deeeb57917429e46f210e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0cd3dbb5c492a9d29ba73df9f91367d3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0cd3dbb5c492a9d29ba73df9f91367d3">get_index_partition_depth</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a0cd3dbb5c492a9d29ba73df9f91367d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a34beb32f0eaca94f60950ae65ef55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3a34beb32f0eaca94f60950ae65ef55"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>get_index_partition_depth</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:ae3a34beb32f0eaca94f60950ae65ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8f321f0c4b28b50018bca830829f6f72"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8f321f0c4b28b50018bca830829f6f72">get_field_size</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid)</td></tr>
<tr class="separator:a8f321f0c4b28b50018bca830829f6f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eebf38d805a8d30a365f361c6e01d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07eebf38d805a8d30a365f361c6e01d6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_field_size</b> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, FieldID fid)</td></tr>
<tr class="separator:a07eebf38d805a8d30a365f361c6e01d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a383b27d0b35fb369684129730cd22abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a383b27d0b35fb369684129730cd22abf">get_field_space_fields</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, std::vector&lt; FieldID &gt; &amp;fields)</td></tr>
<tr class="separator:a383b27d0b35fb369684129730cd22abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775eaf53087b9adebb496036462f54ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a775eaf53087b9adebb496036462f54ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_field_space_fields</b> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, std::vector&lt; FieldID &gt; &amp;fields)</td></tr>
<tr class="separator:a775eaf53087b9adebb496036462f54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9139a80c882ad60d4e2f929926bd5746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9139a80c882ad60d4e2f929926bd5746">get_field_space_fields</a> (Context ctx, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, std::set&lt; FieldID &gt; &amp;fields)</td></tr>
<tr class="separator:a9139a80c882ad60d4e2f929926bd5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a696aec06ef25116ba15deed6f0a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07a696aec06ef25116ba15deed6f0a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_field_space_fields</b> (<a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> handle, std::set&lt; FieldID &gt; &amp;fields)</td></tr>
<tr class="separator:ab07a696aec06ef25116ba15deed6f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac4a5c2ac979cf345aef6f1228094a123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac4a5c2ac979cf345aef6f1228094a123">get_logical_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:ac4a5c2ac979cf345aef6f1228094a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5bebf64f696d790c18e71103d8329e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5bebf64f696d790c18e71103d8329e"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle)</td></tr>
<tr class="separator:a7c5bebf64f696d790c18e71103d8329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4490e3726e81d1979f4611bb84fc7b64"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4490e3726e81d1979f4611bb84fc7b64"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a4490e3726e81d1979f4611bb84fc7b64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_partition</b> (<a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a4490e3726e81d1979f4611bb84fc7b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae164cbd42bbe5a25996ae15eb8d24d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae164cbd42bbe5a25996ae15eb8d24d65">get_logical_partition_by_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, Color c)</td></tr>
<tr class="separator:ae164cbd42bbe5a25996ae15eb8d24d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420508b71462f0474763db19fc38e9d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a420508b71462f0474763db19fc38e9d6"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_by_color</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:a420508b71462f0474763db19fc38e9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb81a1e4fd478695b46d3bcdc3e6742"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb81a1e4fd478695b46d3bcdc3e6742"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_by_color</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, Color c)</td></tr>
<tr class="separator:adfb81a1e4fd478695b46d3bcdc3e6742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6a6ad0caa9d8acb8ddcfbaff549ba9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6a6ad0caa9d8acb8ddcfbaff549ba9"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_by_color</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:a5e6a6ad0caa9d8acb8ddcfbaff549ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e45427b85dab0aece64bd86780ccf"><td class="memTemplParams" colspan="2"><a class="anchor" id="af96e45427b85dab0aece64bd86780ccf"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:af96e45427b85dab0aece64bd86780ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_partition_by_color</b> (<a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; parent, Color c)</td></tr>
<tr class="separator:af96e45427b85dab0aece64bd86780ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab45e29c1e287be2765f1c7e36d51be7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab45e29c1e287be2765f1c7e36d51be7e">has_logical_partition_by_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:ab45e29c1e287be2765f1c7e36d51be7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9477fcfca1bb780f774df26085dc04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9477fcfca1bb780f774df26085dc04b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_logical_partition_by_color</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:af9477fcfca1bb780f774df26085dc04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9bc916db695b09528ffbf7ff84d22b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9bc916db695b09528ffbf7ff84d22b07">get_logical_partition_by_tree</a> (Context ctx, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fspace, RegionTreeID tid)</td></tr>
<tr class="separator:a9bc916db695b09528ffbf7ff84d22b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa2af7b8a6e34ef7f87d76926763c0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa2af7b8a6e34ef7f87d76926763c0c"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_by_tree</b> (<a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fspace, RegionTreeID tid)</td></tr>
<tr class="separator:acaa2af7b8a6e34ef7f87d76926763c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e140daf16a2efd561b36d3686ed560d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e140daf16a2efd561b36d3686ed560d"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a7e140daf16a2efd561b36d3686ed560d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_partition_by_tree</b> (<a class="el" href="class_legion_1_1_index_partition_t.html">IndexPartitionT</a>&lt; DIM, COORD_T &gt; handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fspace, RegionTreeID tid)</td></tr>
<tr class="separator:a7e140daf16a2efd561b36d3686ed560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a62ae579f7527fbb9bca25d97b664e643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a62ae579f7527fbb9bca25d97b664e643">get_logical_subregion</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a62ae579f7527fbb9bca25d97b664e643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edfaf872f7d7cda5089218d867f3c2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1edfaf872f7d7cda5089218d867f3c2d"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_subregion</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle)</td></tr>
<tr class="separator:a1edfaf872f7d7cda5089218d867f3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04367bfe17c89364aa3460d806448e7b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04367bfe17c89364aa3460d806448e7b"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a04367bfe17c89364aa3460d806448e7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_subregion</b> (<a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt; parent, <a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a04367bfe17c89364aa3460d806448e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adceef7f0d276d6809ee2915b45c57339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#adceef7f0d276d6809ee2915b45c57339">get_logical_subregion_by_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, Color c)</td></tr>
<tr class="separator:adceef7f0d276d6809ee2915b45c57339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45bd0e0e64e754e0d483301d282080f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac45bd0e0e64e754e0d483301d282080f"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_subregion_by_color</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:ac45bd0e0e64e754e0d483301d282080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0828f9b1b05d10d0d0632a2e63dffd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c0828f9b1b05d10d0d0632a2e63dffd"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_subregion_by_color</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, Color c)</td></tr>
<tr class="separator:a2c0828f9b1b05d10d0d0632a2e63dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccc63200594789cf4ef142dda1f1eff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeccc63200594789cf4ef142dda1f1eff"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_subregion_by_color</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:aeccc63200594789cf4ef142dda1f1eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc6c4bdcd149d6bd966014882a705fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fc6c4bdcd149d6bd966014882a705fe"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a1fc6c4bdcd149d6bd966014882a705fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_subregion_by_color</b> (<a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color)</td></tr>
<tr class="separator:a1fc6c4bdcd149d6bd966014882a705fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf8611680f7d1150f80e8512bee304fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abf8611680f7d1150f80e8512bee304fb">has_logical_subregion_by_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:abf8611680f7d1150f80e8512bee304fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f85c66d60cc63eaea635bf34ebfdcf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f85c66d60cc63eaea635bf34ebfdcf8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_logical_subregion_by_color</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> parent, const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;c)</td></tr>
<tr class="separator:a4f85c66d60cc63eaea635bf34ebfdcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b904439a4d1ca2faca7bb36afc2e34f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b904439a4d1ca2faca7bb36afc2e34f"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:a8b904439a4d1ca2faca7bb36afc2e34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_logical_subregion_by_color</b> (<a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt; parent, Point&lt; COLOR_DIM, COLOR_COORD_T &gt; color)</td></tr>
<tr class="separator:a8b904439a4d1ca2faca7bb36afc2e34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a654a54016487be150b4a2b22fe2dd368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a654a54016487be150b4a2b22fe2dd368">get_logical_subregion_by_tree</a> (Context ctx, <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fspace, RegionTreeID tid)</td></tr>
<tr class="separator:a654a54016487be150b4a2b22fe2dd368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac732b24e3baae76ee7dcb8b29ae312ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac732b24e3baae76ee7dcb8b29ae312ed"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_subregion_by_tree</b> (<a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> fspace, RegionTreeID tid)</td></tr>
<tr class="separator:ac732b24e3baae76ee7dcb8b29ae312ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d84c3674f2a823c5de15854594abf7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52d84c3674f2a823c5de15854594abf7"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a52d84c3674f2a823c5de15854594abf7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_subregion_by_tree</b> (<a class="el" href="class_legion_1_1_index_space_t.html">IndexSpaceT</a>&lt; DIM, COORD_T &gt; handle, <a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> space, RegionTreeID tid)</td></tr>
<tr class="separator:a52d84c3674f2a823c5de15854594abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae006fc7a66d9efe5f079e8e83fe56ba6"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae006fc7a66d9efe5f079e8e83fe56ba6">get_logical_region_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:ae006fc7a66d9efe5f079e8e83fe56ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c3eef3e4127a98ebe7f636b3c9a45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a477c3eef3e4127a98ebe7f636b3c9a45"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_region_color_point</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a477c3eef3e4127a98ebe7f636b3c9a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d3a18e5510f7d2706ad4fd3e96490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a167d3a18e5510f7d2706ad4fd3e96490"></a>
Color&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_region_color</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a167d3a18e5510f7d2706ad4fd3e96490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e620ffde69c5a76de40cb88b22eafcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e620ffde69c5a76de40cb88b22eafcd"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_region_color_point</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a4e620ffde69c5a76de40cb88b22eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac187401504ebeba2165b132b0c42a668"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac187401504ebeba2165b132b0c42a668"></a>
template&lt;int DIM, typename COORD_T , int COLOR_DIM, typename COLOR_COORD_T &gt; </td></tr>
<tr class="memitem:ac187401504ebeba2165b132b0c42a668"><td class="memTemplItemLeft" align="right" valign="top">Point&lt; COLOR_DIM, COLOR_COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_logical_region_color_point</b> (<a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:ac187401504ebeba2165b132b0c42a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a19959d25a409bd42b83f3c46effa78d2"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a19959d25a409bd42b83f3c46effa78d2">get_logical_partition_color</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:a19959d25a409bd42b83f3c46effa78d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2b7ca388009f2c66b02c5dda662759"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2b7ca388009f2c66b02c5dda662759"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_color_point</b> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:acf2b7ca388009f2c66b02c5dda662759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52f2406b071dcc28bec1a6dd262213c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52f2406b071dcc28bec1a6dd262213c"></a>
Color&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_color</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:aa52f2406b071dcc28bec1a6dd262213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55332273721187fa9ff7d7545b6d2251"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55332273721187fa9ff7d7545b6d2251"></a>
<a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_logical_partition_color_point</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:a55332273721187fa9ff7d7545b6d2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aecb1ba26ad2b6d3857afaff64bb9de93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aecb1ba26ad2b6d3857afaff64bb9de93">get_parent_logical_region</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:aecb1ba26ad2b6d3857afaff64bb9de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877fcd2e5888a4ef7bfe9db12074b01a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877fcd2e5888a4ef7bfe9db12074b01a"></a>
<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_parent_logical_region</b> (<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> handle)</td></tr>
<tr class="separator:a877fcd2e5888a4ef7bfe9db12074b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb9a7a49b39d43d33d74e65899b3e4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7fb9a7a49b39d43d33d74e65899b3e4c"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:a7fb9a7a49b39d43d33d74e65899b3e4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_parent_logical_region</b> (<a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:a7fb9a7a49b39d43d33d74e65899b3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4aab2f2c259fd3c203ad15374f38f991"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a4aab2f2c259fd3c203ad15374f38f991">has_parent_logical_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a4aab2f2c259fd3c203ad15374f38f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbe63b242c19bb72ef0fec9e9576588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdbe63b242c19bb72ef0fec9e9576588"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_parent_logical_partition</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:abdbe63b242c19bb72ef0fec9e9576588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a54086a6e4fb144bec4a48d414eaffbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a54086a6e4fb144bec4a48d414eaffbb0">get_parent_logical_partition</a> (Context ctx, <a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a54086a6e4fb144bec4a48d414eaffbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1caa2e6462edde9710c91f6dc7771a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1caa2e6462edde9710c91f6dc7771a"></a>
<a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_parent_logical_partition</b> (<a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> handle)</td></tr>
<tr class="separator:a7b1caa2e6462edde9710c91f6dc7771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf995684e43f3c74d1417684ed006379"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf995684e43f3c74d1417684ed006379"></a>
template&lt;int DIM, typename COORD_T &gt; </td></tr>
<tr class="memitem:abf995684e43f3c74d1417684ed006379"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_logical_partition_t.html">LogicalPartitionT</a>&lt; DIM, COORD_T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_parent_logical_partition</b> (<a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt; handle)</td></tr>
<tr class="separator:abf995684e43f3c74d1417684ed006379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2d11b01690d3c3859b75d92094ddd720"><td class="memItemLeft" align="right" valign="top">static TraceID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2d11b01690d3c3859b75d92094ddd720">generate_static_trace_id</a> (void)</td></tr>
<tr class="separator:a2d11b01690d3c3859b75d92094ddd720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6291e578160b1d11704361cc2fe5953"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae6291e578160b1d11704361cc2fe5953">get_zero_time</a> (void)</td></tr>
<tr class="separator:ae6291e578160b1d11704361cc2fe5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bdb63597d855c08e6bc37ffeaec90d"><td class="memItemLeft" align="right" valign="top">static MapperID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae9bdb63597d855c08e6bc37ffeaec90d">generate_static_mapper_id</a> (void)</td></tr>
<tr class="separator:ae9bdb63597d855c08e6bc37ffeaec90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9313599c62c1c03089d4b4fea19463"><td class="memItemLeft" align="right" valign="top">static ProjectionID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#afa9313599c62c1c03089d4b4fea19463">generate_static_projection_id</a> (void)</td></tr>
<tr class="separator:afa9313599c62c1c03089d4b4fea19463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7deb7e4e59ec0254a042e485370ab32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa7deb7e4e59ec0254a042e485370ab32">preregister_projection_functor</a> (ProjectionID pid, <a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a> *functor)</td></tr>
<tr class="separator:aa7deb7e4e59ec0254a042e485370ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97afe9ec2226b0cd545b291c407296c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a97afe9ec2226b0cd545b291c407296c1">get_projection_functor</a> (ProjectionID pid)</td></tr>
<tr class="separator:a97afe9ec2226b0cd545b291c407296c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0909cfe0ea7e5636968cc61eaada18"><td class="memItemLeft" align="right" valign="top">static ShardingID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#acf0909cfe0ea7e5636968cc61eaada18">generate_static_sharding_id</a> (void)</td></tr>
<tr class="separator:acf0909cfe0ea7e5636968cc61eaada18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af960d0cdd23cb7dd8e535920f5073095"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af960d0cdd23cb7dd8e535920f5073095">preregister_sharding_functor</a> (ShardingID sid, <a class="el" href="class_legion_1_1_sharding_functor.html">ShardingFunctor</a> *functor)</td></tr>
<tr class="separator:af960d0cdd23cb7dd8e535920f5073095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cd6d9bff2aefe7087b35844ab9217a"><td class="memItemLeft" align="right" valign="top">static ReductionOpID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae1cd6d9bff2aefe7087b35844ab9217a">generate_static_reduction_id</a> (void)</td></tr>
<tr class="separator:ae1cd6d9bff2aefe7087b35844ab9217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8b66a348ea56e232301cfcfb20338e"><td class="memTemplParams" colspan="2">template&lt;typename REDOP &gt; </td></tr>
<tr class="memitem:a7e8b66a348ea56e232301cfcfb20338e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7e8b66a348ea56e232301cfcfb20338e">register_reduction_op</a> (ReductionOpID redop_id, bool permit_duplicates=false)</td></tr>
<tr class="separator:a7e8b66a348ea56e232301cfcfb20338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac29dc50bf483aeca0b4bae5fc45e28f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aac29dc50bf483aeca0b4bae5fc45e28f">register_reduction_op</a> (ReductionOpID redop_id, ReductionOp *op, SerdezInitFnptr init_fnptr=NULL, SerdezFoldFnptr fold_fnptr=NULL, bool permit_duplicates=false)</td></tr>
<tr class="separator:aac29dc50bf483aeca0b4bae5fc45e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3562ae6bc99740fdf7dead6ea6e6fb1"><td class="memItemLeft" align="right" valign="top">static const ReductionOp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af3562ae6bc99740fdf7dead6ea6e6fb1">get_reduction_op</a> (ReductionOpID redop_id)</td></tr>
<tr class="separator:af3562ae6bc99740fdf7dead6ea6e6fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e64df524c296e54dc6068dc0798358"><td class="memItemLeft" align="right" valign="top">static CustomSerdezID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a92e64df524c296e54dc6068dc0798358">generate_static_serdez_id</a> (void)</td></tr>
<tr class="separator:a92e64df524c296e54dc6068dc0798358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd6b9cee8ae1eb9f8ed7a96dede81d1"><td class="memTemplParams" colspan="2">template&lt;typename SERDEZ &gt; </td></tr>
<tr class="memitem:a2dd6b9cee8ae1eb9f8ed7a96dede81d1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a2dd6b9cee8ae1eb9f8ed7a96dede81d1">register_custom_serdez_op</a> (CustomSerdezID serdez_id, bool permit_duplicates=false)</td></tr>
<tr class="separator:a2dd6b9cee8ae1eb9f8ed7a96dede81d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50d6273d77001d62c47a32eaaac3819"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa50d6273d77001d62c47a32eaaac3819">register_custom_serdez_op</a> (CustomSerdezID serdez_id, SerdezOp *serdez_op, bool permit_duplicates=false)</td></tr>
<tr class="separator:aa50d6273d77001d62c47a32eaaac3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5c849820b8b363331fea7345707aaa"><td class="memItemLeft" align="right" valign="top">static const SerdezOp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5e5c849820b8b363331fea7345707aaa">get_serdez_op</a> (CustomSerdezID serdez_id)</td></tr>
<tr class="separator:a5e5c849820b8b363331fea7345707aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad454cb6f6219e29c1278480a3dd4d09a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ad454cb6f6219e29c1278480a3dd4d09a">get_legion_version</a> (void)</td></tr>
<tr class="separator:ad454cb6f6219e29c1278480a3dd4d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef2a69a34d383ea70f8630023c29015"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">start</a> (int argc, char **argv, bool background=false, bool supply_default_mapper=true)</td></tr>
<tr class="separator:a7ef2a69a34d383ea70f8630023c29015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7604218afb83fecd6d9e47a1852b6219"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7604218afb83fecd6d9e47a1852b6219">initialize</a> (int *argc, char ***argv, bool filter=false)</td></tr>
<tr class="separator:a7604218afb83fecd6d9e47a1852b6219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6d29724fa7b7e3679b94b19a20c37c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3c6d29724fa7b7e3679b94b19a20c37c">wait_for_shutdown</a> (void)</td></tr>
<tr class="separator:a3c6d29724fa7b7e3679b94b19a20c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e0c687da51d111c209e98e4aeb97c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a524e0c687da51d111c209e98e4aeb97c">set_return_code</a> (int return_code)</td></tr>
<tr class="separator:a524e0c687da51d111c209e98e4aeb97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bc41e96b5b10f3435b15ef6d5f090b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a63bc41e96b5b10f3435b15ef6d5f090b">set_top_level_task_id</a> (TaskID top_id)</td></tr>
<tr class="separator:a63bc41e96b5b10f3435b15ef6d5f090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64b2a328c162ba26386019fffc5dc21"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa64b2a328c162ba26386019fffc5dc21">set_top_level_task_mapper_id</a> (MapperID mapper_id)</td></tr>
<tr class="separator:aa64b2a328c162ba26386019fffc5dc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5f4c6e37c8bc225de4b1851d87a2a"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae0f5f4c6e37c8bc225de4b1851d87a2a">get_maximum_dimension</a> (void)</td></tr>
<tr class="separator:ae0f5f4c6e37c8bc225de4b1851d87a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd293aa87d221487f044562a81bddb4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5fd293aa87d221487f044562a81bddb4">configure_MPI_interoperability</a> (int rank)</td></tr>
<tr class="separator:a5fd293aa87d221487f044562a81bddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5347e1e4e56e5b687f63c65179aeaed9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_legion_handshake.html">LegionHandshake</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5347e1e4e56e5b687f63c65179aeaed9">create_external_handshake</a> (bool init_in_ext=true, int ext_participants=1, int legion_participants=1)</td></tr>
<tr class="separator:a5347e1e4e56e5b687f63c65179aeaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d61b0337c401f877ec94bc55d87bf0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_m_p_i_legion_handshake.html">MPILegionHandshake</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac3d61b0337c401f877ec94bc55d87bf0">create_handshake</a> (bool init_in_MPI=true, int mpi_participants=1, int legion_participants=1)</td></tr>
<tr class="separator:ac3d61b0337c401f877ec94bc55d87bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a152e69794766a5565eec12eefca80c"><td class="memTemplParams" colspan="2">template&lt;LogicalRegion(*)(LogicalRegion, const DomainPoint &amp;, Runtime *) PROJ_PTR&gt; </td></tr>
<tr class="memitem:a9a152e69794766a5565eec12eefca80c"><td class="memTemplItemLeft" align="right" valign="top">static ProjectionID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a9a152e69794766a5565eec12eefca80c">register_region_function</a> (ProjectionID handle)</td></tr>
<tr class="separator:a9a152e69794766a5565eec12eefca80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01797f8368215038e3ace3a5e84a277"><td class="memTemplParams" colspan="2">template&lt;LogicalRegion(*)(LogicalPartition, const DomainPoint &amp;, Runtime *) PROJ_PTR&gt; </td></tr>
<tr class="memitem:aa01797f8368215038e3ace3a5e84a277"><td class="memTemplItemLeft" align="right" valign="top">static ProjectionID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#aa01797f8368215038e3ace3a5e84a277">register_partition_function</a> (ProjectionID handle)</td></tr>
<tr class="separator:aa01797f8368215038e3ace3a5e84a277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e904984b8b7efb43c2f790f7a012d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af90e904984b8b7efb43c2f790f7a012d">add_registration_callback</a> (RegistrationCallbackFnptr callback, bool dedup=true, size_t dedup_tag=0)</td></tr>
<tr class="separator:af90e904984b8b7efb43c2f790f7a012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9cd898938622d9551c58a13d3847a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c9cd898938622d9551c58a13d3847a3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_registration_callback</b> (RegistrationWithArgsCallbackFnptr callback, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;buffer, bool dedup=true, size_t dedup_tag=0)</td></tr>
<tr class="separator:a0c9cd898938622d9551c58a13d3847a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b2f41e39bff2e64956d40ab1732477"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac9b2f41e39bff2e64956d40ab1732477">perform_registration_callback</a> (RegistrationCallbackFnptr callback, bool global, bool deduplicate=true, size_t dedup_tag=0)</td></tr>
<tr class="separator:ac9b2f41e39bff2e64956d40ab1732477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0572f6108f11ae649a60f88b9280cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f0572f6108f11ae649a60f88b9280cc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>perform_registration_callback</b> (RegistrationWithArgsCallbackFnptr callback, const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;buffer, bool global, bool deduplicate=true, size_t dedup_tag=0)</td></tr>
<tr class="separator:a6f0572f6108f11ae649a60f88b9280cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae93947622a78e885a5a8b36811bb79"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7ae93947622a78e885a5a8b36811bb79">set_registration_callback</a> (RegistrationCallbackFnptr callback)</td></tr>
<tr class="separator:a7ae93947622a78e885a5a8b36811bb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86706aed4463173286cfdacd8a5c9c23"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_legion_1_1_input_args.html">InputArgs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a86706aed4463173286cfdacd8a5c9c23">get_input_args</a> (void)</td></tr>
<tr class="separator:a86706aed4463173286cfdacd8a5c9c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357602aa4f54f88fe361861fa50e20a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a357602aa4f54f88fe361861fa50e20a9">enable_profiling</a> (void)</td></tr>
<tr class="separator:a357602aa4f54f88fe361861fa50e20a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1338247926eef76421390573c82cc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a3b1338247926eef76421390573c82cc3">disable_profiling</a> (void)</td></tr>
<tr class="separator:a3b1338247926eef76421390573c82cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3959f5e3dcedc969475d839dfb3a573"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ae3959f5e3dcedc969475d839dfb3a573">dump_profiling</a> (void)</td></tr>
<tr class="separator:ae3959f5e3dcedc969475d839dfb3a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a125ab374f0985728589368ee8faf2"><td class="memItemLeft" align="right" valign="top">static LayoutConstraintID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a83a125ab374f0985728589368ee8faf2">preregister_layout</a> (const <a class="el" href="struct_legion_1_1_layout_constraint_registrar.html">LayoutConstraintRegistrar</a> &amp;registrar, LayoutConstraintID layout_id=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a83a125ab374f0985728589368ee8faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0807fe3cf812682fcbdb29e1ebaa0918"><td class="memItemLeft" align="right" valign="top">static TaskID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0807fe3cf812682fcbdb29e1ebaa0918">generate_static_task_id</a> (void)</td></tr>
<tr class="separator:a0807fe3cf812682fcbdb29e1ebaa0918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1742215df90e10e12bfe71d76a5171"><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a8d1742215df90e10e12bfe71d76a5171"><td class="memTemplItemLeft" align="right" valign="top">static VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8d1742215df90e10e12bfe71d76a5171">preregister_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const char *task_name=NULL, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a8d1742215df90e10e12bfe71d76a5171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0912d5b41b1060fdb2fa0b17fffbcafd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:a0912d5b41b1060fdb2fa0b17fffbcafd"><td class="memTemplItemLeft" align="right" valign="top">static VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0912d5b41b1060fdb2fa0b17fffbcafd">preregister_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const UDT &amp;user_data, const char *task_name=NULL, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a0912d5b41b1060fdb2fa0b17fffbcafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e85dd4405daabc5eb4ebf3621763eb7"><td class="memTemplParams" colspan="2">template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a5e85dd4405daabc5eb4ebf3621763eb7"><td class="memTemplItemLeft" align="right" valign="top">static VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a5e85dd4405daabc5eb4ebf3621763eb7">preregister_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const char *task_name=NULL, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:a5e85dd4405daabc5eb4ebf3621763eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a3743c8dc7d4e777d44c964c35344"><td class="memTemplParams" colspan="2">template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:abf7a3743c8dc7d4e777d44c964c35344"><td class="memTemplItemLeft" align="right" valign="top">static VariantID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abf7a3743c8dc7d4e777d44c964c35344">preregister_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const UDT &amp;user_data, const char *task_name=NULL, VariantID vid=LEGION_AUTO_GENERATE_ID)</td></tr>
<tr class="separator:abf7a3743c8dc7d4e777d44c964c35344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ffe9b3f048f6606a0435271a134e29"><td class="memItemLeft" align="right" valign="top">static VariantID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a41ffe9b3f048f6606a0435271a134e29">preregister_task_variant</a> (const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;registrar, const CodeDescriptor &amp;codedesc, const void *user_data=NULL, size_t user_len=0, const char *task_name=NULL, VariantID vid=LEGION_AUTO_GENERATE_ID, size_t return_type_size=LEGION_MAX_RETURN_SIZE, bool check_task_id=true)</td></tr>
<tr class="separator:a41ffe9b3f048f6606a0435271a134e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cae296df9a998053907a268f907c9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a75cae296df9a998053907a268f907c9e">legion_task_preamble</a> (const void *data, size_t datalen, Processor p, const <a class="el" href="class_legion_1_1_task.html">Task</a> *&amp;task, const std::vector&lt; <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> &gt; *&amp;reg, Context &amp;ctx, <a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&amp;runtime)</td></tr>
<tr class="separator:a75cae296df9a998053907a268f907c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89f0d1e1c5051981e85dda090ee3141"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ab89f0d1e1c5051981e85dda090ee3141">legion_task_postamble</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *runtime, Context ctx, const void *retvalptr=NULL, size_t retvalsize=0, bool owned=false, Realm::RegionInstance inst=Realm::RegionInstance::NO_INST)</td></tr>
<tr class="separator:ab89f0d1e1c5051981e85dda090ee3141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475a28e7ac108578586f5038eb4e8b09"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a475a28e7ac108578586f5038eb4e8b09">legion_task_postamble</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *runtime, Context ctx, <a class="el" href="class_legion_1_1_future_functor.html">FutureFunctor</a> *callback_functor, bool owned=false)</td></tr>
<tr class="separator:a475a28e7ac108578586f5038eb4e8b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d51b64f40ce794ff98b1403994c11f3"><td class="memTemplParams" colspan="2">template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a6d51b64f40ce794ff98b1403994c11f3"><td class="memTemplItemLeft" align="right" valign="top">static TaskID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a6d51b64f40ce794ff98b1403994c11f3">register_legion_task</a> (TaskID id, Processor::Kind proc_kind, bool single, bool index, VariantID vid=LEGION_AUTO_GENERATE_ID, <a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a> options=<a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>(), const char *task_name=NULL)</td></tr>
<tr class="separator:a6d51b64f40ce794ff98b1403994c11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed2e245248488919540ac601250098e"><td class="memTemplParams" colspan="2">template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </td></tr>
<tr class="memitem:a7ed2e245248488919540ac601250098e"><td class="memTemplItemLeft" align="right" valign="top">static TaskID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a7ed2e245248488919540ac601250098e">register_legion_task</a> (TaskID id, Processor::Kind proc_kind, bool single, bool index, VariantID vid=LEGION_AUTO_GENERATE_ID, <a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a> options=<a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>(), const char *task_name=NULL)</td></tr>
<tr class="separator:a7ed2e245248488919540ac601250098e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc41657d63ef3c5587288a5fdba376e5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:abc41657d63ef3c5587288a5fdba376e5"><td class="memTemplItemLeft" align="right" valign="top">static TaskID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#abc41657d63ef3c5587288a5fdba376e5">register_legion_task</a> (TaskID id, Processor::Kind proc_kind, bool single, bool index, const UDT &amp;user_data, VariantID vid=LEGION_AUTO_GENERATE_ID, <a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a> options=<a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>(), const char *task_name=NULL)</td></tr>
<tr class="separator:abc41657d63ef3c5587288a5fdba376e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ccafce990902cc501cd4ca2f160914"><td class="memTemplParams" colspan="2">template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </td></tr>
<tr class="memitem:a48ccafce990902cc501cd4ca2f160914"><td class="memTemplItemLeft" align="right" valign="top">static TaskID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a48ccafce990902cc501cd4ca2f160914">register_legion_task</a> (TaskID id, Processor::Kind proc_kind, bool single, bool index, const UDT &amp;user_data, VariantID vid=LEGION_AUTO_GENERATE_ID, <a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a> options=<a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>(), const char *task_name=NULL)</td></tr>
<tr class="separator:a48ccafce990902cc501cd4ca2f160914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b93b22fb8f780717fa6310e289dad3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#af0b93b22fb8f780717fa6310e289dad3">has_runtime</a> (void)</td></tr>
<tr class="separator:af0b93b22fb8f780717fa6310e289dad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ae746205378b10cd898824b719ee8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a61ae746205378b10cd898824b719ee8a">get_runtime</a> (Processor p=Processor::NO_PROC)</td></tr>
<tr class="separator:a61ae746205378b10cd898824b719ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bae127d301ae23323b0341b01ab94e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#ac2bae127d301ae23323b0341b01ab94e">has_context</a> (void)</td></tr>
<tr class="separator:ac2bae127d301ae23323b0341b01ab94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae1696024e39fb7afc5ed87797ad8ff"><td class="memItemLeft" align="right" valign="top">static Context&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a0ae1696024e39fb7afc5ed87797ad8ff">get_context</a> (void)</td></tr>
<tr class="separator:a0ae1696024e39fb7afc5ed87797ad8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb3136f2a6068ad51307831ee645c4a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_legion_1_1_task.html">Task</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_runtime.html#a8fb3136f2a6068ad51307831ee645c4a">get_context_task</a> (Context ctx)</td></tr>
<tr class="separator:a8fb3136f2a6068ad51307831ee645c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab0c485bb658d7ac21ce5a24a10159b87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0c485bb658d7ac21ce5a24a10159b87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Runtime</b> (Internal::Runtime *rt)</td></tr>
<tr class="separator:ab0c485bb658d7ac21ce5a24a10159b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_legion_1_1_runtime.html">Runtime</a> class is the primary interface for <a class="el" href="namespace_legion.html">Legion</a>. Every task is given a reference to the runtime as part of its arguments. All <a class="el" href="namespace_legion.html">Legion</a> operations are then performed by directing the runtime to perform them through the methods of this class. The methods in <a class="el" href="class_legion_1_1_runtime.html">Runtime</a> are broken into three categories. The first group of calls are the methods that can be used by application tasks during runtime. The second group contains calls for initializing the runtime during start-up callback. The final section of calls are static methods that are used to configure the runtime prior to starting it up.</p>
<p>A note on context free functions: context free functions have equivalent functionality to their non-context-free couterparts. However, context free functions can be safely used in a leaf task while any runtime function that requires a context cannot be used in a leaf task. If your task variant only uses context free functions as part of its implementation then it is safe for you to annotate it as a leaf task variant. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae96cf3328e9b69c7df53c25982286b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_grant.html">Grant</a> Legion::Runtime::acquire_grant </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_lock_request.html">LockRequest</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_acquire.html">Acquire</a> one or more locks in the given mode. Returns a grant object which can be passed to many kinds of launchers for indicating that the operations must be performed while the grant his held. Note that the locks will be acquired in the order specified by the in the vector which may be necessary for applications to avoid deadlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">requests</td><td>vector of locks to acquire </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a grant object </dd></dl>

</div>
</div>
<a class="anchor" id="a099c2cb81609323acebc086f0da983ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::add_mapper </td>
          <td>(</td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>map_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mapping::Mapper *&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>proc</em> = <code>Processor::NO_PROC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a mapper at the given mapper ID for the runtime to use when mapping tasks. If a specific processor is passed to the call then the mapper instance will only be registered on that processor. Alternatively, if no processor is passed, then the mapper will be registered with all processors on the local node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map_id</td><td>the mapper ID to associate with the mapper </td></tr>
    <tr><td class="paramname">mapper</td><td>pointer to the mapper object </td></tr>
    <tr><td class="paramname">proc</td><td>the processor to associate the mapper with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af90e904984b8b7efb43c2f790f7a012d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::add_registration_callback </td>
          <td>(</td>
          <td class="paramtype">RegistrationCallbackFnptr&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dedup</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dedup_tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call allows the application to add a callback function that will be run prior to beginning any task execution on every runtime in the system. It can be used to register or update the mapping between mapper IDs and mappers, register reductions, register projection function, register coloring functions, or configure any other static runtime variables prior to beginning the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>function pointer to the callback function to be run </td></tr>
    <tr><td class="paramname">buffer</td><td>optional argument buffer to pass to the callback </td></tr>
    <tr><td class="paramname">dedup</td><td>whether to deduplicate this with other registration callbacks for the same function </td></tr>
    <tr><td class="paramname">dedup_tag</td><td>a tag to use for deduplication in the case where applications may want to deduplicate across multiple callbacks with the same function pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d742dec7f16386ecaa85a451766eadf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> Legion::Runtime::advance_dynamic_collective </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td>
          <td class="paramname"><em>dc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance an existing dynamic collective to the next phase. It has the same semantics as the equivalent call for phase barriers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">dc</td><td>the dynamic collective to be advanced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an updated dynamic collective used for the next phase </dd></dl>

</div>
</div>
<a class="anchor" id="a92381209ec4d73bae91236cf77da5fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a> Legion::Runtime::advance_phase_barrier </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a>&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance an existing phase barrier to the next phase. Note this is NOT arrive which indicates an actual arrival at the next phase. Instead this allows tasks launched with the returned phase barrier to indicate that they should be executed in the next phase of the computation. Note that once a phase barrier exhausts its total number of generations then it will fail the 'exists' method test. It is the responsibility of the application to detect this case and handle it correctly by making a new <a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">pb</td><td>the phase barrier to be advanced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an updated phase barrier used for the next phase </dd></dl>

</div>
</div>
<a class="anchor" id="a125adaa5cd839477ccd82a3e29ed5512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::arrive_dynamic_collective </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Arrive on a dynamic collective immediately with a value stored in an untyped buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">dc</td><td>dynamic collective on which to arrive </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to an untyped buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer in bytes </td></tr>
    <tr><td class="paramname">count</td><td>arrival count on the barrier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf0b11fbbbd98d975ae1472ea1d25cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::attach_external_resource </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_attach_launcher.html">AttachLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach an external resource to a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the attach launcher that describes the resource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical region for the external resource </dd></dl>

</div>
</div>
<a class="anchor" id="a85f01d9189d26f07ad2e4f8db2dc55bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_external_resources.html">ExternalResources</a> Legion::Runtime::attach_external_resources </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_index_attach_launcher.html">IndexAttachLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach multiple external resources to logical regions using an index space attach operation. In a control replicated context this method is an unusual "collective" method meaning that different shards are allowed to pass in different arguments and the runtime will interpret them as different sub-operations coming from different shards. All the physical regions returned from this method must be detached together as well using the 'detach_external_resources' method and cannot be detached individually using the 'detach_external_resource' method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the index attach launcher describing the external resources to be attached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an external resources objects containing the physical regions for the attached resources with regions in the same order as specified in the launcher </dd></dl>

</div>
</div>
<a class="anchor" id="a80f4f7c08d42f4607e79df8a20a55146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::attach_file </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LegionFileMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Attach an normal file as a physical region. This attach is similar to attach_hdf5 operation, except that the file has exact same data format as in-memory physical region. Data lays out as SOA in file. </dd></dl>

</div>
</div>
<a class="anchor" id="a18a9db6622557604ab9687729cfa89b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::attach_hdf5 </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; FieldID, const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LegionFileMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Attach an HDF5 file as a physical region. The file must already exist. <a class="el" href="namespace_legion.html">Legion</a> will defer the attach operation until all other operations on the logical region are finished. After the attach operation succeeds, then all other physical instances for the logical region will be invalidated, making the physical instance the only valid version of the logical region. The resulting physical instance is attached with restricted coherence (the same as logical regions mapped with simultaneous coherence). All operations using the logical region will be required to use the physical instance until the restricted coherence is removed using an acquire operation. The restricted coherence can be reinstated by performing a release operation. Just like other physical regions, the HDF5 file can be both mapped and unmapped after it is created. The runtime will report an error for an attempt to attach an file to a logical region which is already mapped in the enclosing parent task's context. The runtime will also report an error if the task launching the attach operation does not have the necessary privileges (read-write) on the logical region. The resulting physical region is unmapped, but can be mapped using the standard inline mapping calls. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">file_name</td><td>the path to an existing HDF5 file </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region with which to associate the file </td></tr>
    <tr><td class="paramname">parent</td><td>the parent logical region containing privileges </td></tr>
    <tr><td class="paramname">field_map</td><td>mapping for field IDs to HDF5 dataset names </td></tr>
    <tr><td class="paramname">mode</td><td>the access mode for attaching the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new physical instance corresponding to the HDF5 file </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9033b3a82953c9991b14a2a3002a47e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to a task </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_id</td><td>the ID of the task </td></tr>
    <tr><td class="paramname">name</td><td>pointer to the name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
    <tr><td class="paramname">local_only</td><td>attach the name only on the local node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a422e9329647f5477dc54a2ae5af0c0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to an index space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75e857566eaffcdca175b3a23175c217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to an index partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f1ccdd03cbc18919f081b96761bfb3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to a field space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5165fcf2d6b6d5bc60026155fa15ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to a specific field </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">fid</td><td>field ID </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae01312959577f6d3598b7a7c60aede3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical region handle </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62ed85fcc8151cbf16e20d56de5cc604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a name to a logical partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical partition handle </td></tr>
    <tr><td class="paramname">name</td><td>pointer to a name </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the name be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02665b2e9420a73f96b5b2ca0bedcbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to a logical task </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>task_id the ID of the task </td></tr>
    <tr><td class="paramname">tag</td><td>the semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
    <tr><td class="paramname">local_only</td><td>attach the name only on this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3650321803a3a960e89ef809f346e64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to an index space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecd048a1345ec6c5e877f1eb95d45959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to an index partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae44ffbd80bf5a589d96896c4ea680836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to a field space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a781ed5acedef1c738c9975fcde1f4242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to a specific field </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">fid</td><td>field ID </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1c172c1fe694d1b814363c09c3a9fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical region handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34dce427fc17f11ac738faf86b18e348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::attach_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_mutable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach semantic information to a logical partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical partition handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer to a buffer </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer to save </td></tr>
    <tr><td class="paramname">is_mutable</td><td>can the tag value be changed later </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fd4333221923bb6e88d8ab6da24cea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Context Legion::Runtime::begin_implicit_task </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>top_task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>mapper_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor::Kind&#160;</td>
          <td class="paramname"><em>proc_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>control_replicable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shard_per_address_space</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shard_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition to launching top-level tasks from outside the runtime, applications can bind external threads as new implicit top-level tasks to the runtime. This will tell the runtime that this external thread should now function as new top-level task that is executing. After this call the trhead will be treated as through it is a top-level task running on a specific kind of processor. Users can also mark that this implicit top-level task is control replicable for supporting implicit top-level tasks for multi-node runs. For the control replicable case we expect to see the same number of calls from every address space. This number is controlled by shard_per_address_space and defaults to one. The application can also optionally specify the shard ID for every implicit top level task for control replication settings. If it is specified, then the application must specify it for all shards. Otherwise the runtime will allocate shard IDs contiguously on each node before proceeding to the next node. </p>

</div>
</div>
<a class="anchor" id="affcf2b0d9fb51e2a25b1b2f3bed2e9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::MapperContext Legion::Runtime::begin_mapper_call </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>target</em> = <code>Processor::NO_PROC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a mapper call from the application side. This will create a mapper context to use during the mapper call. The creation of this mapper context will ensure appropriate synchronization with other mapper calls consistent with the mapper synchronization model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">id</td><td>the mapper ID for which mapper to locate </td></tr>
    <tr><td class="paramname">target</td><td>processor if any, if none specified then the executing processor for the current context is used, if specified processor must be local to the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fresh mapper context to use for the mapper call </dd></dl>

</div>
</div>
<a class="anchor" id="ad41876356255505a4600a987fd3e2730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::begin_static_trace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; RegionTreeID &gt; *&#160;</td>
          <td class="paramname"><em>managed</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a new static trace of operations. Inside of this trace it is the application's responsibility to specify any dependences that would normally have existed between each operation being launched and any prior operations in the trace (there is no need to specify dependences on anything outside of the trace). The application can optionally specify a set of region trees for which it will be supplying dependences, with all other region trees being left to the runtime to handle. If no such set is specified then the runtime will operate under the assumption that the application is specifying dependences for all region trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">managed</td><td>optional list of region trees managed by the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac742f795af88189854aa921f247bdc76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::begin_trace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TraceID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logical_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_trace</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; RegionTreeID &gt; *&#160;</td>
          <td class="paramname"><em>managed</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a new trace of legion operations. Tracing enables the runtime to memoize the dynamic logical dependence analysis for these operations. <a class="el" href="class_legion_1_1_future.html">Future</a> executions of the trace will no longer need to perform the dynamic dependence analysis, reducing overheads and improving the parallelism available in the physical analysis. The trace ID need only be local to the enclosing context. Traces are currently not permitted to be nested. In general, the runtime will capture all dependence information for the trace. However, in some cases, compilers may want to pass information along for the logical dependence analysis as a static trace. Inside of a static trace it is the application's responsibility to specify any dependences that would normally have existed between each operation being launched and any prior operations in the trace (there is no need to specify dependences on anything outside of the trace). The application can optionally specify a set of region trees for which it will be supplying dependences, with all other region trees being left to the runtime to handle. If no such set is specified then the runtime will operate under the assumption that the application is specifying dependences for all region trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">tid</td><td>the trace ID of the trace to be captured </td></tr>
    <tr><td class="paramname">logical_only</td><td>whether physical tracing is permitted </td></tr>
    <tr><td class="paramname">static_trace</td><td>whether this is a static trace </td></tr>
    <tr><td class="paramname">managed</td><td>specific region trees the application will handle in the case of a static trace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacba31e40f227459297e0d98901582af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::bind_implicit_task_to_external_thread </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind an implicit context to an external thread. It is the user's responsibility to make sure that no more than one external thread is bound to an implicit task's context at a time or undefined behavior will occur. </p>

</div>
</div>
<a class="anchor" id="a80ac9a3b4f949dff7aed8def14a2d113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::complete_frame </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frames are a very simple way to control the number of outstanding operations in a task context. By default, mappers have control over this by saying how many outstanding operations each task context can have using the 'configure_context' mapper call. However, in many cases, it is easier for custom mappers to reason about how many iterations or some other application-specific set of operations are in flight. To facilitate this, applications can create 'frames' of tasks. Using the 'configure_context' mapper call, custom mappers can specify the maximum number of outstanding frames that make up the operation window. It is best to place these calls at the end of a frame of tasks. </p>

</div>
</div>
<a class="anchor" id="a5fd293aa87d221487f044562a81bddb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::configure_MPI_interoperability </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configre the runtime for interoperability with MPI. This call should be made once in each MPI process before invoking the 'start' function when running <a class="el" href="namespace_legion.html">Legion</a> within the same process as MPI. As a result of this call the 'find_forward_MPI_mapping' and 'find_reverse_MPI_mapping' methods on a runtime instance will return a map which associates an AddressSpace with each MPI rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the integer naming this MPI rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04ef382f66b480e80d87607641912573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> Legion::Runtime::construct_future_map </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collective</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShardingID&#160;</td>
          <td class="paramname"><em>sid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicit_sharding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a future map from a collection of buffers. The user must also specify the domain of the future map and there must be one buffer for every point in the domain. In the case of 'collective=true' the runtime supports different shards in a control-replicated context to work collectively to construct the future map. The runtime will not detect if points are missing or if points are duplicated and undefined behavior will occur. If 'collective=true', the application must provide a sharding function that describes assignment of points to shards for the runtime to use. The runtime will verify this sharding function accurately describes all the points passed in. If the task is not control-replicated then the 'collective' flag will not have any effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">domain</td><td>the index space that names all points in the future map </td></tr>
    <tr><td class="paramname">data</td><td>the set of futures from which to create the future map </td></tr>
    <tr><td class="paramname">collective</td><td>whether shards from a control replicated context should work collectively to construct the map </td></tr>
    <tr><td class="paramname">sid</td><td>the sharding function ID that describes the sharding pattern if collective=true </td></tr>
    <tr><td class="paramname">implicit_sharding</td><td>if collective=true this says whether the sharding should be implicitly handled by the runtime and the sharding function ID ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new future map containing all the futures </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a26344ad772345a6544dadd5e2df3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> Legion::Runtime::construct_future_map </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_future.html">Future</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>futures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collective</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShardingID&#160;</td>
          <td class="paramname"><em>sid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicit_sharding</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a future map from a collection of futures. The user must also specify the domain of the futures and there must be one future for every point in the domain. In the case of 'collective=true' the runtime supports different shards in a control-replicated context to work collectively to construct the future map. The runtime will not detect if points are missing or if points are duplicated and undefined behavior will occur. If the task is not control-replicated then the 'collective' flag will not have any effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">domain</td><td>the index space that names all points in the future map </td></tr>
    <tr><td class="paramname">futures</td><td>the set of futures from which to create the future map </td></tr>
    <tr><td class="paramname">collective</td><td>whether shards from a control replicated context should work collectively to construct the map </td></tr>
    <tr><td class="paramname">sid</td><td>the sharding function ID that describes the sharding pattern if collective=true </td></tr>
    <tr><td class="paramname">implicit_sharding</td><td>if collective=true this says whether the sharding should be implicitly handled by the runtime and the sharding function ID ignored </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new future map containing all the futures </dd></dl>

</div>
</div>
<a class="anchor" id="a387ad10ef63b243e9edbb1c1622fc4e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a> Legion::Runtime::create_argument_map </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Create an argument map in the given context. This method is deprecated as argument maps can now be created directly by a simple declaration. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new argument map </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="af7ea5dfe590c909afdb1ab534b3fcfe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::create_association </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>domain_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>domain_fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>&#160;</td>
          <td class="paramname"><em>map_arg</em> = <code><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create association will construct an injective mapping between the points of two different index spaces. The mapping will be constructed in a field of the domain logical region so that there is one entry for each point in the index space of the domain logical region. If the cardinality of domain index space is larger than the cardinality of the range index space then some entries in the field may not be written. It is the responsiblity of the user to have initialized the field with a "null" value to detect such cases. Users wishing to create a bi-directional mapping between index spaces can also use the versions of this method that take a logical region on the range as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">domain</td><td>the region for the results and source index space </td></tr>
    <tr><td class="paramname">domain_parent</td><td>the region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field of domain in which to place the results </td></tr>
    <tr><td class="paramname">range</td><td>the index space to serve as the range of the mapping </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the mapper to use for mapping the fields </td></tr>
    <tr><td class="paramname">tag</td><td>the tag to pass to the mapper for context </td></tr>
    <tr><td class="paramname">map_arg</td><td>an untyped buffer for the mapper data of the <a class="el" href="class_legion_1_1_partition.html">Partition</a> </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a930307028502cdb18bcfb56039745d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color Legion::Runtime::create_cross_product_partitions </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>, <a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs a cross product between two different index partitions. For every index subspace in the first index partition the runtime will create a new index partition of that index space by intersecting each of the different index subspaces in the second index partition. As a result, whole set of new index partitions will be created. The user can request which partition names to return by specifying a map of domain points from the color space of the first index partition. If the map is empty, no index partitions will be returned. The user can can say what kind the partitions are using the 'part_kind' argument. The user can also specify a color for the new partitions using the 'color' argument. If a specific color is specified, it must be available for a partition in each of the index subspaces in the first index partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle1</td><td>the first index partition </td></tr>
    <tr><td class="paramname">handle2</td><td>the second index partition </td></tr>
    <tr><td class="paramname">handle</td><td>optional map for new partitions (can be empty) </td></tr>
    <tr><td class="paramname">part_kind</td><td>indicate the kinds for the partitions </td></tr>
    <tr><td class="paramname">color</td><td>optional color for each of the new partitions </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color used for each of the partitions </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c9f25e047233fefbf75ab200e42af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a> Legion::Runtime::create_dynamic_collective </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arrivals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>init_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>init_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A dynamic collective is a special type of phase barrier that is also associated with a reduction operation that allows arrivals to contribute a value to a generation of the barrier. The runtime reduces down all the applied values to a common value for each generation of the phase barrier. The number of arrivals gives a default number of expected arrivals for each generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">arrivals</td><td>default number of expected arrivals </td></tr>
    <tr><td class="paramname">redop</td><td>the associated reduction operation </td></tr>
    <tr><td class="paramname">init_value</td><td>the inital value for each generation </td></tr>
    <tr><td class="paramname">init_size</td><td>the size in bytes of the initial value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new dynamic collective handle </dd></dl>

</div>
</div>
<a class="anchor" id="a67493d677a98031068cec3d81895b0e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_equal_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>granularity</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create 'color_space' index subspaces (one for each point) in a common partition of the 'parent' index space. By definition the resulting partition will be disjoint. Users can also specify a minimum 'granularity' for the size of the index subspaces. Users can specify an optional color for the index partition. Note: for multi-dimensional cases, this implementation will currently only split across the first dimension. This is useful for providing an initial equal partition, but is unlikely to be an ideal partition for long repetitive use. Do NOT rely on this behavior as the runtime reserves the right to change the implementation in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space of the partition to be made </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors to create </td></tr>
    <tr><td class="paramname">granularity</td><td>the minimum size of the index subspaces </td></tr>
    <tr><td class="paramname">color</td><td>optional color paramter for the partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the created index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a5347e1e4e56e5b687f63c65179aeaed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_legion_handshake.html">LegionHandshake</a> Legion::Runtime::create_external_handshake </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_in_ext</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext_participants</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>legion_participants</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a handshake object for exchanging control between an external application and <a class="el" href="namespace_legion.html">Legion</a>. We make this a static method so that it can be created before the <a class="el" href="namespace_legion.html">Legion</a> runtime is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_in_ext</td><td>who owns initial control of the handshake, by default it is the external application </td></tr>
    <tr><td class="paramname">ext_participants</td><td>number of calls that need to be made to the handshake to pass control from the external application to <a class="el" href="namespace_legion.html">Legion</a> </td></tr>
    <tr><td class="paramname">legion_participants</td><td>number of calls that need to be made to the handshake to pass control from <a class="el" href="namespace_legion.html">Legion</a> to the external application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3819fe6203528d2e753f3a09325eec8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_field_allocator.html">FieldAllocator</a> Legion::Runtime::create_field_allocator </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a field space allocator object for the given field space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the field space to create an allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new field space allocator for the given field space </dd></dl>

</div>
</div>
<a class="anchor" id="a4d8b0cee719f8b8bd779b35642affc70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> Legion::Runtime::create_field_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new field space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new field space </dd></dl>

</div>
</div>
<a class="anchor" id="ad78dae9a93c71a1592fe247090366ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> Legion::Runtime::create_field_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>resulting_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CustomSerdezID&#160;</td>
          <td class="paramname"><em>serdez_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new field space with an existing set of fields </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">field_sizes</td><td>initial field sizes for fields </td></tr>
    <tr><td class="paramname">resulting_fields</td><td>optional field snames for fields </td></tr>
    <tr><td class="paramname">serdez_id</td><td>optional parameter for specifying a custom serdez object for serializing and deserializing fields </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new field space </dd></dl>

</div>
</div>
<a class="anchor" id="acd2b45279d8e1d14281182bbfa434f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> Legion::Runtime::create_field_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_future.html">Future</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>resulting_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CustomSerdezID&#160;</td>
          <td class="paramname"><em>serdez_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new field space with an existing set of fields </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">field_sizes</td><td>initial field sizes for fields </td></tr>
    <tr><td class="paramname">resulting_fields</td><td>optional field snames for fields </td></tr>
    <tr><td class="paramname">serdez_id</td><td>optional parameter for specifying a custom serdez object for serializing and deserializing fields </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new field space </dd></dl>

</div>
</div>
<a class="anchor" id="ac3d61b0337c401f877ec94bc55d87bf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_m_p_i_legion_handshake.html">MPILegionHandshake</a> Legion::Runtime::create_handshake </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_in_MPI</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mpi_participants</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>legion_participants</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a handshake object for exchanging control between MPI and <a class="el" href="namespace_legion.html">Legion</a>. We make this a static method so that it can be created before the <a class="el" href="namespace_legion.html">Legion</a> runtime is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_in_MPI</td><td>who owns initial control of the handshake, by default it is MPI </td></tr>
    <tr><td class="paramname">mpi_participants</td><td>number of calls that need to be made to the handshake to pass control from MPI to <a class="el" href="namespace_legion.html">Legion</a> </td></tr>
    <tr><td class="paramname">legion_participants</td><td>number of calls that need to be made to the handshake to pass control from <a class="el" href="namespace_legion.html">Legion</a> to MPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1550f7305763dadb37ce5a42572425b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_allocator.html">IndexAllocator</a> Legion::Runtime::create_index_allocator </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Create an index allocator object for a given index space This method is deprecated becasue index spaces no longer support dynamic allocation. This will still work only if there is exactly one allocator made for the index space throughout the duration of its lifetime. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the index space to create an allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index space allocator for the given index space </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a51cb6acd03b57e45fd3857704ffcb0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointColoring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Create an index partition from a point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
    <tr><td class="paramname">allocable</td><td>whether the child index spaces are allocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a70dc84f7aae18e1c437e01d6498a433e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coloring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>See the previous create_index_partition call Create an index partition. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae76572904db634ccda408fd3e85bc555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainPointColoring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Create an index partition from a domain point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1089cb44f5721ddfa8539107ef96983b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainColoring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>See the previous create index partition call Create an index partition from a domain color space and coloring. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>the domain of colors </td></tr>
    <tr><td class="paramname">coloring</td><td>the domain coloring of the parent index space </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a11784fd73bdd77db112bcf8e14d73d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiDomainPointColoring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Create an index partition from a multi-domain point coloring <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">coloring</td><td>the coloring of the parent index space </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of partition or whether to compute it </td></tr>
    <tr><td class="paramname">color</td><td>optional color for the new partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the new index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a702eb790c35bcbd2a8c8497226c6f8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiDomainColoring &amp;&#160;</td>
          <td class="paramname"><em>coloring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>See the previous create index partition call Create an index partitiong from a domain color space and a multi-domain coloring which allows multiple domains to be associated with each color. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>the domain of colors </td></tr>
    <tr><td class="paramname">coloring</td><td>the multi-domain coloring </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5a673027fda1ad8b8749cb37a6aa8c49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Create an index partitioning from a typed mapping. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space being partitioned </td></tr>
    <tr><td class="paramname">mapping</td><td>the mapping of points to colors </td></tr>
    <tr><td class="paramname">color</td><td>optional color name for the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4e44777b685baa2b21f0bf04ed516c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LegionRuntime::Accessor::RegionAccessor&lt; LegionRuntime::Accessor::AccessorType::Generic &gt;&#160;</td>
          <td class="paramname"><em>field_accessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_legion_1_1_runtime.html#ac3eff619ee6af41d64afc6dcfab212f1">create_partition_by_field</a> instead Create an index partitioning from an existing field in a physical instance. This requires that the field accessor be valid for the entire parent index space. By definition colors are always non-negative. The runtime will iterate over the field accessor and interpret values as signed integers. Any locations less than zero will be ignored. Values greater than or equal to zero will be colored and placed in the appropriate subregion. By definition this partitioning mechanism has to disjoint since each pointer value has at most one color. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">field_accessor</td><td>field accessor for the coloring field </td></tr>
    <tr><td class="paramname">disjoint</td><td>whether the partitioning is disjoint or not </td></tr>
    <tr><td class="paramname">complete</td><td>whether the partitioning is complete or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the next index partition </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac0b3d4e90852fe581ec4cbcab476baa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeTag&#160;</td>
          <td class="paramname"><em>type_tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space based on the given domain bounds If the bounds contains a Realm index space then <a class="el" href="namespace_legion.html">Legion</a> will take ownership of any sparsity maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">bounds</td><td>the bounds for the new index space </td></tr>
    <tr><td class="paramname">type_tag</td><td>optional type tag to use for the index space </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a588d11c58c54b46aec62bd0e3edb1fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeTag&#160;</td>
          <td class="paramname"><em>type_tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space from a future which contains a <a class="el" href="class_legion_1_1_domain.html">Domain</a> object. If the <a class="el" href="class_legion_1_1_domain.html">Domain</a> conaints a Realm index space then <a class="el" href="namespace_legion.html">Legion</a> will take ownership of any sparsity maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">dimensions</td><td>number of dimensions for the created space </td></tr>
    <tr><td class="paramname">future</td><td>the future value containing the bounds </td></tr>
    <tr><td class="paramname">type_tag</td><td>optional type tag to use for the index space defaults to 'coord_t' </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebd8334917853b4abdf391ffeaa31aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space from a vector of points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">points</td><td>a vector of points to have in the index space </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="aa3c91c5dd72c1beae812fcf9887aa307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space from a vector of rectangles </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">rects</td><td>a vector of rectangles to have in the index space </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a4bfb413efd2de89152ad9e930769e46f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_num_elmts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Create a new top-level index space with the maximum number of elements <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">max_num_elmts</td><td>maximum number of elements in the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0ccb642113a2bad26c3b4ec900633d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Create a new top-level index space based on a set of domains <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">domains</td><td>the set of domains </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e29f710aa1a3b4a68f2fdaf47fbc57e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space_difference </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenancne</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new index space by taking the set difference of an existing index space with a set of other index spaces. The resulting index space is assigned to be the index space corresponding to 'color' of the 'parent' index partition. It is illegal to invoke this method with a 'parent' index partition that was not created by a call to 'create_pending_partition'. The 'initial' index space is the index space from which differences will be performed, and each of the index spaces in 'handles' will be subsequently subtracted from the 'initial' index space. All of the index spaces in 'handles' as well as 'initial' must come from the same index space tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index partition </td></tr>
    <tr><td class="paramname">color</td><td>the color to assign the index space to in the parent </td></tr>
    <tr><td class="paramname">initial</td><td>the starting index space </td></tr>
    <tr><td class="paramname">handles</td><td>a vector index space handles to subtract </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a7e49eee0e9cac0f4cd363b30bf5b68ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space_intersection </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new index space by intersecting together a bunch of index spaces from a common index space tree. The resulting index space is assigned to be the index space corresponding to 'color' of the 'parent' index partition. It is illegal to invoke this method with a 'parent' index partition that was not created by a call to 'create_pending_partition'. All of the index spaces being intersected together must come from the same index space tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index partition </td></tr>
    <tr><td class="paramname">color</td><td>the color to assign the index space to in the parent </td></tr>
    <tr><td class="paramname">handles</td><td>a vector index space handles to intersect </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a703ed6a38c874e44d1d2cde2c7d2d9de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space_intersection </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenannce</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as the one above, except the index spaces all come from a common partition specified by 'handle'. The resulting index space will be an intersection of all the index spaces of 'handle'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enlcosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index partition </td></tr>
    <tr><td class="paramname">color</td><td>the color to assign the index space to in the parent </td></tr>
    <tr><td class="paramname">handle</td><td>an index partition to intersect together </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="abdee40ed6877e577ef4c4a62f775230e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space_union </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new index space by unioning together a bunch of index spaces from a common index space tree. The resulting index space is assigned to be the index space corresponding to 'color' of the 'parent' index partition. It is illegal to invoke this method with a 'parent' index partition that was not created by a 'create_pending_partition' call. All of the index spaces being unioned together must come from the same index space tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index partition </td></tr>
    <tr><td class="paramname">color</td><td>the color to assign the index space to in the parent </td></tr>
    <tr><td class="paramname">handles</td><td>a vector index space handles to union </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="af46287bec00ed15ebd7d50fa6ba1a55d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::create_index_space_union </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the same as the one above, except the index spaces all come from a common partition specified by 'handle'. The resulting index space will be a union of all the index spaces of 'handle'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enlcosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index partition </td></tr>
    <tr><td class="paramname">color</td><td>the color to assign the index space to in the parent </td></tr>
    <tr><td class="paramname">handle</td><td>an index partition to union together </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="aeaffbe858643c9083a6a9ef39e472e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_lock.html">Lock</a> Legion::Runtime::create_lock </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new lock handle </dd></dl>

</div>
</div>
<a class="anchor" id="a2a571b535af50b8f7fbf88c5d88054f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> Legion::Runtime::create_logical_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>task_local</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new logical region tree from the given index space and field space. It is important to note that every call to this function will return a new logical region with a new tree ID. Only the triple of an index space, a field space, and a tree ID uniquely define a logical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">index</td><td>handle for the index space of the logical region </td></tr>
    <tr><td class="paramname">fields</td><td>handle for the field space of the logical region </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the logical region created </dd></dl>

</div>
</div>
<a class="anchor" id="ac878d96de9f646c4d9e98da3950d7a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_blockify </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td>
          <td class="paramname"><em>blocking_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by blockify is a special (but common) case of create partition by restriction, that is guaranteed to create a disjoint partition given the blocking factor specified for each dimension. This call will also create an implicit color space for the partition that is the caller's responsibility to reclaim. This assumes an origin of (0)* for all dimensions of the extent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space to be partitioned </td></tr>
    <tr><td class="paramname">blocking</td><td>factor the blocking factors for each dimension </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the parent index space </dd></dl>

</div>
</div>
<a class="anchor" id="a50aef6fe949121cc5675bc30b9a271f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_blockify </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td>
          <td class="paramname"><em>blockify_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alternate version of create partition by blockify that also takes an origin to use for the computation of the extent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space to be partitioned </td></tr>
    <tr><td class="paramname">blocking</td><td>factor the blocking factors for each dimension </td></tr>
    <tr><td class="paramname">origin</td><td>the origin to use for computing the extent </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the parent index space </dd></dl>

</div>
</div>
<a class="anchor" id="afb1d5252724c1165b6951b4c40f1b898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_difference </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function zips a set difference operation over all the index subspaces in two different partitions. The zip operation is only applied to the points contained in the intersection of the two color spaces. The difference is taken from the corresponding pairs of index spaces from each partition. The resulting partition is created off the 'parent' index space. In order to be sound, both index partitions must be from the same index tree and the first index partition must have the 'parent' index space as an ancestor. The user can say whether the partition is disjoint or not or ask the runtime to compute the result using the 'part_kind' argument. The user can assign a color to the new partition by the 'color' argument. index spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space for the new partition </td></tr>
    <tr><td class="paramname">handle1</td><td>first index partition </td></tr>
    <tr><td class="paramname">handle2</td><td>second index partition </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors to zip over </td></tr>
    <tr><td class="paramname">part_kind</td><td>indicate the kind of partition </td></tr>
    <tr><td class="paramname">color</td><td>the new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the created index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a5f30c909133a89f0c5ae99a92d54d1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_domain </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform_intersections</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by domain allows users to specify an explicit <a class="el" href="class_legion_1_1_domain.html">Domain</a> object to use for one or more subregions directly. This is similar to the old (deprecated) coloring APIs. However, instead of specifying colors for each element, we encourage users to create domains that express as few dense rectangles in them as necessary for expressing the index space. The runtime will not attempt to coalesce the rectangles in each domain further. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space to be partitioned </td></tr>
    <tr><td class="paramname">domains</td><td>map of points in the color space points to domains </td></tr>
    <tr><td class="paramname">color_space</td><td>the color space for the partition </td></tr>
    <tr><td class="paramname">perform_intersections</td><td>intersect domains with parent space </td></tr>
    <tr><td class="paramname">part_kind</td><td>specify the partition kind or ask to compute it </td></tr>
    <tr><td class="paramname">color</td><td>the color of the result of the partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the parent index space </dd></dl>

</div>
</div>
<a class="anchor" id="a98f028a0614677a5f9fab2c700dfde3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_domain </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;&#160;</td>
          <td class="paramname"><em>domain_future_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform_intersections</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an alternate version of create_partition_by_domain that instead takes a future map for the list of domains to be used. The runtime will automatically interpret the results in the individual futures as domains for creating the partition. This allows users to create this partition without blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space to be partitioned </td></tr>
    <tr><td class="paramname">domains</td><td>future map of points to domains </td></tr>
    <tr><td class="paramname">color_space</td><td>the color space for the partition </td></tr>
    <tr><td class="paramname">perform_intersections</td><td>intersect domains with parent space </td></tr>
    <tr><td class="paramname">part_kind</td><td>specify the partition kind or ask to compute it </td></tr>
    <tr><td class="paramname">color</td><td>the color of the result of the partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the parent index space </dd></dl>

</div>
</div>
<a class="anchor" id="ac3eff619ee6af41d64afc6dcfab212f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_field </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_DISJOINT_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>&#160;</td>
          <td class="paramname"><em>map_arg</em> = <code><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by field uses an existing field in a logical region to perform a partitioning operation. The field type must be of 'Point&lt;COLOR_DIM,COLOR_COORD_T&gt;' type so that the runtime can interpret the field as an enumerated function from Point&lt;DIM,COORD_TT&gt; -&gt; Point&lt;COLOR_DIM,COLOR_COORD_T&gt;. Pointers are assigned into index subspaces based on their assigned color. Pointers with negative entries will not be assigned into any index subspace. The resulting index partition is a partition of the index space of the logical region over which the operation is performed. By definition this partition is disjoint. The 'color' argument can be used to specify an optional color for the index partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>logical region handle containing the chosen field and of which a partition will be created </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field ID of the logical region containing the coloring </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors for the partition </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the mapper to use for mapping the fields </td></tr>
    <tr><td class="paramname">tag</td><td>the context tag to pass to the mapper </td></tr>
    <tr><td class="paramname">part_kind</td><td>the kind of the partition </td></tr>
    <tr><td class="paramname">map_arg</td><td>an untyped buffer for the mapper data of the <a class="el" href="class_legion_1_1_partition.html">Partition</a> </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the index space of the logical region </dd></dl>

</div>
</div>
<a class="anchor" id="a990d3750e296d56d146bf5d67f4e49c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_image </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>&#160;</td>
          <td class="paramname"><em>map_arg</em> = <code><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by image creates a new index partition from an existing field that represents an enumerated function from pointers into the logical region containing the field 'fid' to pointers in the 'handle' index space. The function the field represents therefore has type ptr_t -&gt; ptr_t. We can therefore create a new index partition of 'handle' by mapping each of the pointers in the index subspaces in the index partition of the 'projection' logical partition to get pointers into the 'handle' index space and assigning them to a corresponding index subspace. The runtime will automatically compute if the resulting partition is disjoint or not. The user can give the new partition a color by specifying the 'color' argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the parent index space of the new index partition and the one in which all the ptr_t contained in 'fid' must point </td></tr>
    <tr><td class="paramname">projection</td><td>the logical partition of which we are creating a projected version of through the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field ID of the 'projection' logical partition we are reading which contains ptr_t </td></tr>
    <tr><td class="paramname">color_space</td><td>the index space of potential colors </td></tr>
    <tr><td class="paramname">part_kind</td><td>specify the kind of partition </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the mapper to use for mapping field </td></tr>
    <tr><td class="paramname">tag</td><td>the mapper tag to provide context to the mapper </td></tr>
    <tr><td class="paramname">map_arg</td><td>an untyped buffer for the mapper data of the <a class="el" href="class_legion_1_1_partition.html">Partition</a> </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the 'handle' index space </dd></dl>

</div>
</div>
<a class="anchor" id="a2f83d2e58f036b2e2d2ad653752d7417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_intersection </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function zips an intersection operation over all the index subspaces in two different partitions. The zip operation is only applied to points contained in the intersection of the two color spaces. The corresponding pairs of index spaces from each partition are intersected together and assigned to the same color in the new index partition. The resulting partition is created off the 'parent' index space. In order to be sound both index partitions must come from the same index tree as the parent and at least one must have the 'parent' index space as an ancestor. The user can say whether the partition is disjoint or not or ask the runtime to compute the result using the 'part_kind' argument. The user can assign a color to the new partition by the 'color' argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space for the new partition </td></tr>
    <tr><td class="paramname">handle1</td><td>first index partition </td></tr>
    <tr><td class="paramname">handle2</td><td>second index partition </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors to zip over </td></tr>
    <tr><td class="paramname">part_kind</td><td>indicate the kind of partition </td></tr>
    <tr><td class="paramname">color</td><td>the new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the created index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a9aa4ddd1be0da7dba779021f2daa1faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_intersection </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dominates</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of create partition by intersection will intersect an existing partition with a parent index space in order to generate a new partition where each subregion is the intersection of the parent with the corresponding subregion in the original partition. We require that the partition and the parent index space both have the same dimensionality and coordinate type, but they can be otherwise unrelated. The application can also optionally indicate that the parent will dominate all the subregions in the partition which will allow the runtime to elide the intersection test and turn this into a partition copy operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the new parent index space for the mirrored partition </td></tr>
    <tr><td class="paramname">partition</td><td>the partition to mirror </td></tr>
    <tr><td class="paramname">part_kind</td><td>optinally specify the completenss of the partition </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the mirrored partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
    <tr><td class="paramname">dominates</td><td>whether the parent dominates the partition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae479d425cb2ce28ca0e5f8c4352803b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_preimage </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>&#160;</td>
          <td class="paramname"><em>map_arg</em> = <code><a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by premimage performs the opposite operation of create partition by image. The function will create a new index partition of the index space of 'handle' by projecting it through another index space 'projection'. The field contained in 'fid' of the logical region 'handle' must contain pointers into 'projection' index space. For each 'pointer' in the index space of 'handle', this function will compute its equivalent pointer into the index space tree of 'projection' by looking it up in the field 'fid'. The input pointer will be assigned to analogous index subspaces for each of the index subspaces in 'projection' that its projected pointer belonged to. The runtime will compute if the resulting partition is disjoint. The user can also assign a color to the new index partition with the 'color' argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">projection</td><td>the index partition being projected </td></tr>
    <tr><td class="paramname">handle</td><td>logical region over which to evaluate the function </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field ID of the 'handle' logical region containing the function being evaluated </td></tr>
    <tr><td class="paramname">color_space</td><td>the space of colors for the partition </td></tr>
    <tr><td class="paramname">part_kind</td><td>specify the kind of partition </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the mapper to use for mapping field </td></tr>
    <tr><td class="paramname">tag</td><td>the mapper tag to provide context to the mapper </td></tr>
    <tr><td class="paramname">map_arg</td><td>an untyped buffer for the mapper data of the <a class="el" href="class_legion_1_1_partition.html">Partition</a> </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the index space of 'handle' </dd></dl>

</div>
</div>
<a class="anchor" id="ad75fd95f229d19ada30337832ca8f3ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_restriction </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain_transform.html">DomainTransform</a>&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create partition by restriction will make a new partition of a logical region by computing new restriction bounds for each of the different subregions. All the sub-regions will have the same 'extent' (e.g. contain the same number of initial points). The particular location of the extent for each sub-region is determined by taking a point in the color space and transforming it by multiplying it by a 'transform' matrix to compute a 'delta' for the particular subregion. This 'delta' is then added to the bounds of the 'extent' rectangle to generate a new bounding rectangle for the subregion of the given color. The runtime will also automatically intersect the resulting bounding rectangle with the original bounds of the parent region to ensure proper containment. This may result in empty subregions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space to be partitioned </td></tr>
    <tr><td class="paramname">color_space</td><td>the color space of the partition </td></tr>
    <tr><td class="paramname">transform</td><td>a matrix transformation to be performed on each color </td></tr>
    <tr><td class="paramname">extent</td><td>the rectangle shape of each of the bounds </td></tr>
    <tr><td class="paramname">part_kind</td><td>the specify the partition kind </td></tr>
    <tr><td class="paramname">color</td><td>optional new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new index partition of the parent index space </dd></dl>

</div>
</div>
<a class="anchor" id="a2316d17a8248cedd61b0b6f6910838f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_union </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function zips a union operation over all the index subspaces in two different partitions. The zip operation is only applied to the points contained in the intersection of the two color spaces. The corresponding pairs of index spaces are unioned together and assigned to the same color in the new index partition. The resulting partition is created off the 'parent' index space. In order to be sound the parent must be an ancestor of both index partitions. The kind of partition (e.g. disjoint or aliased) can be specified with the 'part_kind' argument. This argument can also be used to request that the runtime compute the kind of partition. The user can assign a color to the new partition by the 'color' argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space for the new partition </td></tr>
    <tr><td class="paramname">handle1</td><td>first index partition </td></tr>
    <tr><td class="paramname">handle2</td><td>second index partition </td></tr>
    <tr><td class="paramname">color_space</td><td>space of colors to zip over </td></tr>
    <tr><td class="paramname">part_kind</td><td>indicate the kind of partition </td></tr>
    <tr><td class="paramname">color</td><td>the new color for the index partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the created index partition </dd></dl>

</div>
</div>
<a class="anchor" id="adc39d964f62c5c923a09a11de58ceca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_partition_by_weights </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>granularity</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create 'color_space' index spaces (one for each point) to partition the parent 'parent' index space using the 'weights' to proportionally size the resulting subspaces. By definition the resulting partition will be disjoint. Users can also specify a minimum 'granularity' for the size of the index subspaces. Users can specify an optional 'color' for the name of the created index partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space of the partition to be made </td></tr>
    <tr><td class="paramname">weights</td><td>per-color weights for sizing output regions </td></tr>
    <tr><td class="paramname">color_space</td><td>space of the colors to create </td></tr>
    <tr><td class="paramname">granularity</td><td>the minimum size of the index subspaces </td></tr>
    <tr><td class="paramname">color</td><td>optional color parameter for the partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the created index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a3f216d0f931bf8e8192d8d4fc2205278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::create_pending_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>color_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartitionKind&#160;</td>
          <td class="paramname"><em>part_kind</em> = <code>LEGION_COMPUTE_KIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new index partition in which the individual sub-regions will computed by one of the following calls:</p>
<ul>
<li>create_index_space_union (2 variants)</li>
<li>create_index_space_intersection (2 variants)</li>
<li>create_index_space_difference Once this call is made the application can immediately retrieve the names of the new sub-regions corresponding to each the different colors in the color space. However, it is the responsibility of the application to ensure that it actually computes an index space for each of the colors. Undefined behavior will result if the application tries to assign to a color of an index space more than once. If the runtime is asked to compute the disjointness, the application must assign values to each of the different subspace colors before querying the disjointness or deadlock will likely result (unless a different task is guaranteed to compute any remaining index subspaces). <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the parent index space for the partition </td></tr>
    <tr><td class="paramname">color_space</td><td>the color space for the new partition </td></tr>
    <tr><td class="paramname">part_kind</td><td>optionally specify the partition kind </td></tr>
    <tr><td class="paramname">color</td><td>optionally assign a color to the partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle of the new index partition </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a2dfcf5e6fc52dc9bcbb5d0eb76087472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a> Legion::Runtime::create_phase_barrier </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arrivals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new phase barrier with an expected number of arrivals. Note that this number of arrivals is the number of arrivals performed on each generation of the phase barrier and cannot be changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">arrivals</td><td>number of arrivals on the barrier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new phase barrier handle </dd></dl>

</div>
</div>
<a class="anchor" id="afd1eb2a680dce9e2dcd4c03093cb75e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a> Legion::Runtime::create_predicate </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new predicate value from a future. The future passed must be a boolean future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">f</td><td>future value to convert to a predicate </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>predicate value wrapping the future </dd></dl>

</div>
</div>
<a class="anchor" id="abe54270c655c3a1f30d38e8370b732f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a> Legion::Runtime::create_predicate </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_predicate_launcher.html">PredicateLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic predicate constructor for an arbitrary number of predicates </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the predicate launcher #return predicate value of combining other predicates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33c1b802f7bfb0c85e8192053cf9abfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::create_shared_ownership </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shared ownership of a top-level index space to prevent it from being destroyed by other potential owners. Every call to this method that succeeds must be matched with a corresponding call to destroy the index space in order for the index space to actually be deleted. The index space must not have been destroyed prior to this call being performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for top-level index space to request ownership for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8690291c53e667b2dc50fca6ea5dae0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::create_shared_ownership </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shared ownership of an index partition to prevent it from being destroyed by other potential owners. Every call to this method that succeeds must be matched with a corresponding call to destroy the index partition in order for the index partition to actually be deleted. The index partition must not have been destroyed prior to this call being performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for index partition to request ownership for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50ce52d630c4f0b8820e46ce39e5b221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::create_shared_ownership </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shared ownership of a field space to prevent it from being destroyed by other potential owners. Every call to this method that succeeds must be matched with a corresponding call to destroy the field space in order for the field space to actually be deleted. The field space must not have been destroyed prior to this call being performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for field space to request ownership for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f2b99b00f2adb30766adc73fd116241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::create_shared_ownership </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new shared ownership of a top-level logical region to prevent it from being destroyed by other potential owners. Every call to this method that succeeds must be matched with a corresponding call to destroy the logical region in order for the logical region to actually be deleted. The logical region must not have been destroyed prior to this call being performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for top-level logical region to request ownership for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a714e67a25827ba66bc3b58cd6748edce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::defer_dynamic_collective_arrival </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a deferred arrival on a dynamic collective dependent upon a future value. The runtime will automatically pipe the future value through to the dynamic collective. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">dc</td><td>dynamic collective on which to arrive </td></tr>
    <tr><td class="paramname">f</td><td>future to use for performing the arrival </td></tr>
    <tr><td class="paramname">count</td><td>total arrival count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a37a1dbbbfafef022fc55463d807b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_dynamic_collective </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td>
          <td class="paramname"><em>dc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a dynamic collective operation. It has the same semantics as the destruction of a phase barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">dc</td><td>dynamic collective to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a345455341864d8c45f9743c05fdb2dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_field_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an existing field space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>of the field space to be destroyed </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af43b0a87f19f1d6ceb1aca434dfd6d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an index partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index partition to be destroyed </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">recurse</td><td>destroy the full sub-tree below this partition </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20209f3cd0ba38d596257d05d6b34164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an existing index space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the index space to destroy </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">recurse</td><td>delete the full index tree </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55c3a2fca0f3456220fde2736431712a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_lock </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_lock.html">Lock</a>&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a lock. This operation will defer the lock destruction until the completion of the task in which the destruction is performed so the user does not need to worry about races with child operations which may be using the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">r</td><td>lock to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9349fe8247c32783efe2c30b2b43f7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_logical_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a logical partition and all of it is logical sub-regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>logical partition handle to destroy </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47d4d7b61fd5b0ffd1a34fa4ebfdb689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_logical_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a logical region and all of its logical sub-regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>logical region handle to destroy </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fb709efc503d8500f9710cb892b45a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::destroy_phase_barrier </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_phase_barrier.html">PhaseBarrier</a>&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a phase barrier. This operation will defer the phase barrier destruciton until the completion of the task in which in the destruction is performed so the the user does not need to worry about races with child operations which may still be using the phase barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">pb</td><td>phase barrier to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf5cfc4047ce453b5b6642ed23803770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::detach_external_resource </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach an external resource from a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>the physical region for the external resource </td></tr>
    <tr><td class="paramname">flush</td><td>copy out data to the physical region before detaching </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an empty future indicating when the resource is detached </dd></dl>

</div>
</div>
<a class="anchor" id="a4a58772ee8c20b794f915650a2e812be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::detach_external_resources </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_external_resources.html">ExternalResources</a>&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach multiple external resources that were all created by a common call to 'attach_external_resources'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">external</td><td>the external resources to detach </td></tr>
    <tr><td class="paramname">flush</td><td>copy out data to the physical region before detaching </td></tr>
    <tr><td class="paramname">unordered</td><td>set to true if this is performed by a different thread than the one for the task (e.g a garbage collector) </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an empty future indicating when the resources are detached </dd></dl>

</div>
</div>
<a class="anchor" id="af840cc317084b2faccf5321557755c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::detach_file </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Detach an normal file. THis detach operation is similar to detach_hdf5 </dd></dl>

</div>
</div>
<a class="anchor" id="ad93bf3b151012fb90aac52137eaf652f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::detach_hdf5 </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Detach an HDF5 file. This can only be performed on a physical region that was created by calling attach_hdf5. The runtime will properly defer the detach call until all other operations on the logical region are complete. It is the responsibility of the user to perform the necessary operations to flush any data back to the physical instance before detaching (e.g. releasing coherence, etc). If the physical region is still mapped when this function is called, then it will be unmapped by this call. Note that this file may not actually get detached until much later in the execution of the program due to <a class="el" href="namespace_legion.html">Legion</a>'s deferred execution model. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>the physical region for an HDF5 file to detach </td></tr>
  </table>
  </dd>
</dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3b1338247926eef76421390573c82cc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::disable_profiling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable recording of profiling information. </p>

</div>
</div>
<a class="anchor" id="ae3959f5e3dcedc969475d839dfb3a573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::dump_profiling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dump the current profiling information to file. </p>

</div>
</div>
<a class="anchor" id="a357602aa4f54f88fe361861fa50e20a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::enable_profiling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable recording of profiling information. </p>

</div>
</div>
<a class="anchor" id="a087efef8f6dde153b6419a591334d82d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::end_mapper_call </td>
          <td>(</td>
          <td class="paramtype">Mapping::MapperContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End a mapper call from the application side. This must be done for all mapper contexts created by calls into begin_mapper_call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>mapper context to end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac89bdf19645572d9fd250156aad5a383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::end_static_trace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finish a static trace of operations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f0dfc27d00a33bc914332f658e98fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::end_trace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TraceID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the end of trace that was being performed. </p>

</div>
</div>
<a class="anchor" id="a0e8d31f02a06b0b63824d1eb9f79b4eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> Legion::Runtime::execute_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch an index space of tasks with arguments specified by the index launcher configuration. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the task launcher configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future map for return values of the points in the index space of tasks </dd></dl>

</div>
</div>
<a class="anchor" id="aa6f07a1164d549f044af6db3f0830008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::execute_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch an index space of tasks with arguments specified by the index launcher configuration. Reduce all the return values into a single value using the specified reduction operator into a single future value. The reduction operation must be a foldable reduction. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_index_task_launcher.html">IndexTaskLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the task launcher configuration </td></tr>
    <tr><td class="paramname">redop</td><td>ID for the reduction op to use for reducing return values </td></tr>
    <tr><td class="paramname">deterministic</td><td>request that the reduced future value be computed in a deterministic way (more expensive than non-deterministic) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future result representing the reduction of all the return values from the index space of tasks </dd></dl>

</div>
</div>
<a class="anchor" id="a7e5e4f0c7a374673017c11c064bae7c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> Legion::Runtime::execute_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>global_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a> &amp;&#160;</td>
          <td class="paramname"><em>arg_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>Predicate::TRUE_PRED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>must_paralleism</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>An older method for launching an index space of tasks maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">domain</td><td>for the set of points in the index space to create </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the tasks </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the tasks </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the tasks </td></tr>
    <tr><td class="paramname">global_arg</td><td>untyped arguments passed by value to all tasks </td></tr>
    <tr><td class="paramname">arg_map</td><td>argument map containing point arguments for tasks </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">must_parallelism</td><td>are tasks required to be run concurrently </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future map containing results for all tasks </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a041162c3fe46047c46e9e00a26f75528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::execute_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain.html">Domain</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>global_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_argument_map.html">ArgumentMap</a> &amp;&#160;</td>
          <td class="paramname"><em>arg_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>Predicate::TRUE_PRED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>must_parallelism</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>An older method for launching an index space of tasks that reduce all of their values by a reduction operation down to a single future. Maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">domain</td><td>for the set of points in the index space to create </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the tasks </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the tasks </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the tasks </td></tr>
    <tr><td class="paramname">global_arg</td><td>untyped arguments passed by value to all tasks </td></tr>
    <tr><td class="paramname">arg_map</td><td>argument map containing point arguments for tasks </td></tr>
    <tr><td class="paramname">reduction</td><td>operation to be used for reducing return values </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">must_parallelism</td><td>are tasks required to be run concurrently </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future containing reduced return value of all tasks </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4f219e544094fa61ddea088645482e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> Legion::Runtime::execute_must_epoch </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_must_epoch_launcher.html">MustEpochLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch a collection of operations that all must be guaranteed to execute in parallel. This construct is necessary for ensuring the correctness of tasks which use simultaneous coherence and perform synchronization between different physical instances (e.g. using phase barriers or reservations). </p>

</div>
</div>
<a class="anchor" id="a7b7d00659246b245b91410987e65eea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::execute_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_launcher.html">TaskLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch a single task with arguments specified by the configuration of the task launcher. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_task_launcher.html">TaskLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the task launcher configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future for the return value of the task </dd></dl>

</div>
</div>
<a class="anchor" id="a9a607c1fa178a6f1369b4471ec1414b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::execute_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_index_space_requirement.html">IndexSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_field_space_requirement.html">FieldSpaceRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_untyped_buffer.html">UntypedBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>Predicate::TRUE_PRED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>An older method for launching a single task maintained for backwards compatibility with older <a class="el" href="namespace_legion.html">Legion</a> programs. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">task_id</td><td>the ID of the task to launch </td></tr>
    <tr><td class="paramname">indexes</td><td>the index space requirements for the task </td></tr>
    <tr><td class="paramname">fields</td><td>the field space requirements for the task </td></tr>
    <tr><td class="paramname">regions</td><td>the region requirements for the task </td></tr>
    <tr><td class="paramname">arg</td><td>untyped arguments passed by value to the task </td></tr>
    <tr><td class="paramname">predicate</td><td>for controlling speculation </td></tr>
    <tr><td class="paramname">id</td><td>of the mapper to associate with the task </td></tr>
    <tr><td class="paramname">tag</td><td>mapping tag to be passed to any mapping calls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future representing return value of the task </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a140bb70e85c103a86fab13e7d496eb7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_field </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_fill.html">Fill</a> the specified field by setting all the entries in the index space from the given logical region to a specified value. Importantly this operation is done lazily so that the writes only need to happen the next time the field is used and therefore it is a very inexpensive operation to perform. This operation requires read-write privileges on the requested field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field to fill </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to all the entries </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a889a6d23c86a02ec305561be1ba20b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_field </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of fill field is exactly the same as the one above, but is untyped and allows the value to be specified as a buffer with a size. The runtime will make a copy of the buffer. This operation requires read-write privileges on the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field to fill </td></tr>
    <tr><td class="paramname">value</td><td>pointer to the buffer containing the value to be used </td></tr>
    <tr><td class="paramname">value_size</td><td>size of the buffer in bytes </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba0b72552910db25303cd67970d584e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_field </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version of fill field is exactly the same as the one above, but uses a future value. This operation requires read-write privileges on the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fid</td><td>the field to fill </td></tr>
    <tr><td class="paramname">value</td><td>pointer to the buffer containing the value to be used </td></tr>
    <tr><td class="paramname">value_size</td><td>size of the buffer in bytes </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a113667a31d9e922b56cd95d2f5409b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_fill.html">Fill</a> multiple fields of a logical region with the same value. This operation requires read-write privileges on the fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fields</td><td>the set of fields to fill </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to all the entries </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8953222069a4b25004f7d67f58acda3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_fill.html">Fill</a> multiple fields of a logical region with the same value. The runtime will make a copy of the buffer passed. This operation requires read-write privileges on the fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fields</td><td>the set of fields to fill </td></tr>
    <tr><td class="paramname">value</td><td>pointer to the buffer containing the value to be used </td></tr>
    <tr><td class="paramname">value_size</td><td>size of the buffer in bytes </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e26e3821b804151fe5773c1f7e31066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a>&#160;</td>
          <td class="paramname"><em>pred</em> = <code>Predicate::TRUE_PRED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_fill.html">Fill</a> multiple fields of a logical region with the same future value. This operation requires read-write privileges on the fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region on which to fill the field </td></tr>
    <tr><td class="paramname">parent</td><td>the parent region from which privileges are derived </td></tr>
    <tr><td class="paramname">fields</td><td>the set of fields to fill </td></tr>
    <tr><td class="paramname">future</td><td>the future value to use for filling the fields </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6e5fbafa51f0d505fb4878db79d9fb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_fill_launcher.html">FillLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a fill operation using a launcher which specifies all of the parameters of the launch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the launcher that describes the fill operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92453823db486b1a23ff6e1017da2bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::fill_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_index_fill_launcher.html">IndexFillLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an index fill operation using a launcher which specifies all the parameters of the launch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>the launcher that describes the index fill operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51590b28041537778aab81d790ebdbe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;int,AddressSpace&gt;&amp; Legion::Runtime::find_forward_MPI_mapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the mapping from MPI ranks to address spaces. This method is only valid if the static initialization method 'configure_MPI_interoperability' was called on all nodes before starting the runtime with the static 'start' method. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the forward map </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b6769d9ee8de7892f0b5d5c3cc4ab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Legion::Runtime::find_local_MPI_rank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local MPI rank ID for the current <a class="el" href="namespace_legion.html">Legion</a> runtime </p>

</div>
</div>
<a class="anchor" id="ac27b2638c8aa39d366886a678f63749d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;AddressSpace,int&gt;&amp; Legion::Runtime::find_reverse_MPI_mapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the reverse mapping from address spaces to MPI ranks. This method is only valid if the static initialization method 'configure_MPI_interoperability' was called on all nodes before starting the runtime with the static 'start' method. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the reverse map </dd></dl>

</div>
</div>
<a class="anchor" id="aa64e8a16a1b5769cd8542338f0200100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::finish_implicit_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the final method for marking the end of an implicit top-level task. Note that it executes asychronously and it is still the responsibility of the user to wait for the runtime to shutdown when all of it's effects are done. The Context object is no longer valid after this call. </p>

</div>
</div>
<a class="anchor" id="a710dd7fbc03f776789c4b0ee538a50f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MapperID Legion::Runtime::generate_dynamic_mapper_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique Mapper ID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a Mapper ID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="aff251c3730c6ef38345121889807c879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProjectionID Legion::Runtime::generate_dynamic_projection_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique projection ID for use across the machine  a ProjectionID that is globally unique across the machine </p>

</div>
</div>
<a class="anchor" id="affb54cd8076ac9a0604bba29bff183bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReductionOpID Legion::Runtime::generate_dynamic_reduction_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique reduction ID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a ReductionOpID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a4c70f76c03a26412e89206df8103e5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CustomSerdezID Legion::Runtime::generate_dynamic_serdez_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique serdez ID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a CustomSerdezID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a3218b7f14c3a92c47be12d0ddcb77694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShardingID Legion::Runtime::generate_dynamic_sharding_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique sharding ID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a ShardingID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a249a6a1cd0c1a87157a916681b0c6a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskID Legion::Runtime::generate_dynamic_task_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique <a class="el" href="class_legion_1_1_task.html">Task</a> ID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_legion_1_1_task.html">Task</a> ID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a676e0571bd9be25788063ded6303189a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TraceID Legion::Runtime::generate_dynamic_trace_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically generate a unique TraceID for use across the machine </p>
<dl class="section return"><dt>Returns</dt><dd>a TraceID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a1cfa9087b19781f3a645e7dba9d45557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MapperID Legion::Runtime::generate_library_mapper_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of MapperIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of mapper IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first mapper ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="aa8752180deb9b0547d2eaab51e78a45f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProjectionID Legion::Runtime::generate_library_projection_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of ProjectionIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of projection IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first projection ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="a96be12e76153f4dc356421f7072db801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReductionOpID Legion::Runtime::generate_library_reduction_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of ReductionOpIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of reduction IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first reduction ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="a8d2e4e8576f3b6408824b643b79f79b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CustomSerdezID Legion::Runtime::generate_library_serdez_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of CustomSerdezIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of serdez IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first serdez ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="ace3cbdfa056de737b5187c350a0000a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShardingID Legion::Runtime::generate_library_sharding_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of ShardingIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of sharding IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first sharding ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="a8cc9e3ca9a0efc36d04bc2bd7e2c8ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskID Legion::Runtime::generate_library_task_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of TaskIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of task IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first task ID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="ab11042f09a94d61949dae96d611eb944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TraceID Legion::Runtime::generate_library_trace_ids </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a contiguous set of TraceIDs for use by a library. This call will always generate the same answer for the same library name no many how many times it is called or on how many nodes it is called. If the count passed in to this method differs for the same library name the runtime will raise an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique null-terminated string that names the library </td></tr>
    <tr><td class="paramname">count</td><td>the number of trace IDs that should be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first TraceID that is allocated to the library </dd></dl>

</div>
</div>
<a class="anchor" id="ae9bdb63597d855c08e6bc37ffeaec90d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MapperID Legion::Runtime::generate_static_mapper_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique Mapper ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all nodes in the machine prior to starting the rutnime. </p>
<dl class="section return"><dt>Returns</dt><dd>a MapperID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="afa9313599c62c1c03089d4b4fea19463"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ProjectionID Legion::Runtime::generate_static_projection_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique Projection ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all the nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>a ProjectionID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="ae1cd6d9bff2aefe7087b35844ab9217a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ReductionOpID Legion::Runtime::generate_static_reduction_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique reduction ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all the nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>a ReductionOpID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a92e64df524c296e54dc6068dc0798358"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CustomSerdezID Legion::Runtime::generate_static_serdez_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique serdez ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all the nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>a CustomSerdezID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="acf0909cfe0ea7e5636968cc61eaada18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ShardingID Legion::Runtime::generate_static_sharding_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique Sharding ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all the nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>ShardingID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a0807fe3cf812682fcbdb29e1ebaa0918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskID Legion::Runtime::generate_static_task_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique <a class="el" href="class_legion_1_1_task.html">Task</a> ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>a TaskID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a2d11b01690d3c3859b75d92094ddd720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TraceID Legion::Runtime::generate_static_trace_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically generate a unique Trace ID for use across the machine. This can only be called prior to the runtime starting. It must be invoked symmetrically across all the nodes in the machine prior to starting the runtime. </p>
<dl class="section return"><dt>Returns</dt><dd>a TraceID that is globally unique across the machine </dd></dl>

</div>
</div>
<a class="anchor" id="a0ae1696024e39fb7afc5ed87797ad8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Context Legion::Runtime::get_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the context for the currently executing task this must be called inside of an actual <a class="el" href="namespace_legion.html">Legion</a> task. Calling it outside of a <a class="el" href="namespace_legion.html">Legion</a> task will result in undefined behavior </p>
<dl class="section return"><dt>Returns</dt><dd>the context for the enclosing task in which we are executing </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb3136f2a6068ad51307831ee645c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_legion_1_1_task.html">Task</a>* Legion::Runtime::get_context_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the task object associated with a context </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing processor context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the task representation of the context </dd></dl>

</div>
</div>
<a class="anchor" id="a74371677d9d67f800329ac5c770c54c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_legion_1_1_task.html">Task</a>* Legion::Runtime::get_current_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the task object for the currently executing task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="class_legion_1_1_task.html">Task</a> object for the current task </dd></dl>

</div>
</div>
<a class="anchor" id="ac1c740ac313e5a6bb1e986d334a345ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::get_current_time </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td>
          <td class="paramname"><em>precondition</em> = <code><a class="el" href="class_legion_1_1_future.html">Future</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an operation into the stream to record the current time in seconds. The resulting future should be interpreted as a 'double' that represents the absolute time when this measurement was taken. The operation can be given an optional future which will not be interpreted, but will be used as a precondition to ensure that the measurement will not be taken until the precondition is complete. </p>

</div>
</div>
<a class="anchor" id="af81ff08366d6e945735015c228595f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::get_current_time_in_microseconds </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td>
          <td class="paramname"><em>precondition</em> = <code><a class="el" href="class_legion_1_1_future.html">Future</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an operation into the stream to record the current time in microseconds. The resulting future should be interpreted as a 'long long' with no fractional microseconds. The operation can be givien an optional future precondition which will not be interpreted, but ill be used as a precondition to ensure that the measurement will not be taken until the precondition is complete. </p>

</div>
</div>
<a class="anchor" id="a08a4e3e7621d3f8bc12b4c54e2c13001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::get_current_time_in_nanoseconds </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td>
          <td class="paramname"><em>precondition</em> = <code><a class="el" href="class_legion_1_1_future.html">Future</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an operation into the stream to record the current time in nanoseconds. The resulting future should be interpreted as a 'long long' with no fractional nanoseconds. The operation can be givien an optional future precondition which will not be interpreted, but ill be used as a precondition to ensure that the measurement will not be taken until the precondition is complete. </p>

</div>
</div>
<a class="anchor" id="a27211b0ad6a4087bb97de66f8fa44f20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::get_dynamic_collective_result </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_dynamic_collective.html">DynamicCollective</a>&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will return the value of a dynamic collective in the form of a future. Applications can then use this future just like all other futures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">dc</td><td>dynamic collective on which to get the result </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>future value that contains the result of the collective </dd></dl>

</div>
</div>
<a class="anchor" id="aae005a8b8c1f513af1c52029d22bbf9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Processor Legion::Runtime::get_executing_processor </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the processor on which the current task is being executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the processor on which the task is running </dd></dl>

</div>
</div>
<a class="anchor" id="a8f321f0c4b28b50018bca830829f6f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Runtime::get_field_size </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the size of a specific field within field space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">fid</td><td>field ID for which to find the size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the field in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a383b27d0b35fb369684129730cd22abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::get_field_space_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the IDs of the fields currently allocated in a field space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">set</td><td>in which to place the field IDs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9139a80c882ad60d4e2f929926bd5746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::get_field_space_fields </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; FieldID &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the IDs of the fields currently allocated in a field space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">set</td><td>in which to place the field IDs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2500d5ff24ddb3dd51ed72fa27059092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::get_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index partitioning of an index space with the assigned color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space </td></tr>
    <tr><td class="paramname">color</td><td>of index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the index partition with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="a7d69bd699220851a3b5ac75b281dbd62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color Legion::Runtime::get_index_partition_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the color for the corresponding index partition in in relation to its parent logical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the index partition for which to find the color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color for the index partition </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a30d26bbe0213364d650a180c91259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_domain.html">Domain</a> Legion::Runtime::get_index_partition_color_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a domain that represents the color space for the specified partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>handle for the index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a domain for the color space of the specified partition </dd></dl>

</div>
</div>
<a class="anchor" id="a442a5007d55a2fc1bec4ebfd9d847670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::get_index_partition_color_space_name </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the name of the color space for a partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>handle for the index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the color space of the specified partition </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd3dbb5c492a9d29ba73df9f91367d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Legion::Runtime::get_index_partition_depth </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the depth in the index space tree of the given index partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth in the index space tree of the index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a8d6888ccb6eebe2f6451ae4bae7f5e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color Legion::Runtime::get_index_space_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the color for the corresponding index space in its member partition. If it is a top-level index space then zero will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the index space for which to find the color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color for the index space </dd></dl>

</div>
</div>
<a class="anchor" id="ae96ebe79753c43b45029c5b29e6d2182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Legion::Runtime::get_index_space_depth </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the depth in the index space tree of the given index space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth in the index space tree of the index space </dd></dl>

</div>
</div>
<a class="anchor" id="aafd8990d5deccad8024d786a4f9c44ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_domain.html">Domain</a> Legion::Runtime::get_index_space_domain </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the domain corresponding to the specified index space if it exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the domain corresponding to the index space </dd></dl>

</div>
</div>
<a class="anchor" id="a1afb2c536734219c0f4c8973219c1e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::get_index_space_domains </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_legion_1_1_domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Return the domains that represent the index space. While the previous call only works when there is a single domain for the index space, this call will work in all circumstances. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">vector</td><td>to populate with domains </td></tr>
  </table>
  </dd>
</dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a166661797fec45438f9e87a778bcb143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::get_index_space_partition_colors </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; Color &gt; &amp;&#160;</td>
          <td class="paramname"><em>colors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a set that contains the colors of all the partitions of the index space. It is unlikely the colors are numerically dense which precipitates the need for a set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">sp</td><td>handle for the index space </td></tr>
    <tr><td class="paramname">colors</td><td>reference to the set object in which to place the colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf32a26bbbbf07ba7f7aca9d4109d589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::get_index_subspace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index subspace of an index partitioning with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>parent index partitioning </td></tr>
    <tr><td class="paramname">color</td><td>of the index sub-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle for the index space with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="ab69648bdfc893258e57b6d0e75cab8d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::get_index_subspace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LegionRuntime::Arrays::Point&lt; DIM &gt;&#160;</td>
          <td class="paramname"><em>color_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Get an index subspace from a partition with a given color point. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>parent index partition handle </td></tr>
    <tr><td class="paramname">color_point</td><td>point containing color value of index subspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding index space to the specified color point </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a86706aed4463173286cfdacd8a5c9c23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="struct_legion_1_1_input_args.html">InputArgs</a>&amp; Legion::Runtime::get_input_args </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method can be used to retrieve the default arguments passed into the runtime at the start call from any point in the machine. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the input arguments passed in at start-up </dd></dl>

</div>
</div>
<a class="anchor" id="a997dbe4572afcee60009c90f10f01e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a> Legion::Runtime::get_layout_constraint_field_space </td>
          <td>(</td>
          <td class="paramtype">LayoutConstraintID&#160;</td>
          <td class="paramname"><em>layout_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the field space for a specific layout description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout_id</td><td>the layout ID for which to obtain the field space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field space handle for the layout description </dd></dl>

</div>
</div>
<a class="anchor" id="a6d59c74088bf40aac44f4ac6e67bf09e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::get_layout_constraints </td>
          <td>(</td>
          <td class="paramtype">LayoutConstraintID&#160;</td>
          <td class="paramname"><em>layout_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayoutConstraintSet &amp;&#160;</td>
          <td class="paramname"><em>layout_constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the constraints for a specific layout description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout_id</td><td>the layout ID for which to obtain the constraints </td></tr>
    <tr><td class="paramname">layout_constraints</td><td>a LayoutConstraintSet to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac365a5387d02cedee6a70d89d883f0cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Legion::Runtime::get_layout_constraints_name </td>
          <td>(</td>
          <td class="paramtype">LayoutConstraintID&#160;</td>
          <td class="paramname"><em>layout_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name associated with a particular layout description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout_id</td><td>the layout ID for which to obtain the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a string of the name of the layou description </dd></dl>

</div>
</div>
<a class="anchor" id="ad454cb6f6219e29c1278480a3dd4d09a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* Legion::Runtime::get_legion_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string representing the <a class="el" href="namespace_legion.html">Legion</a> version. This string can be compared in application code against the LEGION_VERSION macro defined by <a class="el" href="legion_8h.html">legion.h</a> to detect header/library mismatches. </p>

</div>
</div>
<a class="anchor" id="a580d2097717587b6843d2a3bd7edbef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_legion_1_1_task.html">Task</a>* Legion::Runtime::get_local_task </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a reference to the task for the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the task for the context </dd></dl>

</div>
</div>
<a class="anchor" id="ab9f1b71c70eaaa525ecf6dd54e6690a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Legion::Runtime::get_local_task_variable_untyped </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalVariableID&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of a task-local variable named by the ID. This variable only has the lifetime of the task </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the task-local variable to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value of the variable if any </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a5c2ac979cf345aef6f1228094a123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> Legion::Runtime::get_logical_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical partition instance of the given index partition in the region tree for the parent logical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the logical region parent </td></tr>
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding logical partition in the same tree as the parent region </dd></dl>

</div>
</div>
<a class="anchor" id="ae164cbd42bbe5a25996ae15eb8d24d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> Legion::Runtime::get_logical_partition_by_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical partition of the logical region parent with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>logical region </td></tr>
    <tr><td class="paramname">color</td><td>for the specified logical partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical partition for the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc916db695b09528ffbf7ff84d22b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> Legion::Runtime::get_logical_partition_by_tree </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>fspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegionTreeID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical partition identified by the triple of index partition, field space, and region tree ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
    <tr><td class="paramname">fspace</td><td>field space handle </td></tr>
    <tr><td class="paramname">tid</td><td>region tree ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding logical partition </dd></dl>

</div>
</div>
<a class="anchor" id="a19959d25a409bd42b83f3c46effa78d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color Legion::Runtime::get_logical_partition_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the color for the logical partition corresponding to its location relative to the parent logical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical partition handle for which to find the color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color for the logical partition </dd></dl>

</div>
</div>
<a class="anchor" id="ae006fc7a66d9efe5f079e8e83fe56ba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color Legion::Runtime::get_logical_region_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the color for the logical region corresponding to its location in the parent partition. If the region is a top-level region then zero is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical region for which to find the color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color for the logical region </dd></dl>

</div>
</div>
<a class="anchor" id="a62ae579f7527fbb9bca25d97b664e643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> Legion::Runtime::get_logical_subregion </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical region instance of the given index space in the region tree for the parent logical partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>the logical partition parent </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding logical region in the same tree as the parent partition </dd></dl>

</div>
</div>
<a class="anchor" id="adceef7f0d276d6809ee2915b45c57339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> Legion::Runtime::get_logical_subregion_by_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical region of the logical partition parent with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>logical partition </td></tr>
    <tr><td class="paramname">color</td><td>for the specified logical region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical region for the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="a654a54016487be150b4a2b22fe2dd368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> Legion::Runtime::get_logical_subregion_by_tree </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>fspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegionTreeID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logical partition identified by the triple of index space, field space, and region tree ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">fspace</td><td>field space handle </td></tr>
    <tr><td class="paramname">tid</td><td>region tree ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding logical region </dd></dl>

</div>
</div>
<a class="anchor" id="a888c6816e049c49ce25e6196b15535d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::Mapper* Legion::Runtime::get_mapper </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>target</em> = <code>Processor::NO_PROC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the mapper at the given mapper ID associated with the processor in which this task is executing. This call allows applications to make calls into mappers that they have created to inform that mapper of important application level information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">id</td><td>the mapper ID for which mapper to locate </td></tr>
    <tr><td class="paramname">target</td><td>processor if any, if none specified then the executing processor for the current context is used, if specified processor must be local to the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the specified mapper object </dd></dl>

</div>
</div>
<a class="anchor" id="ad899e01c313c6ef26865f873e9232887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::MapperRuntime* Legion::Runtime::get_mapper_runtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mapper runtime for passing to a newly created mapper. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the mapper runtime for this <a class="el" href="namespace_legion.html">Legion</a> instance </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f5f4c6e37c8bc225de4b1851d87a2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Legion::Runtime::get_maximum_dimension </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of dimensions that <a class="el" href="namespace_legion.html">Legion</a> was configured to support in this build. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of dimensions that <a class="el" href="namespace_legion.html">Legion</a> supports </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca198b6c23f72a8e0269e50d49ae556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a> Legion::Runtime::get_parent_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the parent partition for the given index space. Use the previous call to check to see if a parent actually exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parent index partition </dd></dl>

</div>
</div>
<a class="anchor" id="ac3eda0d64b2aced859894d2967e26ccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::get_parent_index_space </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index space parent for the given index partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index space for the parent </dd></dl>

</div>
</div>
<a class="anchor" id="a54086a6e4fb144bec4a48d414eaffbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a> Legion::Runtime::get_parent_logical_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the parent logical partition for a logical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the logical region for which to find a parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parent logical partition </dd></dl>

</div>
</div>
<a class="anchor" id="aecb1ba26ad2b6d3857afaff64bb9de93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a> Legion::Runtime::get_parent_logical_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the parent logical region for a given logical partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>the logical partition handle for which to find a parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parent logical region </dd></dl>

</div>
</div>
<a class="anchor" id="a35f8b658d5534f78088c7e268567b0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::get_predicate_future </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a future value that will be completed when the predicate triggers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate for which to get a future </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean future with the result of the predicate </dd></dl>

</div>
</div>
<a class="anchor" id="a97afe9ec2226b0cd545b291c407296c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a>* Legion::Runtime::get_projection_functor </td>
          <td>(</td>
          <td class="paramtype">ProjectionID&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a given projection functor object. The runtime retains ownership of this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>ID of the projection functor to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the projection functor if it exists </dd></dl>

</div>
</div>
<a class="anchor" id="af3562ae6bc99740fdf7dead6ea6e6fb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const ReductionOp* Legion::Runtime::get_reduction_op </td>
          <td>(</td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a given reduction operation object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">redop_id</td><td>ID of the reduction operation to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the reduction operation object if it exists </dd></dl>

</div>
</div>
<a class="anchor" id="a61ae746205378b10cd898824b719ee8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_runtime.html">Runtime</a>* Legion::Runtime::get_runtime </td>
          <td>(</td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>p</em> = <code>Processor::NO_PROC</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a mechanism for finding the <a class="el" href="namespace_legion.html">Legion</a> runtime pointer for a processor wrapper tasks that are starting a new application level task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">processor</td><td>the task will run on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="namespace_legion.html">Legion</a> runtime pointer for the specified processor </dd></dl>

</div>
</div>
<a class="anchor" id="a5e5c849820b8b363331fea7345707aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SerdezOp* Legion::Runtime::get_serdez_op </td>
          <td>(</td>
          <td class="paramtype">CustomSerdezID&#160;</td>
          <td class="paramname"><em>serdez_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the given custom serdez operation object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serdez_id</td><td>ID of the serdez operation to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the serdez operation object if it exists </dd></dl>

</div>
</div>
<a class="anchor" id="a183d30f63de89ea1f1becf1b3a36fda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Legion::Runtime::get_tunable_value </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TunableID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>mapper</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>This is the old method for asking the mapper to specify a tunable value. It will assume that the resulting tunable future can be interpreted as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6291e578160b1d11704361cc2fe5953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long long Legion::Runtime::get_zero_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the base time in nanoseconds on THIS node with which all other aboslute timings can be compared. This value will not change during the course of the lifetime of a <a class="el" href="namespace_legion.html">Legion</a> application and may therefore be safely cached. </p>

</div>
</div>
<a class="anchor" id="ac2bae127d301ae23323b0341b01ab94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Legion::Runtime::has_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether we are inside of a <a class="el" href="namespace_legion.html">Legion</a> task and therefore have a context available. This can be used to see if it is safe to call '<a class="el" href="class_legion_1_1_runtime.html#a0ae1696024e39fb7afc5ed87797ad8ff">Runtime::get_context</a>'. </p>
<dl class="section return"><dt>Returns</dt><dd>boolean indicating if we are inside of a <a class="el" href="namespace_legion.html">Legion</a> task </dd></dl>

</div>
</div>
<a class="anchor" id="a2db78ed39353a434fad6b403c52fb5a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the index space has an index partition with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>index space </td></tr>
    <tr><td class="paramname">color</td><td>of index partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an index partition exists with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="aa3614582fe1829077771a7c6003654dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_index_subspace </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the index partition has an index subspace with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>parent index partitioning </td></tr>
    <tr><td class="paramname">color</td><td>of the index sub-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an index space exists with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="ab45e29c1e287be2765f1c7e36d51be7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_logical_partition_by_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the logical region has a logical partition with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>logical region </td></tr>
    <tr><td class="paramname">color</td><td>for the specified logical partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the logical partition exists with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="abf8611680f7d1150f80e8512bee304fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_logical_subregion_by_color </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the logical partition has a logical region with the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">parent</td><td>logical partition </td></tr>
    <tr><td class="paramname">color</td><td>for the specified logical region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a logical region exists with the specified color </dd></dl>

</div>
</div>
<a class="anchor" id="adb0ee94d82c36b374cf3804a48f7a16b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_multiple_domains </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Return if the given index space is represented by multiple domains or just a single one. If multiple domains represent the index space then 'get_index_space_domains' should be used for getting the set of domains. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index space has multiple domains </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1be0f5a074a6df83b283fc0acd5f3e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_parent_index_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given index space has a parent partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is a parent index partition </dd></dl>

</div>
</div>
<a class="anchor" id="a4aab2f2c259fd3c203ad15374f38f991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::has_parent_logical_partition </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the logical region has a parent logical partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">handle</td><td>for the logical region for which to check for a parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a parent exists </dd></dl>

</div>
</div>
<a class="anchor" id="af0b93b22fb8f780717fa6310e289dad3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Legion::Runtime::has_runtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a method to test whether the <a class="el" href="namespace_legion.html">Legion</a> runtime has been started yet or not. Note that this method simply queries at a single point in time and can race with a call to <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> performed by a different thread. </p>

</div>
</div>
<a class="anchor" id="a7604218afb83fecd6d9e47a1852b6219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::initialize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This 'initialize' method is an optional method that provides users a way to look at the command line arguments before they actually start the <a class="el" href="namespace_legion.html">Legion</a> runtime. Users will still need to call 'start' in order to actually start the <a class="el" href="namespace_legion.html">Legion</a> runtime but this way they can do some static initialization and use their own command line parameters to initialize the runtime prior to actually starting it. The resulting 'argc' and 'argv' should be passed into the 'start' method or undefined behavior will occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>pointer to an integer in which to store the argument count </td></tr>
    <tr><td class="paramname">argv</td><td>pointer to array of strings for storing command line args </td></tr>
    <tr><td class="paramname">filter</td><td>remove any runtime command line arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5b676fe6ae1a35b50ba0c1bd649428b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::intersect_index_spaces </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space by intersecting several existing index spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">spaces</td><td>the index spaces to intersect </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="a36af197f72cc33ba83d0ada197002bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::is_index_partition_complete </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a given index partition is complete </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>index partition handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the index partition is complete </dd></dl>

</div>
</div>
<a class="anchor" id="a2d5acf558aa75f074a816c9e897a9777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::is_index_partition_disjoint </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a given index partition is disjoint </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>index partition handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the index partition is disjoint </dd></dl>

</div>
</div>
<a class="anchor" id="a9d7065b4e925dd6a6f7402840e7bde2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::is_MPI_interop_configured </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the MPI interop has been established </dd></dl>

</div>
</div>
<a class="anchor" id="a1d1a34f794934fda97473fcbd8de8c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::issue_acquire </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_acquire_launcher.html">AcquireLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an acquire operation on the specified physical region provided by the acquire launcher. This call should be matched by a release call later in the same context on the same physical region. </p>

</div>
</div>
<a class="anchor" id="a44776b6543dac1f165b5148831e341b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::issue_copy_operation </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_copy_launcher.html">CopyLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch a copy operation from the given configuration of the given copy launcher. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_copy_launcher.html">CopyLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>copy launcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a986853cf7b7747c747f664d04e05a4dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::issue_copy_operation </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_index_copy_launcher.html">IndexCopyLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launch an index copy operation from the given configuration of the given copy launcher </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_index_copy_launcher.html">IndexCopyLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>index copy launcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0136c0bb23695eaa3b36fcd3d410208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::issue_execution_fence </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a <a class="el" href="namespace_legion.html">Legion</a> execution fence in the current context. A <a class="el" href="namespace_legion.html">Legion</a> execution fence guarantees that all of the tasks issued in the context prior to the fence will finish running before the tasks after the fence begin to map. This will allow the necessary propagation of <a class="el" href="namespace_legion.html">Legion</a> meta-data such as modifications to the region tree made prior to the fence visible to tasks issued after the fence. </p>

</div>
</div>
<a class="anchor" id="af68392f02f7fa6ccfdb0a5be66b839e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::issue_mapping_fence </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a <a class="el" href="namespace_legion.html">Legion</a> mapping fence in the current context. A <a class="el" href="namespace_legion.html">Legion</a> mapping fence guarantees that all of the tasks issued in the context prior to the fence will finish mapping before the tasks after the fence begin to map. This can be useful as a performance optimization to minimize the number of mapping independence tests required. </p>

</div>
</div>
<a class="anchor" id="aa1ceedaee7b9e3be8cd045b30a98212d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::issue_release </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_release_launcher.html">ReleaseLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a release operation on the specified physical region provided by the release launcher. This call should be preceded by an acquire call earlier in teh same context on the same physical region. </p>

</div>
</div>
<a class="anchor" id="aa08079d49f5ca63e3254864c3c91827b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::issue_timing_measurement </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_timing_launcher.html">TimingLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a timing measurement operation configured with a launcher. The above methods are just common special cases. This allows for the general case of an arbitrary measurement with an arbitrary number of preconditions. </p>

</div>
</div>
<a class="anchor" id="a97b45946044f7672c734111a4960d4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::launch_top_level_task </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_launcher.html">TaskLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After the runtime is started, users can launch as many top-level tasks as they want using this method. Each one will start a new top-level task and returns values with a future. Currently we only permit this to be called from threads not managed by <a class="el" href="namespace_legion.html">Legion</a>. </p>

</div>
</div>
<a class="anchor" id="ab89f0d1e1c5051981e85dda090ee3141"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::legion_task_postamble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>retvalptr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>retvalsize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owned</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Realm::RegionInstance&#160;</td>
          <td class="paramname"><em>inst</em> = <code>Realm::RegionInstance::NO_INST</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the necessary postamble call to use when registering a task variant with an explicit CodeDescriptor. It passes back the task return value and completes the task. It should be the last thing called before the task finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runtime</td><td>the runtime pointer </td></tr>
    <tr><td class="paramname">ctx</td><td>the context for the task </td></tr>
    <tr><td class="paramname">retvalptr</td><td>pointer to the return value </td></tr>
    <tr><td class="paramname">retvalsize</td><td>the size of the return value in bytes </td></tr>
    <tr><td class="paramname">owned</td><td>whether the runtime now owns this result </td></tr>
    <tr><td class="paramname">inst</td><td>optional Realm instance containing the data that <a class="el" href="namespace_legion.html">Legion</a> should take ownership of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a475a28e7ac108578586f5038eb4e8b09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::legion_task_postamble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>runtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_future_functor.html">FutureFunctor</a> *&#160;</td>
          <td class="paramname"><em>callback_functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>owned</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variant of the <a class="el" href="namespace_legion.html">Legion</a> task postamble allows users to pass in a future functor object to serve as a callback interface for <a class="el" href="namespace_legion.html">Legion</a> to query so that it is only invoked in the case where futures actually need to be serialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runtime</td><td>the runtime pointer </td></tr>
    <tr><td class="paramname">ctx</td><td>the context for the task </td></tr>
    <tr><td class="paramname">callback_functor</td><td>pointer to the callback object </td></tr>
    <tr><td class="paramname">owned</td><td>whether <a class="el" href="namespace_legion.html">Legion</a> should take ownership of the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75cae296df9a998053907a268f907c9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::legion_task_preamble </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_task.html">Task</a> *&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> &gt; *&amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&amp;&#160;</td>
          <td class="paramname"><em>runtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the necessary preamble call to use when registering a task variant with an explicit CodeDescriptor. It takes the base Realm task arguments and will return the equivalent <a class="el" href="namespace_legion.html">Legion</a> task arguments from the runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the Realm task data </td></tr>
    <tr><td class="paramname">datalen</td><td>size of the Realm task data in bytes </td></tr>
    <tr><td class="paramname">p</td><td>Realm processor on which the task is running </td></tr>
    <tr><td class="paramname">task</td><td>reference to the <a class="el" href="class_legion_1_1_task.html">Task</a> pointer to be set </td></tr>
    <tr><td class="paramname">regionsptr</td><td>pointer to the vector of regions reference to set </td></tr>
    <tr><td class="paramname">ctx</td><td>the context to set </td></tr>
    <tr><td class="paramname">runtime</td><td>the runtime pointer to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfd9a2972ac9b068d579ac15379d72f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShardID Legion::Runtime::local_shard </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ShardID for the execution of this task in a control-replicated context. If the task is not control replicated then the ShardID will always be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ShardID for this execution of the task </dd></dl>

</div>
</div>
<a class="anchor" id="a71eda2e1e351ddb779295fd6d6313edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::log_once </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Realm::LoggerMessage &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the logger message exactly once regardless of the control replication status of the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">message</td><td>the Realm Logger Message to be logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72a56d287882bf9d1b937dd9a909b409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::map_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_inline_launcher.html">InlineLauncher</a> &amp;&#160;</td>
          <td class="paramname"><em>launcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an inline mapping operation from the given inline operation configuration. Note the application must wait for the resulting physical region to become valid before using it. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_legion_1_1_inline_launcher.html">InlineLauncher</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">launcher</td><td>inline launcher object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a physical region for the resulting data </dd></dl>

</div>
</div>
<a class="anchor" id="a86b8d2c9bdf3f2cd0bd0402461b383e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::map_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_region_requirement.html">RegionRequirement</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an inline mapping operation which returns a physical region object for the requested region requirement. Note the application must wait for the resulting physical region to become valid before using it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">req</td><td>the region requirement for the inline mapping </td></tr>
    <tr><td class="paramname">id</td><td>the mapper ID to associate with the operation </td></tr>
    <tr><td class="paramname">tag</td><td>the mapping tag to pass to any mapping calls </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a physical region for the resulting data </dd></dl>

</div>
</div>
<a class="anchor" id="a35289dab953525dd68eb1a872ba19611"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a> Legion::Runtime::map_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform an inline mapping operation that re-maps a physical region that was initially mapped when the task began. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">idx</td><td>index of the region requirement from the enclosing task </td></tr>
    <tr><td class="paramname">id</td><td>the mapper ID to associate with the operation </td></tr>
    <tr><td class="paramname">the</td><td>mapping tag to pass to any mapping calls </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a physical region for the resulting data </dd></dl>

</div>
</div>
<a class="anchor" id="ac9b2f41e39bff2e64956d40ab1732477"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::perform_registration_callback </td>
          <td>(</td>
          <td class="paramtype">RegistrationCallbackFnptr&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deduplicate</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dedup_tag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call allows applications to request a registration callback be performed after the runtime has started. The application can select whether this registration is performed locally (e.g. once on the local node) or globally across all nodes in the machine. The method will not return until the registration has been performed on all the target address spaces. All function pointers passed into this method with 'global' set to true must "portable", meaning that we can lookup their shared object name and symbol name. This means they either need to originate with a shared object or the binary must be linked with '-rdynamic'. It's up the user to guarantee this or <a class="el" href="namespace_legion.html">Legion</a> will raise an error about a non-portable function pointer. For any given function pointer all calls must be made with the same value of 'global' or hangs can occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">global</td><td>whether this registration needs to be performed in all address spaces or just the local one </td></tr>
    <tr><td class="paramname">buffer</td><td>optional buffer of data to pass to callback </td></tr>
    <tr><td class="paramname">dedup</td><td>whether to deduplicate this with other registration callbacks for the same function </td></tr>
    <tr><td class="paramname">dedup_tag</td><td>a tag to use for deduplication in the case where applications may want to deduplicate across multiple callbacks with the same function pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00aac64c5c44fb580598a8c1a4bea175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a> Legion::Runtime::predicate_and </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new predicate value that is the logical conjunction of two other predicate values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p1</td><td>first predicate to logically and </td></tr>
    <tr><td class="paramname">p2</td><td>second predicate to logically and </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>predicate value logically and-ing two predicates </dd></dl>

</div>
</div>
<a class="anchor" id="a36140f9ce5045dfa588d11fe5835026f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a> Legion::Runtime::predicate_not </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new predicate value that is the logical negation of another predicate value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p</td><td>predicate value to logically negate </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>predicate value logically negating previous predicate </dd></dl>

</div>
</div>
<a class="anchor" id="aba44e7bfcbc9f7dbf78fd3865fcc8122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_predicate.html">Predicate</a> Legion::Runtime::predicate_or </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new predicate value that is the logical disjunction of two other predicate values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">p1</td><td>first predicate to logically or </td></tr>
    <tr><td class="paramname">p2</td><td>second predicate to logically or </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>predicate value logically or-ing two predicates </dd></dl>

</div>
</div>
<a class="anchor" id="a83a125ab374f0985728589368ee8faf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LayoutConstraintID Legion::Runtime::preregister_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_layout_constraint_registrar.html">LayoutConstraintRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayoutConstraintID&#160;</td>
          <td class="paramname"><em>layout_id</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static version of the method above to register layout descriptions prior to the runtime starting. Attempting to use this method after the runtime starts will result in a failure. All of the calls to this method must specifiy layout descriptions that are not associated with a field space. This call must be made symmetrically across all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>a layout description registrar </td></tr>
    <tr><td class="paramname">layout_id</td><td>the ID to associate with the description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the layout id assigned to the set of constraints </dd></dl>

</div>
</div>
<a class="anchor" id="aa7deb7e4e59ec0254a042e485370ab32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::preregister_projection_functor </td>
          <td>(</td>
          <td class="paramtype">ProjectionID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a projection functor before the runtime has started only. The runtime will update the projection functor so that it has contains a valid runtime pointer prior to the projection functor ever being invoked. The runtime takes ownership for deleting the projection functor after the application has finished executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>the projection ID to use for the registration </td></tr>
    <tr><td class="paramname">functor</td><td>the objecto register for handling projections </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af960d0cdd23cb7dd8e535920f5073095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::preregister_sharding_functor </td>
          <td>(</td>
          <td class="paramtype">ShardingID&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_sharding_functor.html">ShardingFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a sharding functor before the runtime has started only. The sharding functor will be invoked to handle queries during control replication about which shard owns a given point in an index space launch. </p>

</div>
</div>
<a class="anchor" id="a8d1742215df90e10e12bfe71d76a5171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VariantID Legion::Runtime::preregister_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically register a new task variant with the runtime with a non-void return type prior to the runtime starting. This call must be made on all nodes and it will fail if done after the <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> method has been invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">task_name</td><td>an optional name to assign to the logical task </td></tr>
    <tr><td class="paramname">vid</td><td>optional static variant ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a0912d5b41b1060fdb2fa0b17fffbcafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VariantID Legion::Runtime::preregister_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically register a new task variant with the runtime with a non-void return type and userd data prior to the runtime starting. This call must be made on all nodes and it will fail if done after the <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> method has been invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">user_data</td><td>the user data to associate with the task variant </td></tr>
    <tr><td class="paramname">task_name</td><td>an optional name to assign to the logical task </td></tr>
    <tr><td class="paramname">vid</td><td>optional static variant ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a5e85dd4405daabc5eb4ebf3621763eb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VariantID Legion::Runtime::preregister_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically register a new task variant with the runtime with a void return type prior to the runtime starting. This call must be made on all nodes and it will fail if done after the <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> method has been invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">an</td><td>optional name to assign to the logical task </td></tr>
    <tr><td class="paramname">vid</td><td>optional static variant ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="abf7a3743c8dc7d4e777d44c964c35344"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VariantID Legion::Runtime::preregister_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically register a new task variant with the runtime with a void return type and user data prior to the runtime starting. This call must be made on all nodes and it will fail if done after the <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> method has been invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">user_data</td><td>the user data to associate with the task variant </td></tr>
    <tr><td class="paramname">an</td><td>optional name to assign to the logical task </td></tr>
    <tr><td class="paramname">vid</td><td>optional static variant ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a41ffe9b3f048f6606a0435271a134e29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static VariantID Legion::Runtime::preregister_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CodeDescriptor &amp;&#160;</td>
          <td class="paramname"><em>codedesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>user_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>return_type_size</em> = <code>LEGION_MAX_RETURN_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_task_id</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statically register a new task variant with the runtime that has already built in the necessary preamble/postamble (i.e. calls to LegionTaskWrapper::legion_task_{pre,post}amble). This call must be made on all nodes and it will fail if done after the <a class="el" href="class_legion_1_1_runtime.html#a7ef2a69a34d383ea70f8630023c29015">Runtime::start</a> method has been invoked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">codedesc</td><td>the code descriptor for the pre-wrapped task </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data to associate with the task variant </td></tr>
    <tr><td class="paramname">user_len</td><td>size of optional user_data in bytes </td></tr>
    <tr><td class="paramname">has_return_type</td><td>boolean indicating a non-void return type </td></tr>
    <tr><td class="paramname">check_task_id</td><td>verify validity of the task ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a22c83c4c48550b75c3c0676bed306de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::print_once </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the string to the given C file (may also be stdout/stderr) exactly once regardless of the replication status of the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">file</td><td>the file to be written to </td></tr>
    <tr><td class="paramname">message</td><td>pointer to the C string to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af81aaaf17046eba245b86c345dbb0e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::progress_unordered_operations </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force progress on unordered operations. After performing one of these calls then all outstanding unordered operations that have been issued are guaranteed to be in the task stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae436d1051bfac794d153ea776aca9f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::raise_region_exception </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nuclear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate that data in a particular physical region appears to be incorrect for whatever reason. This will cause the runtime to trap into an error handler and may result in the task being re-executed if the fault is determined to be recoverable. Control will never return from this call. The application can also indicate whether it believes that this particular instance is invalid (nuclear=false) or whether it believes that all instances contain invalid data (nuclear=true). If all instances are bad the runtime will nuke all copies of the data and restart the tasks necessary to generate them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>physical region which contains bad data </td></tr>
    <tr><td class="paramname">nuclear</td><td>whether the single instance is invalid or all are </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cc6d21a6ae61814eecd74bf6fdf17bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::reduce_future_map </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_legion_1_1_future_map.html">FutureMap</a> &amp;&#160;</td>
          <td class="paramname"><em>future_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce a future map down to a single future value using a specified reduction operator. This assumes that all the values in the future map are instance of the reduction operator's RHS type and the resulting future will also be an RHS type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">future_map</td><td>the future map to reduct the value </td></tr>
    <tr><td class="paramname">redop</td><td>ID for the reduction op to use for reducing values </td></tr>
    <tr><td class="paramname">deterministic</td><td>request that the reduced future be computed in a deterministic way (more expensive than non-deterministic) </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string for describing the provenance of this invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future result representing the the reduction of all the values in the future map </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd6b9cee8ae1eb9f8ed7a96dede81d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SERDEZ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::register_custom_serdez_op </td>
          <td>(</td>
          <td class="paramtype">CustomSerdezID&#160;</td>
          <td class="paramname"><em>serdez_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register custom serialize/deserialize operation with the runtime. This can be used for providing custom serialization and deserialization method for fields that are not trivially copied (e.g. byte-wise copies). The type being registered must conform to the Realm definition of a CustomSerdez object (see realm/custom_serdez.h). Note that eventhough this is a static method you can safely call it both before and after the runtime has been started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serdez_id</td><td>ID at which to register the serdez operator </td></tr>
    <tr><td class="paramname">permit_duplicates</td><td>will allow a duplicate registration to be successful if this serdez ID has been used before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa50d6273d77001d62c47a32eaaac3819"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::register_custom_serdez_op </td>
          <td>(</td>
          <td class="paramtype">CustomSerdezID&#160;</td>
          <td class="paramname"><em>serdez_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerdezOp *&#160;</td>
          <td class="paramname"><em>serdez_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register custom serialize/deserialize operation with the runtime. This can be used for providing custom serialization and deserialization method for fields that are not trivially copied (e.g. byte-wise copies). Note that eventhough this is a static method you can safely call it both before and after the runtime has been started. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serdez_id</td><td>ID at which to register the serdez operator </td></tr>
    <tr><td class="paramname">serdez_op</td><td>The functor for the serdez op </td></tr>
    <tr><td class="paramname">permit_duplicates</td><td>will allow a duplicate registration to be successful if this serdez ID has been used before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc6acec0e7ede9fd3e052b3c3e2df6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LayoutConstraintID Legion::Runtime::register_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_layout_constraint_registrar.html">LayoutConstraintRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a new layout description with the runtime. The runtime will return an ID that is a globally unique name for this set of constraints and can be used anywhere in the machine. Once this set of constraints is set, it cannot be changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>a layout description registrar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unique layout ID assigned to this set of constraints </dd></dl>

</div>
</div>
<a class="anchor" id="a6d51b64f40ce794ff98b1403994c11f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskID Legion::Runtime::register_legion_task </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor::Kind&#160;</td>
          <td class="paramname"><em>proc_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Register a task with a template return type for the given kind of processor. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID to assign to the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7ed2e245248488919540ac601250098e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskID Legion::Runtime::register_legion_task </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor::Kind&#160;</td>
          <td class="paramname"><em>proc_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Register a task with a void return type for the given kind of processor. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID to assign to the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="abc41657d63ef3c5587288a5fdba376e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskID Legion::Runtime::register_legion_task </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor::Kind&#160;</td>
          <td class="paramname"><em>proc_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Same as the register_legion_task above, but allow for users to pass some static data that will be passed as an argument to all invocations of the function. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID at which to assign the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">user_data</td><td>user data type to pass to all invocations of the task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a48ccafce990902cc501cd4ca2f160914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskID Legion::Runtime::register_legion_task </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor::Kind&#160;</td>
          <td class="paramname"><em>proc_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="struct_legion_1_1_task_config_options.html">TaskConfigOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>task_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Same as the register_legion_task above, but allow for users to pass some static data that will be passed as an argument to all invocations of the function. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID at which to assign the task </td></tr>
    <tr><td class="paramname">proc_kind</td><td>the processor kind on which the task can run </td></tr>
    <tr><td class="paramname">single</td><td>whether the task can be run as a single task </td></tr>
    <tr><td class="paramname">index</td><td>whether the task can be run as an index space task </td></tr>
    <tr><td class="paramname">user_data</td><td>user data type to pass to all invocations of the task </td></tr>
    <tr><td class="paramname">vid</td><td>the variant ID to assign to the task </td></tr>
    <tr><td class="paramname">options</td><td>the task configuration options </td></tr>
    <tr><td class="paramname">task_name</td><td>string name for the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID the task was assigned </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa01797f8368215038e3ace3a5e84a277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LogicalRegion(*)(LogicalPartition, const DomainPoint &amp;, Runtime *) PROJ_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ProjectionID Legion::Runtime::register_partition_function </td>
          <td>(</td>
          <td class="paramtype">ProjectionID&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Register a partition projection function that can be used to map from an upper bound of a logical partition down to a specific logical sub-region for a given domain point during index task execution. The projection ID zero is reserved for runtime use. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the projection ID to register the function at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID where the function was registered </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="aed570eb66ecffb1772de58c122d521dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::register_projection_functor </td>
          <td>(</td>
          <td class="paramtype">ProjectionID&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_projection_functor.html">ProjectionFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a projection functor for handling projection queries. The ProjectionID must be non-zero because zero is the identity projection. Unlike mappers which require a separate instance per processor, only one of these must be registered per projection ID. The runtime takes ownership for deleting the projection functor after the application has finished executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>the projection ID to use for the registration </td></tr>
    <tr><td class="paramname">functor</td><td>the object to register for handling projections </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>disable warnings about dynamic registration </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with any warnings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e8b66a348ea56e232301cfcfb20338e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename REDOP &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::register_reduction_op </td>
          <td>(</td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a reduction operation with the runtime. Note that the reduction operation template type must conform to the specification for a reduction operation outlined in the Realm runtime interface. Reduction operations can be used either for reduction privileges on a region or for performing reduction of values across index space task launches. The reduction operation ID zero is reserved for runtime use. Note that even though this method is a static method it can be called either before or after the runtime has been started safely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">redop_id</td><td>ID at which to register the reduction operation </td></tr>
    <tr><td class="paramname">permit_duplicates</td><td>will allow a duplicate registration to be successful if this reduction ID has been used before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac29dc50bf483aeca0b4bae5fc45e28f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::register_reduction_op </td>
          <td>(</td>
          <td class="paramtype">ReductionOpID&#160;</td>
          <td class="paramname"><em>redop_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReductionOp *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerdezInitFnptr&#160;</td>
          <td class="paramname"><em>init_fnptr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerdezFoldFnptr&#160;</td>
          <td class="paramname"><em>fold_fnptr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register an untyped reduction operation with the runtime. Note that the reduction operation template type must conform to the specification for a reduction operation outlined in the Realm runtime interface. Reduction operations can be used either for reduction privileges on a region or for performing reduction of values across index space task launches. The reduction operation ID zero is reserved for runtime use. The runtime will take ownership of this operation and delete it at the end of the program. Note that eventhough this is a static method it can be called either before or after the runtime has been started safely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">redop_id</td><td>ID at which to register the reduction opeation </td></tr>
    <tr><td class="paramname">op</td><td>the untyped reduction operator (legion claims ownership) </td></tr>
    <tr><td class="paramname">init_fnptr</td><td>optional function for initializing the reduction type of this reduction operator if they also support compression  fold_fnptr optional function for folding reduction types of this reduction operator if they also support compression </td></tr>
    <tr><td class="paramname">permit_duplicates</td><td>will allow a duplicate registration to be successful if this reduction ID has been used before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a152e69794766a5565eec12eefca80c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LogicalRegion(*)(LogicalRegion, const DomainPoint &amp;, Runtime *) PROJ_PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ProjectionID Legion::Runtime::register_region_function </td>
          <td>(</td>
          <td class="paramtype">ProjectionID&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Register a region projection function that can be used to map from an upper bound of a logical region down to a specific logical sub-region for a given domain point during index task execution. The projection ID zero is reserved for runtime use. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the projection ID to register the function at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID where the function was registered </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaf4e7851463eecc0773ca7e3b70a7f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::register_sharding_functor </td>
          <td>(</td>
          <td class="paramtype">ShardingID&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_sharding_functor.html">ShardingFunctor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a sharding functor for handling control replication queries about which shard owns which a given point in an index space launch. </p>

</div>
</div>
<a class="anchor" id="a9208ecb02d6fce840202193227fe1250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VariantID Legion::Runtime::register_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a new task variant with the runtime with a non-void return type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">vid</td><td>optional variant ID to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a62da327be82232e97077f207805e01ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename UDT , T(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VariantID Legion::Runtime::register_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a new task variant with the runtime with a non-void return type and user data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">user_data</td><td>the user data to associate with the task variant </td></tr>
    <tr><td class="paramname">vid</td><td>optional variant ID to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a25379d3ea373e9c9e1eeb6c06fbfa8ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *) TASK_PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VariantID Legion::Runtime::register_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a new task variant with the runtime with a void return type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">vid</td><td>optional variant ID to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a5838b3cc5e9ce88b9e37b6790179cc1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UDT , void(*)(const Task *, const std::vector&lt; PhysicalRegion &gt; &amp;, Context, Runtime *, const UDT &amp;) TASK_PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VariantID Legion::Runtime::register_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UDT &amp;&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a new task variant with the runtime with a void return type and user data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">user_data</td><td>the user data to associate with the task variant </td></tr>
    <tr><td class="paramname">vid</td><td>optional variant ID to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a4de4e1d191026fd2d0af78a6495e4d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariantID Legion::Runtime::register_task_variant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_legion_1_1_task_variant_registrar.html">TaskVariantRegistrar</a> &amp;&#160;</td>
          <td class="paramname"><em>registrar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CodeDescriptor &amp;&#160;</td>
          <td class="paramname"><em>codedesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>user_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>return_type_size</em> = <code>LEGION_MAX_RETURN_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantID&#160;</td>
          <td class="paramname"><em>vid</em> = <code>LEGION_AUTO_GENERATE_ID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a new task variant with the runtime that has already built in the necessary preamble/postamble (i.e. calls to LegionTaskWrapper::legion_task_{pre,post}amble) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrar</td><td>the task variant registrar for describing the task </td></tr>
    <tr><td class="paramname">codedesc</td><td>the code descriptor for the pre-wrapped task </td></tr>
    <tr><td class="paramname">user_data</td><td>pointer to optional user data to associate with the task variant </td></tr>
    <tr><td class="paramname">user_len</td><td>size of optional user_data in bytes </td></tr>
    <tr><td class="paramname">has_return_type</td><td>boolean if this has a non-void return type </td></tr>
    <tr><td class="paramname">vid</td><td>optional variant ID to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variant ID for the task </dd></dl>

</div>
</div>
<a class="anchor" id="a25c37ef0a98db690f4933457eeaa853e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::release_grant </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_grant.html">Grant</a>&#160;</td>
          <td class="paramname"><em>grant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_release.html">Release</a> the grant object indicating that no more operations will be launched that require the grant object. Once this is done and all the tasks using the grant complete the runtime can release the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">grant</td><td>the grant object to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae495979ba6641b365c2c0b9ee4be7818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::release_layout </td>
          <td>(</td>
          <td class="paramtype">LayoutConstraintID&#160;</td>
          <td class="paramname"><em>layout_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_legion_1_1_release.html">Release</a> the set of constraints associated the given layout ID. This promises that this set of constraints will never be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout_id</td><td>the name for the set of constraints to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac1c0ab14c57618b4e4fd317a0b8862b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::remap_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remap a region from an existing physical region. It will still be necessary for the application to wait until the physical region is valid again before using it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>the physical region to be remapped </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c7d346beb15757301ecd5bc51395361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::replace_default_mapper </td>
          <td>(</td>
          <td class="paramtype">Mapping::Mapper *&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Processor&#160;</td>
          <td class="paramname"><em>proc</em> = <code>Processor::NO_PROC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the default mapper for a given processor with a new mapper. If a specific processor is passed to the call then the mapper instance will only be registered on that processor. Alternatively, if no processor is passed, then the mapper will be registered with all processors on the local node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapper</td><td>pointer to the mapper object to use as the new default mapper </td></tr>
    <tr><td class="paramname">proc</td><td>the processor to associate the mapper with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb0cd42dd4eace605fd30e31ece8b7ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a task </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_id</td><td>the ID of the task </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebd3b1f63106adf00cb07e08aae3cbaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of an index space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64c2f0223794f00eed6fab2c5540a499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of an index partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84bbc60633b79321905756d0bb9f20c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a field space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb2b11b863cf5b95223cf699decf55f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a specific field </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">fid</td><td>field ID </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cf9724b6f03af6cd266cb1639fedf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical region handle </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc8f912fbbb69931f7739916db546578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::retrieve_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the name of a logical partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical partition handle </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83a16b950fc9fb7893ca5b5dfc001e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>task_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for a task </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_id</td><td>the ID of the task </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="a0e5fdb8686a7fe4743d84d2c7a6578db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for an index space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index space handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="aa95b639e7a140d4606a39492b3dd4455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_partition.html">IndexPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for an index partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>index partition handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="a4714cba71c744df963874d0792b2a761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for a field space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="a81722db7ba91b62757143a293471ceb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_field_space.html">FieldSpace</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldID&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for a specific field </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>field space handle </td></tr>
    <tr><td class="paramname">fid</td><td>field ID </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="a725a2e5b711bfdb47c64be8dfbd2909e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for a logical region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical region handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="abc4ff9033f16cf0ec6c3fd2e3c8ba631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::retrieve_semantic_information </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_partition.html">LogicalPartition</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemanticTag&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>can_fail</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_ready</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve semantic information for a logical partition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>logical partition handle </td></tr>
    <tr><td class="paramname">tag</td><td>semantic tag </td></tr>
    <tr><td class="paramname">result</td><td>pointer to assign to the semantic buffer </td></tr>
    <tr><td class="paramname">size</td><td>where to write the size of the semantic buffer </td></tr>
    <tr><td class="paramname">can_fail</td><td>query allowed to fail </td></tr>
    <tr><td class="paramname">wait_until_ready</td><td>wait indefinitely for the tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the query succeeds </dd></dl>

</div>
</div>
<a class="anchor" id="a103e10f383ee4ec5d3f04ffcc4cc6ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_t Legion::Runtime::safe_cast </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_t&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safe cast a pointer down to a target region. If the pointer is not in the target region, then a nil pointer is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">pointer</td><td>the pointer to be case </td></tr>
    <tr><td class="paramname">region</td><td>the target logical region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same pointer if it can be safely cast, otherwise nil </dd></dl>

</div>
</div>
<a class="anchor" id="a9158340668c0d8becc481ca648cc9782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a> Legion::Runtime::safe_cast </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_domain_point.html">DomainPoint</a>&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region.html">LogicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safe case a domain point down to a target region. If the point is not in the target region, then an empty domain point is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">point</td><td>the domain point to be cast </td></tr>
    <tr><td class="paramname">region</td><td>the target logical region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same point if it can be safely cast, otherwise empty </dd></dl>

</div>
</div>
<a class="anchor" id="a4184bff14eff459b500fc356da61a63c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, typename COORD_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Runtime::safe_cast </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&lt; DIM, COORD_T &gt;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_logical_region_t.html">LogicalRegionT</a>&lt; DIM, COORD_T &gt;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safe case a domain point down to a target region. If the point is not in the target region, returns false, otherwise returns true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">point</td><td>the domain point to be cast </td></tr>
    <tr><td class="paramname">region</td><td>the target logical region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the point is in the logical region </dd></dl>

</div>
</div>
<a class="anchor" id="a63c1d9bbfcccc42d178f51ff2da2da94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Runtime::select_tunable_value </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TunableID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>mapper</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MappingTagID&#160;</td>
          <td class="paramname"><em>tag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>args</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>argsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="namespace_legion.html">Legion</a>'s ancestral predecessor Sequoia, <a class="el" href="namespace_legion.html">Legion</a> supports tunable variables which are integers supplied by the mapper for individual task contexts. The idea is that there are some parameters which should be considered parameters determined by the underlying hardware. To make these parameters explicit, we express them as tunables which are filled in at runtime by mapper objects. This method will return asynchronously with a future that will be set once the mapper fills in the value for the future. It is the responsibility of the application to maintain consistency on the expected types for a given tunable between the application and the mapper. </p>

</div>
</div>
<a class="anchor" id="adb95bedd55d53c83b9117f4ac31dca09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::set_local_task_variable_untyped </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LocalVariableID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>destructor</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value of a task-local variable named by ID. This variable will only have the lifetime of the task. The user can also specify an optional destructor function which will implicitly be called at the end the task's execution </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">id</td><td>the ID of the task-local variable to set </td></tr>
    <tr><td class="paramname">value</td><td>the value to set the variable to </td></tr>
    <tr><td class="paramname">destructor</td><td>optional method to delete the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ae93947622a78e885a5a8b36811bb79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::set_registration_callback </td>
          <td>(</td>
          <td class="paramtype">RegistrationCallbackFnptr&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>This call allows the application to register a callback function that will be run prior to beginning any task execution on every runtime in the system. It can be used to register or update the mapping between mapper IDs and mappers, register reductions, register projection function, register coloring functions, or configure any other static runtime variables prior to beginning the application. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>function pointer to the callback function to be run </td></tr>
  </table>
  </dd>
</dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a524e0c687da51d111c209e98e4aeb97c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::set_return_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>return_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the return code for the application from <a class="el" href="namespace_legion.html">Legion</a>. This will be returned as the result from 'start' or 'wait_for_shutdown'. The default is zero. If multiple non-zero values are set then at least one of the non-zero values will be returned. </p>

</div>
</div>
<a class="anchor" id="a63bc41e96b5b10f3435b15ef6d5f090b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::set_top_level_task_id </td>
          <td>(</td>
          <td class="paramtype">TaskID&#160;</td>
          <td class="paramname"><em>top_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the top-level task ID for the runtime to use when beginning an application. This should be set before calling start. If no top-level task ID is set then the runtime will not start running any tasks at start-up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_id</td><td>ID of the top level task to be run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa64b2a328c162ba26386019fffc5dc21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Legion::Runtime::set_top_level_task_mapper_id </td>
          <td>(</td>
          <td class="paramtype">MapperID&#160;</td>
          <td class="paramname"><em>mapper_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mapper ID for the runtime to use when starting the top-level task. This can be called either before the runtime is started, or during the registration callback, but will have no effect after the top-level task is started. </p>

</div>
</div>
<a class="anchor" id="a7ef2a69a34d383ea70f8630023c29015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Legion::Runtime::start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>background</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supply_default_mapper</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After configuring the runtime object this method should be called to start the runtime running. The runtime will then launch the specified top-level task on one of the processors in the machine. Note if background is set to false, control will never return from this call. An integer is returned since this is routinely the last call at the end of 'main' in a program and it is nice to return an integer from 'main' to satisfy compiler type checkers.</p>
<p>In addition to the arguments passed to the application, there are also several flags that can be passed to the runtime to control execution. </p>
<hr/>
 <h2>Stealing </h2>
<p>-lg:nosteal Disable any stealing in the runtime. The runtime </p>
<h2>will never query any mapper about stealing. </h2>
<h2>Out-of-order Execution </h2>
<p>-lg:window &lt;int&gt; Specify the maximum number of child tasks allowed in a given task context at a time. A call to launch more tasks than the allotted window will stall the parent task until child tasks begin completing. The default is 1024. -lg:sched &lt;int&gt; The run-ahead factor for the runtime. How many outstanding tasks ready to run should be on each processor before backing off the mapping procedure. -lg:vector &lt;int&gt; Set the initial vectorization option for fusing together important runtime meta tasks in the mapper. The default is 16. -lg:inorder Execute operations in strict propgram order. This flag will actually run the entire operation through the pipeline and wait for it to complete before </p>
<h2>permitting the next operation to start. </h2>
<h2>Messaging </h2>
<p>-lg:message &lt;int&gt; Maximum size in bytes of the active messages to be sent between instances of the <a class="el" href="namespace_legion.html">Legion</a> runtime. This can help avoid the use of expensive per-pair-of-node RDMA buffers in the low-level runtime. Default value is 4K which should guarantee </p>
<h2>medium sized active messages on Infiniband clusters. </h2>
<h2>Configuration Flags </h2>
<p>-lg:no_dyn Disable dynamic disjointness tests when the runtime has been compiled with macro DYNAMIC_TESTS defined which enables dynamic disjointness testing. -lg:epoch &lt;int&gt; Change the size of garbage collection epochs. The default value is 64. Increasing it adds latency to the garbage collection but makes it more efficient. Decreasing the value reduces latency, but adds inefficiency to the collection. -lg:unsafe_launch Tell the runtime to skip any checks for checking for deadlock between a parent task and the sub-operations that it is launching. Note that this is unsafe for a reason. The application can and will deadlock if any currently mapped regions conflict with those requested by a child task or other operation. -lg:unsafe_mapper Tell the runtime to skip any checks for validating the correctness of the results from mapper calls. Turning this off may result in internal crashes in the runtime if the mapper provides invalid output from any mapper call. (Default: false in debug mode, true in release mode.) -lg:safe_mapper Tell the runtime to perform all correctness checks on mapper calls regardless of the optimization level. (Default: true in debug mode, false in release mode.) -lg:local &lt;int&gt; Specify the maximum number of local fields </p>
<h2>permitted in any field space within a context. </h2>
<h2>Resiliency </h2>
<p>-lg:resilient Enable features that make the runtime resilient including deferred commit that can be controlled by the next two flags. By default this is off for performance reasons. Once resiliency mode is enabled, then the user can control when </p>
<h2>operations commit using the next two flags. </h2>
<h2>Debugging </h2>
<p>-lg:warn Enable all verbose runtime warnings -lg:warn_backtrace Print a backtrace for each warning -lg:leaks Report information about resource leaks -lg:ldb &lt;replay_file&gt; Replay the execution of the application with the associated replay file generted by LegionSpy. This will run the application in the <a class="el" href="namespace_legion.html">Legion</a> debugger. -lg:replay &lt;replay_file&gt; Rerun the execution of the application with the associated replay file generated by LegionSpy. -lg:tree Dump intermediate physical region tree states before and after every operation. The runtime must be compiled in debug mode with the DEBUG_LEGION macro defined. -lg:disjointness Verify the specified disjointness of partitioning operations. This flag is now a synonym for -lg:partcheck -lg:partcheck This flag will ask the runtime to dynamically verify that all correctness properties for partitions are upheld. This includes checking that the parent region dominates all subregions and that all annotations of disjointness and completeness from the user are correct. This is an expensive test and users should expect a significant slow-down of their application when using it. -lg:separate Indicate that separate instances of the <a class="el" href="namespace_legion.html">Legion</a> level runtime should be made for each processor. The default is one runtime instance per node. This is primarily useful for debugging purposes to force messages to be sent between runtime instances on the same node. -lg:registration Record the mapping from Realm task IDs to task variant names for debugging Realm runtime error messages. -lg:test Replace the default mapper with the test mapper which will generate sound but random mapping decision in order to stress-test the runtime. -lg:delay &lt;sec&gt; Delay the start of the runtime by 'sec' seconds. This is often useful for attaching debuggers on </p>
<h2>one or more nodes prior to an application beginning. </h2>
<h2>Profiling </h2>
<p>-lg:spy Enable light-weight logging for <a class="el" href="namespace_legion.html">Legion</a> Spy which is valuable for understanding properties of an application such as the shapes of region trees and the kinds of tasks/operations that are created. Checking of the runtime with <a class="el" href="namespace_legion.html">Legion</a> Spy will still require the runtime to be compiled with -DLEGION_SPY. -lg:prof &lt;int&gt; Specify the number of nodes on which to enable profiling information to be collected. By default all nodes are disabled. Zero will disable all profiling while each number greater than zero will profile on that number of nodes. -lg:serializer &lt;string&gt; Specify the kind of serializer to use: 'ascii' or 'binary'. The default is 'binary'. -lg:prof_logfile &lt;filename&gt; If using a binary serializer the name of the output file to write to. -lg:prof_footprint &lt;int&gt; The maximum goal size of <a class="el" href="namespace_legion.html">Legion</a> Prof footprint during runtime in MBs. If the total data captured by the profiler exceeds this footprint, the runtime will begin dumping data out to the output file in a minimally invasive way while the application is still running. The default is 512 (MB). -lg:prof_latency &lt;int&gt; The goal latency in microseconds of intermediate profiling tasks to be writing to output files if the maximum footprint size is exceeded. This allows control over the granularity so they can be made small enough to interleave with other runtime work. The default is 100 (us).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>the number of input arguments </td></tr>
    <tr><td class="paramname">argv</td><td>pointer to an array of string arguments of size argc </td></tr>
    <tr><td class="paramname">background</td><td>whether to execute the runtime in the background </td></tr>
    <tr><td class="paramname">supply_default_mapper</td><td>whether the runtime should initialize the default mapper for use by the application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>only if running in background, otherwise never </dd></dl>

</div>
</div>
<a class="anchor" id="abe24b579ab20fa57baafd450ab116ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::subtract_index_spaces </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space by taking the set difference of two different index spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af322e2707640ed384e51b642ed9e3ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Runtime::total_shards </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of shards for the execution of this task in a control-replicated context. If the task is not control-replicated then the total number of shards will always be one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclosing</td><td>task context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of shards in the execution of the task </dd></dl>

</div>
</div>
<a class="anchor" id="a3c72c6636df75996f3719961fdea4716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::unbind_implicit_task_from_external_thread </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbind an implicit context from the external thread it is currently associated with. It is the user's responsibility to make sure that no more than one external thread is bound to an implicit task's context at a time or undefined behavior will occur. </p>

</div>
</div>
<a class="anchor" id="a813dde334a85eb30bed007240dac5a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> Legion::Runtime::union_index_spaces </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_legion_1_1_index_space.html">IndexSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provenance</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new top-level index space by unioning together several existing index spaces </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the enclosing task context </td></tr>
    <tr><td class="paramname">spaces</td><td>the index spaces to union together </td></tr>
    <tr><td class="paramname">provenance</td><td>an optional string describing the provenance information for this index space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handle for the new index space </dd></dl>

</div>
</div>
<a class="anchor" id="ab27b33e7667fa68655141d7bdc68965e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::unmap_all_regions </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmap all the regions originally requested for a context (if they haven't already been unmapped). WARNING: this call will invalidate all accessors currently valid in the enclosing parent task context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d36874abe2077cd4ea544a357c336b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::unmap_region </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_physical_region.html">PhysicalRegion</a>&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmap a physical region. This can unmap either a previous inline mapping physical region or a region initially mapped as part of the task's launch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>enclosing task context </td></tr>
    <tr><td class="paramname">region</td><td>physical region to be unmapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c6d29724fa7b7e3679b94b19a20c37c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Legion::Runtime::wait_for_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocking call to wait for the runtime to shutdown when running in background mode. Otherwise it is illegal to invoke this method. Returns the exit code for the application. </p>

</div>
</div>
<a class="anchor" id="ad7ef2dd2dff921f5ad8dd208aac18333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Runtime::yield </td>
          <td>(</td>
          <td class="paramtype">Context&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield the task to allow other tasks on the processor. In most <a class="el" href="namespace_legion.html">Legion</a> programs calling this should never be necessary. However, sometimes an application may want to put its own polling loop inside a task. If it does it may need to yield the processor that it is running on to allow other tasks to run on that processor. This can be accomplished by invoking this method. The task will be pre-empted and other eligible tasks will be permitted to run on this processor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="legion_8h_source.html">legion.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 23 2023 09:06:56 for Legion Runtime by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
