<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Debugging &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Debugging">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/legion-website-test/debugging/index.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/legion-website-test/debugging/index.html">
<link href="/legion-website-test/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/legion-website-test/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/legion-website-test/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/legion-website-test/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="icon" sizes="16x16" href="/legion-website-test/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" href="/legion-website-test/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" href="/legion-website-test/images/favicon/favicon-48x48.png">
<link rel="icon" sizes="96x96" href="/legion-website-test/images/favicon/favicon-96x96.png">
<link rel="icon" sizes="144x144" href="/legion-website-test/images/favicon/favicon-144x144.png">
<link rel="icon" sizes="192x192" href="/legion-website-test/images/favicon/favicon-192x192.png">
<link rel="apple-touch-icon" sizes="57x57" href="/legion-website-test/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/legion-website-test/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/legion-website-test/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/legion-website-test/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/legion-website-test/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/legion-website-test/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/legion-website-test/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/legion-website-test/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/legion-website-test/images/favicon/apple-icon-180x180.png">
<link rel="apple-touch-icon-precomposed" sizes="192x192" href="/legion-website-test/images/favicon/apple-icon-precomposed.png">
<meta name="msapplication-config" content="/legion-website-test/images/favicon/browserconfig.xml" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<link rel="manifest" href="/legion-website-test/images/favicon/manifest.json">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/legion-website-test/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/legion-website-test/overview/" >Overview</a></li>
		        
				<li><a href="/legion-website-test/starting/" >Getting Started</a></li>
		        
				<li><a href="/legion-website-test/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/legion-website-test/events/" >Events</a></li>
		        
				<li><a href="/legion-website-test/documentation/" >Documentation</a></li>
		        
				<li><a href="/legion-website-test/publications/" >Publications</a></li>
		        
				<li><a href="/legion-website-test/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <a href="https://www.stanford.edu/"><img src="/legion-website-test/images/logos/stanford.png" class="bio-photo" alt="Stanford University logo"></a>
<a href="https://www6.slac.stanford.edu/"><img src="/legion-website-test/images/logos/slac.jpg" class="bio-photo" alt="SLAC National Accelerator Laboratory logo"></a>
<a href="https://www.lanl.gov/"><img src="/legion-website-test/images/logos/los-alamos.png" class="bio-photo" alt="Los Alamos National Laboratory logo"></a>
<a href="https://www.nvidia.com/"><img src="/legion-website-test/images/logos/nvidia.png" class="bio-photo" alt="NVIDIA logo"></a>
<a href="https://www.rdworldonline.com/rd-100-award-winners-announced-in-analytical-test-it-electrical-categories/"><img src="/legion-website-test/images/logos/rd100.png" class="bio-photo" alt="Winner of the R&D 100 Award"></a>

<h3>Legion</h3>
<p>High Productivity High Performance Computing</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>



  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Debugging</h1>
    <div class="article-wrap" itemprop="text">
      <p>Legion provides robust support for debugging applications. The tools
below fall into two categories: those intended for debugging
applications, and those for debugging the runtime itself.</p>

<p>Generally speaking, users should start by trying these tools
(typically in this order):</p>

<ul>
  <li><a href="#debug-mode">Debug Mode</a> (<code class="language-plaintext highlighter-rouge">DEBUG=1 make; ./app</code>)</li>
  <li><a href="#backtrace">Backtrace</a> (<code class="language-plaintext highlighter-rouge">LEGION_BACKTRACE=1 ./app</code>)</li>
  <li><a href="#freeze-on-error">Freeze On Error</a> (<code class="language-plaintext highlighter-rouge">LEGION_FREEZE_ON_ERROR=1 ./app</code>)</li>
  <li><a href="#privilege-checks">Privilege Checks</a> (<code class="language-plaintext highlighter-rouge">CC_FLAGS=-DPRIVILEGE_CHECKS make; ./app</code>)</li>
  <li><a href="#bounds-checks">Bounds Checks</a> (<code class="language-plaintext highlighter-rouge">CC_FLAGS=-DBOUNDS_CHECKS make; ./app</code>)</li>
  <li><a href="#partition-checks">Partition Checks</a> (<code class="language-plaintext highlighter-rouge">./app -lg:partcheck</code>)</li>
  <li><a href="#legion-spy">Legion Spy</a> (<code class="language-plaintext highlighter-rouge">./app -lg:spy -logfile spy_%.log; tools/legion_spy.py -dez spy_*.log</code>)</li>
  <li><a href="#mapper-logging-wrapper">Mapper Logging Wrapper</a> (<code class="language-plaintext highlighter-rouge">new LoggingWrapper(...)</code> and <code class="language-plaintext highlighter-rouge">-level mapper=2</code>)</li>
</ul>

<p>The following tools are typically used after the initial debugging
tools have been exhausted or in special circumstances:</p>

<ul>
  <li><a href="#logging-infrastructure">Logging Infrastructure</a></li>
  <li><a href="#debug-tasks">Debug Tasks</a></li>
  <li><a href="#delay-start">Delay Start</a> (<code class="language-plaintext highlighter-rouge">./app -lg:delay N</code> where <code class="language-plaintext highlighter-rouge">N</code> is in seconds)</li>
  <li><a href="#in-order-execution">In-Order Execution</a> (<code class="language-plaintext highlighter-rouge">./app -lg:inorder</code>)</li>
  <li><a href="#full-size-instances">Full-Size Instances</a></li>
  <li><a href="#separate-runtime-instances">Separate Runtime Instances</a> (<code class="language-plaintext highlighter-rouge">./app -lg:separate -ll:util 0</code>)</li>
  <li><a href="#dump-backtraces">Dump Backtraces</a> (<code class="language-plaintext highlighter-rouge">./app -ll:force_kthreads</code>)</li>
  <li><a href="#dump-events">Dump Events</a> (<code class="language-plaintext highlighter-rouge">REALM_SHOW_EVENT_WAITERS=60+5</code>)</li>
  <li><a href="#trace-memory-allocations">Trace Memory Allocations</a> (<code class="language-plaintext highlighter-rouge">CC_FLAGS=-DTRACE_ALLOCATION make; ./app -level allocation=2</code>)</li>
  <li><a href="#legion-gc">Legion GC</a> (<code class="language-plaintext highlighter-rouge">CC_FLAGS=-DLEGION_GC make; ./app -level legion_gc=2 -logfile gc_%.log; tools/legion_gc.py -l gc_*.log</code>)</li>
</ul>

<h2 id="try-these-first">Try These First</h2>

<h3 id="debug-mode">Debug Mode</h3>

<p>For any Legion application that is not exhibiting expected
behavior, the first debugging technique should always be
to compile Legion in debug mode. If the
application is being built using our standard Makefile
infrastructure, this is done simply by setting <code class="language-plaintext highlighter-rouge">DEBUG=1</code> in the environment or
at the top of the application’s Makefile. Compiling the
runtime in debug mode will enable many checks which are
disabled in release mode and may uncover both application
as well as runtime bugs.</p>

<p>A quick note on error messages: we endeavor to provide useful error
messages, but Legion is still an experimental system and there may be
assertions that do not produce useful error messages. If you encounter
one of these assertions (regardless of whether it is an application or
runtime bug), please report it on the <a href="/legion-website-test/community/">bug tracker</a>.</p>

<h3 id="backtrace">Backtrace</h3>

<p>Legion can automatically print a backtrace when an error occurs (such
as an assertion failure or a segfault). This capability has a
negligible performance impact and is therefore recommended in settings
where crashes occur in production applications. Backtraces often
provide initial clues as to where a bug may be hiding, and can direct
further debugging efforts. To enable backtraces, set
<code class="language-plaintext highlighter-rouge">LEGION_BACKTRACE</code> to <code class="language-plaintext highlighter-rouge">1</code> in the environment:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">LEGION_BACKTRACE</span><span class="o">=</span>1 ./app</code></pre></figure>

<p>When using <code class="language-plaintext highlighter-rouge">mpirun</code> as a launcher for the application, remember that a
<code class="language-plaintext highlighter-rouge">-x</code> flag is required to pass the variable to the child process:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mpirun <span class="nt">-x</span> <span class="nv">LEGION_BACKTRACE</span><span class="o">=</span>1 ./app</code></pre></figure>

<p>(Note: <code class="language-plaintext highlighter-rouge">LEGION_BACKTRACE</code> can also be spelled <code class="language-plaintext highlighter-rouge">REALM_BACKTRACE</code>. Both
spellings are identical.)</p>

<h3 id="freeze-on-error">Freeze On Error</h3>

<p>Legion has the ability to freeze the application if it reaches an
error (such as an assertion failure or a segfault). This capability is
particularly useful in multi-node runs and in situations where the bug
might reproduce sporadically. To enable this, set
<code class="language-plaintext highlighter-rouge">LEGION_FREEZE_ON_ERROR</code> to <code class="language-plaintext highlighter-rouge">1</code> in the environment:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">LEGION_FREEZE_ON_ERROR</span><span class="o">=</span>1 ./app</code></pre></figure>

<p>When using <code class="language-plaintext highlighter-rouge">mpirun</code> as a launcher for the application, remember that a
<code class="language-plaintext highlighter-rouge">-x</code> flag is required to pass the variable to the child process:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mpirun <span class="nt">-x</span> <span class="nv">LEGION_FREEZE_ON_ERROR</span><span class="o">=</span>1 ./app</code></pre></figure>

<p>(Note: <code class="language-plaintext highlighter-rouge">LEGION_FREEZE_ON_ERROR</code> can also be spelled
<code class="language-plaintext highlighter-rouge">REALM_FREEZE_ON_ERROR</code>. Both spellings are identical.)</p>

<p>If the application crashes, it will freeze with an message such as the
following. After logging in to the node, it should then be possible to
attach to the process with a debugger. For example:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Process 12345 on node n0123 is frozen!

$ # logged in to n0123
$ gdb -p 12345
...

(gdb) info threads
  12   Thread 0x2b2220e33700 (LWP 2660) "terra" 0x00002b221c15fc6d in poll () at .../syscall-template.S:81
  ...
  4    Thread 0x2b2223fed700 (LWP 2668) "terra" 0x00002b221c1339bd in nanosleep () at .../syscall-template.S:81
  3    Thread 0x2b2223ff5700 (LWP 2669) "terra" pthread_cond_wait@@GLIBC_2.3.2 () at .../pthread_cond_wait.S:185
  2    Thread 0x2b2223ffd700 (LWP 2670) "terra" pthread_cond_wait@@GLIBC_2.3.2 () at .../pthread_cond_wait.S:185
* 1    Thread 0x2b221b23c480 (LWP 2651) "terra" pthread_cond_wait@@GLIBC_2.3.2 () at .../pthread_cond_wait.S:185</code></pre></figure>

<p>(As a hint, the offending thread is usually running <code class="language-plaintext highlighter-rouge">nanosleep</code>. Many
of the other threads are message handers and such and are not useful
for debugging purposes.)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">(gdb) thread 4
(gdb) where
#0  0x00002b221c1339bd in nanosleep () at .../syscall-template.S:81
#1  0x00002b221c133854 in __sleep (seconds=0) at .../sleep.c:137
#2  0x00002b221e2e7246 in Realm::realm_freeze (signal=6) at .../legion/runtime/realm/runtime_impl.cc:85
#3  &lt;signal handler called&gt;
#4  0x00002b221c0a8bb9 in __GI_raise (sig=sig@entry=6) at .../raise.c:56
#5  0x00002b221c0abfc8 in __GI_abort () at abort.c:89
...</code></pre></figure>

<h3 id="privilege-checks">Privilege Checks</h3>

<p>While Legion does have a <a href="/legion-website-test/publications/">type system</a>
capable of statically verifying that all region accesses
abide by the stated privileges requested by a task, these
guarantees are only available for applications written in
Regent. For applications written in C++ that use the Legion runtime
interface directly, we provide a way of dynamically verifying
privileges on all memory accesses.</p>

<p>To enable privilege checks, the <code class="language-plaintext highlighter-rouge">-DPRIVILEGE_CHECKS</code> flag
should be added to the list of compile time flags specified
by the <code class="language-plaintext highlighter-rouge">CC_FLAGS</code> environment variable in Legion application
Makefile. This will enforce a privilege check for every
memory access done through a region accessor. If any privileges
violate the originally requested privileges for the task,
then a runtime error will be raised. Since this check is
performed on every memory access, it can significantly
degrade performance, but is very useful at finding privilege
violations that would traditionally be caught by the
Legion type system.</p>

<h3 id="bounds-checks">Bounds Checks</h3>

<p>In addition to checking the privileges on all memory
accesses, we also provide a mechanism for verifying that
all memory accesses fall within the bounds of the logical
regions requested by a task. This feature is also used
to catch application bugs which would normally be caught
at compile-time by the Legion type system, but which may
escape detection when writing programs directly to the
runtime API. To enable these checks, the <code class="language-plaintext highlighter-rouge">-DBOUNDS_CHECKS</code>
flag should the added to the list of compile time flags
specified by the <code class="language-plaintext highlighter-rouge">CC_FLAGS</code> environment variable in a
Legion application Makefile. We again note that because
these checks are performed on every memory access, they
can significantly degrade the performance of a Legion
application.</p>

<h3 id="partition-checks">Partition Checks</h3>

<p>One of the more commonly occurring bugs in Legion applications
is creating partitions which an application declares to
be disjoint, but for which the provided coloring is not
actually disjoint. For performance reasons, when a call
to <code class="language-plaintext highlighter-rouge">create_index_partition</code> is made, Legion does <em>NOT</em>
check the declared disjointness of the coloring. Instead
the runtime simply trusts the applications to correctly
specify the disjointness of the partition. As users have
experimented with more complicated coloring schemes, we’ve
noticed an increasing number of cases where colorings are
claimed to be disjoint when they actually are not.</p>

<p>To address this problem, we provide the <code class="language-plaintext highlighter-rouge">-lg:partcheck</code>
command line flag which instructs the Legion high-level
runtime to verify the disjointness of all colorings which
are claimed to be disjoint and report a runtime error if
they are not. Depending on the size and type of coloring
as well as the number of colors, these checks can take
arbitrarily long and may degrade performance. Due to the
extreme performance cost associated with these checks, the
<code class="language-plaintext highlighter-rouge">-lg:partcheck</code> flag will issue a warning if it is used in conjuction
with profiling.</p>

<h3 id="legion-spy">Legion Spy</h3>

<p>Legion Spy is a visualization tool for task dependencies. This is
useful for two reasons. First, visualizing dependendencies can help as
a sanity check to confirm that Legion is recording the set of tasks
and dependencies that the user expects. Second, Legion Spy contains a
second implementation of the Legion dependence analysis algorithms,
which it can cross-check against the captured dependencies to verify
the runtime itself.</p>

<p>These modes have slightly different usage patterns, as a full check of
the runtime analysis is relatively expensive.</p>

<p>To use visualize dependencies, run the application with <code class="language-plaintext highlighter-rouge">-lg:spy
-logfile spy_%.log</code>. (No special compile-time flags are necessary.)
This will produce one log file per node. Then run the post-processing
script <code class="language-plaintext highlighter-rouge">legion_spy.py</code> on the log files to generate PDF files of the
various visualizations in the current directory.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./app <span class="nt">-lg</span>:spy <span class="nt">-logfile</span> spy_%.log
legion/tools/legion_spy.py <span class="nt">-dez</span> spy_<span class="k">*</span>.log</code></pre></figure>

<p>(The options used here are <code class="language-plaintext highlighter-rouge">-d</code> for dataflow graph, <code class="language-plaintext highlighter-rouge">-e</code> for event
graph, and <code class="language-plaintext highlighter-rouge">-z</code> to include more information, such as field names.)</p>

<p>To use Legion Spy’s full checking mode, compile with
<code class="language-plaintext highlighter-rouge">CC_FLAGS=-DLEGION_SPY</code> in the environment or at the top of the
application Makefile. Run the application as before, and call the
script with <code class="language-plaintext highlighter-rouge">-lpa</code> (<code class="language-plaintext highlighter-rouge">-l</code> for logical analysis, <code class="language-plaintext highlighter-rouge">-p</code> for physical, and
<code class="language-plaintext highlighter-rouge">-a</code> to assert on failure). (The options <code class="language-plaintext highlighter-rouge">-dez</code> will work as well.)</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">CC_FLAGS</span><span class="o">=</span><span class="nt">-DLEGION_SPY</span> make
./app <span class="nt">-logfile</span> spy_%.log
legion/tools/legion_spy.py <span class="nt">-lpa</span> spy_<span class="k">*</span>.log
legion/tools/legion_spy.py <span class="nt">-dez</span> spy_<span class="k">*</span>.log</code></pre></figure>

<p>The graph below is an example of the output generated by
Legion Spy. Boxes correspond to different kinds of operations while
edges represent explicit event dependences between the different
operations.</p>

<p><img src="/legion-website-test/images/event_graph.jpg" alt="" /></p>

<h3 id="mapper-logging-wrapper">Mapper Logging Wrapper</h3>

<p>When your issue stems from tasks running on the wrong processor or
regions being instantiated in ways not suitable for your application
(e.g. a task’s input being placed on the wrong memory, or with the
wrong layout, or covering more of the index space than needed, or
having multiple copies when only one is needed) this is likely due to
the mapper making the wrong decision. You can confirm this by using
the <code class="language-plaintext highlighter-rouge">LoggingWrapper</code> class to record the decisions of the mapper,
and the characteristics of the <code class="language-plaintext highlighter-rouge">PhysicalInstance</code>s it creates.</p>

<p>To use with your own mapper, include <code class="language-plaintext highlighter-rouge">runtime/mappers/logging_wrapper.h</code>,
replace any use of <code class="language-plaintext highlighter-rouge">new MyMapper(...)</code> in your code with
<code class="language-plaintext highlighter-rouge">new LoggingWrapper(new MyMapper(...))</code> and run with <code class="language-plaintext highlighter-rouge">-level mapper=2</code>.
Enabling Realm-level instance reporting might also be useful (<code class="language-plaintext highlighter-rouge">-level inst=1</code>).</p>

<p>If you are not already using a custom mapper, you can define something like
the following:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_mappers</span><span class="p">(</span><span class="n">Machine</span> <span class="n">machine</span><span class="p">,</span> <span class="n">Runtime</span><span class="o">*</span> <span class="n">rt</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;&amp;</span> <span class="n">local_procs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">rt</span><span class="o">-&gt;</span><span class="n">replace_default_mapper</span><span class="p">(</span><span class="k">new</span> <span class="n">LoggingWrapper</span><span class="p">(</span><span class="k">new</span> <span class="n">DefaultMapper</span><span class="p">(</span>
    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">get_mapper_runtime</span><span class="p">(),</span> <span class="n">machine</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">local_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">()))));</span>
<span class="p">}</span></code></pre></figure>

<p>and invoke <code class="language-plaintext highlighter-rouge">Runtime::add_registration_callback(update_mappers)</code> at some
point before the runtime is started, e.g. in <code class="language-plaintext highlighter-rouge">main</code> right before calling
<code class="language-plaintext highlighter-rouge">Runtime::start(...)</code>.</p>

<h2 id="other-debugging-options">Other Debugging Options</h2>

<h3 id="logging-infrastructure">Logging Infrastructure</h3>

<p>Legion has a sophisticated logging infrastructure with support for
logging levels and categorization of messages. Logging is done using
static singleton objects called <em>loggers</em>. Each category of message is
declared as a static singleton object. For example, near the top of
the default mapper implementation in <code class="language-plaintext highlighter-rouge">default_mapper.cc</code> we create the
following logger category:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Logger</span><span class="o">::</span><span class="n">Category</span> <span class="nf">log_mapper</span><span class="p">(</span><span class="s">"default_mapper"</span><span class="p">);</span></code></pre></figure>

<p>Loggers can be used in either printf style or C++ ostream style. The
exact invocation depends on the desired logging level. For example:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// printf-style</span>
<span class="n">log_mapper</span><span class="p">.</span><span class="n">warning</span><span class="p">(</span><span class="s">"hello printf %e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">);</span>
<span class="c1">// C++ ostream style</span>
<span class="n">log_mapper</span><span class="p">.</span><span class="n">debug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"hello ostream"</span> <span class="o">&lt;&lt;</span> <span class="mf">3.14</span><span class="p">;</span> <span class="c1">// no endl</span></code></pre></figure>

<p>Legion supports six levels of logging (in order from lowest priority
to highest): <code class="language-plaintext highlighter-rouge">spew</code>, <code class="language-plaintext highlighter-rouge">debug</code>, <code class="language-plaintext highlighter-rouge">info</code>, <code class="language-plaintext highlighter-rouge">print</code>, <code class="language-plaintext highlighter-rouge">warning</code>, and <code class="language-plaintext highlighter-rouge">error</code>.</p>

<p>Message filtering of different levels is controlled simultaneously by
a static and a dynamic switch.  First, the Makefile variable
<code class="language-plaintext highlighter-rouge">OUTPUT_LEVEL</code> places a static lower bound on which messages can be
emitted. Any messages below this level are guaranteed to be statically
elided by the compiler to avoid any runtime overhead. The logging
level can also be controlled dynamically by a command line
argument. Passing the <code class="language-plaintext highlighter-rouge">-level [&lt;category&gt;=]&lt;int&gt;</code> flag on the command
line will dynamically set the minimum (inclusive) logging level for
the specified category (or if omitted, all categories), with 0
corresponding to <code class="language-plaintext highlighter-rouge">spew</code> and 5 corresponding to <code class="language-plaintext highlighter-rouge">error</code>.</p>

<p>By default, logging messages are emitted to <code class="language-plaintext highlighter-rouge">stderr</code>. Often it is
desirable to log output to a file (or a file per node) instead. The
<code class="language-plaintext highlighter-rouge">-logfile</code> flag can be used to specify a filename for the logs. A <code class="language-plaintext highlighter-rouge">%</code>
character in the name (if any) will be replaced by the node number
(resulting in one log file per node).</p>

<p>For example, the command line below sets a logging level of 4 for
<code class="language-plaintext highlighter-rouge">tasks</code>, 2 for <code class="language-plaintext highlighter-rouge">legion_spy</code>, and 3 for everything else, and directs
output to a series of files <code class="language-plaintext highlighter-rouge">prof_0.log</code>, <code class="language-plaintext highlighter-rouge">prof_1.log</code>, etc. for each
node.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./app <span class="nt">-level</span> <span class="nv">tasks</span><span class="o">=</span>4,legion_spy<span class="o">=</span>2,3 <span class="nt">-logfile</span> prof_%.log</code></pre></figure>

<h3 id="debug-tasks">Debug Tasks</h3>

<p>One very useful debugging technique that we have
found has been the ability to use <em>debug tasks</em>
as a means of introspecting Legion applications.
Due to the out-of-order nature of Legion task
execution, using a traditional debugger like <code class="language-plaintext highlighter-rouge">gdb</code>
to debug a single-node Legion application can be
challenging. To aid in setting break-points and
checking conditions in association with a debugger
we commonly inject explicit debug tasks which are
either empty tasks or tasks which do not impact
correctness and simply check for certain conditions
regarding the data in logical regions. One example of
a kind of debugging task can be seen in our
<a href="/legion-website-test/tutorial/circuit.html">full circuit simulation</a>
example which has optional checking tasks for
verifying that there are no <code class="language-plaintext highlighter-rouge">NaN</code> or <code class="language-plaintext highlighter-rouge">Inf</code> values
in our simulation.</p>

<p>Debug tasks are a very useful tool as they can request
their own privileges and logical regions for introspecting
all or a subset of an applications data.  Similarly by
changing privileges and coherence modes, debug tasks
can control where they are run in the order of execution
of tasks. We routinely launch debug tasks which declare
stronger privileges than necessary (e.g. <code class="language-plaintext highlighter-rouge">READ-WRITE</code>
instead of <code class="language-plaintext highlighter-rouge">READ-ONLY</code>) in order to prevent any later
tasks from running in parallel.</p>

<p>In practice, the ability to launch debug tasks is one of
the most useful features of Legion, enabling introspection
that can be easily enabled and disabled without worrying
about correctness. Really, debug tasks are just a very
primitive form of <code class="language-plaintext highlighter-rouge">in-situ</code> analytics.</p>

<h3 id="delay-start">Delay Start</h3>

<p>In some cases it can be useful to attach a debugger to a program prior
to the point where it actually fails. This can be challenging
particularly in multi-node executions where the user cannot simply run
<code class="language-plaintext highlighter-rouge">gdb --args ./app ...</code>. To assist in such cases, Legion provides an
option to pause at the beginning of an application run. The user can
then use the delay to manually attach to the process with a debugger.</p>

<p>The following command will cause Legion to pause for 30 seconds prior
to starting the top-level task:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./app <span class="nt">-lg</span>:delay 30</code></pre></figure>

<p>The user can use this opportunity to find the appropriate PID and
attach with a debugger. For example, assuming that <code class="language-plaintext highlighter-rouge">ps</code> reports that
the PID is <code class="language-plaintext highlighter-rouge">12345</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ps <span class="nt">-u</span> <span class="si">$(</span><span class="nb">whoami</span><span class="si">)</span>
gdb <span class="nt">-p</span> 12345</code></pre></figure>

<p>After entering the debugger, the user can set breakpoints or configure
settings as appropriate, and then when ready can issue the command
<code class="language-plaintext highlighter-rouge">continue</code> to resume execution of the application.</p>

<h3 id="in-order-execution">In-Order Execution</h3>

<p>While the goal of the Legion runtime is to implicitly
discover parallelism between tasks and other operations,
in many cases, when debugging a Legion application, it is
useful to know that operations are actually executed
in the order in which they are issued. This can be useful
both for debugging Legion application code, as well as
for investigating runtime bugs. To enable this feature,
execute the application with the command-line flag <code class="language-plaintext highlighter-rouge">-lg:inorder</code>.
When running
in this mode sub-tasks and other operations launched
within a parent task will be issued and run to completion
before the next operation is issued. This guarantees
that all operations are performed in program
order with no parallelism being extracted.</p>

<h3 id="full-size-instances">Full-Size Instances</h3>

<p>Another useful debugging tool available is the ability
to create <em>full-size</em> physical
instances. In many cases, the Legion runtime only
allocates space for the data requested by a task based
on its logical region usage. If the requested logical
regions are not the top-level logical regions in the
region tree, the Legion runtime will trim the physical
instances to only store the necessary data.</p>

<p>In the past, trimming physical instances has resulted
in two kinds of bugs. First, applications which do
not access data within the their logical region bounds
(e.g. those that fail bounds checks), have caused
random memory corruption by reading and writing in
locations not actually intended. Second, trimming has
in the past been a source of runtime bugs as it is
difficult to ensure all the Legion copy routines
properly recognized trimmed physical instances.</p>

<p>To help discover both types of bugs, the Legion
runtime can be compiled with the <code class="language-plaintext highlighter-rouge">-DFULL_SIZE_INSTANCES</code>
compile-time flag set in the <code class="language-plaintext highlighter-rouge">CC_FLAGS</code> of a
Legion application Makefile. This feature forces the
Legion runtime to always allocated physical instances
of the size of the top-level logical region in the
region tree. This prevents out-of-bounds memory accesses
from corrupting other instances and can aid in finding
runtime errors. If an application runs correctly
with <code class="language-plaintext highlighter-rouge">-DFULL_SIZE_INSTANCES</code> and passes all bounds
checks then it is likely a runtime bug and should
be reported on the
<a href="https://github.com/StanfordLegion/legion/issues">bug tracker</a>.</p>

<h3 id="separate-runtime-instances">Separate Runtime Instances</h3>

<p>When debugging messaging protocols within the
Legion runtime, it can be challenging to
attach debuggers to processes on different
nodes. To make debugging these protocols simpler,
Legion supports a modified execution setup.
By default, there is only ever a single Legion
runtime instance per process (and by default
per node since we usually only launch a single
Legion process on each node). To support debugging
these messaging protocols on a single node, we
provide an execution setup where an instance
of the Legion runtime is created for each
individual processor in the machine. This
creates multiple instances of the Legion runtime
within a single process. Under this setting
messages are then used to communicate between
the different runtime instances (just as they
would be in the truly distributed case). This
allows a single debugger to be attached
to a process on a single node and observe
the different runtime instances. This setting
can be enabled by passing the flags <code class="language-plaintext highlighter-rouge">-lg:separate -ll:util 0</code>
on the command line. (The <code class="language-plaintext highlighter-rouge">-ll:util 0</code> is required because this mode
does not support execution with explicit utility processors.)</p>

<h3 id="dump-backtraces">Dump Backtraces</h3>

<p>When debugging a freeze in Legion, the first step should always be to
dump backtraces on all nodes. This will help determine (a) if the
application is truly frozen or simply executing slowly, and (b)
whether there are any obvious or unusual functions on the stack traces
that may point to a possible cause.</p>

<p>One complicating factor is that Legion employs user-level threads by
default. Therefore, in order to get useful backtraces, it is necessary
to use the flag <code class="language-plaintext highlighter-rouge">-ll:force_kthreads</code> to disable user-level threads:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./app <span class="nt">-ll</span>:force_kthreads
<span class="c"># wait for the application to freeze</span>
gdb <span class="nt">-p</span> 12345
thread apply all bt <span class="c"># inside gdb, dump backtraces</span></code></pre></figure>

<p>Note also that it is important to compile with debug symbols or else
line numbers will not appear in the resulting backtraces. This can be
accomplished by running in <a href="#debug-mode">debug mode</a> (which is
recommended anyway), or if the freeze does not reproduce in debug
mode, Legion can be compiled with <code class="language-plaintext highlighter-rouge">-Og -ggdb</code> or similar to ensure
that debug symbols are available.</p>

<h3 id="dump-events">Dump Events</h3>

<p>When debugging a freeze, if dumping backtraces fails to provide
insight, then it can be helpful to dump the Realm event graph to
determine if a cycle has formed.</p>

<p>Realm can be configured to do this after a fixed delay. For example,
if you observe that the application is reliably frozen after 60
seconds, then you can do:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">REALM_SHOW_EVENT_WAITERS</span><span class="o">=</span>60+5
./app</code></pre></figure>

<p>In a multi-node job, rank <code class="language-plaintext highlighter-rouge">i</code> will print its events at time
<code class="language-plaintext highlighter-rouge">60+5i</code>. This allows the printing to be staggered so that the results
do not get corrupted. Alternatively, one can use the job scheduler to
send <code class="language-plaintext highlighter-rouge">stdout</code> to a different file for each rank (e.g.,
<code class="language-plaintext highlighter-rouge">--output events_%t.log</code> in SLURM).</p>

<h4 id="dumping-events-with-a-debugger">Dumping Events with a Debugger</h4>

<p>There is an older method of dumping events which is no longer
recommended in general, but has the advantage that it can be triggered
interactively (so you can wait until the job actually freezes). This
method is described below.</p>

<p>Note in order for this to work,
Legion <em>must</em> be compiled with debug symbols (<code class="language-plaintext highlighter-rouge">-Og -ggdb</code> or
similar). <a href="#debug-mode">Debug mode</a> is not required.</p>

<p>To dump the events, run the application and wait for it to
freeze. Then attach with a debugger and call the function
<code class="language-plaintext highlighter-rouge">Realm::realm_show_events(0)</code>. The environment variable
<code class="language-plaintext highlighter-rouge">REALM_SHOW_EVENT_FILENAME</code> controls where the resulting log files are
stored.</p>

<p>Using gdb, this might look like:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">REALM_SHOW_EVENT_FILENAME</span><span class="o">=</span><span class="nv">$PWD</span>/events.txt
./app
<span class="c"># wait for the application to freeze</span>
gdb <span class="nt">-p</span> 12345
call Realm::realm_show_events<span class="o">(</span>0<span class="o">)</span></code></pre></figure>

<p>This should result in a file called <code class="language-plaintext highlighter-rouge">events.txt</code>. This file can be
processed by a Legion tool called <code class="language-plaintext highlighter-rouge">detect_loops</code> to look for cycles in
the event graph:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nt">-C</span> legion/tools detect_loops
legion/tools/detect_loops event.txt</code></pre></figure>

<p>If a cycle is found it will be displayed on stdout.</p>

<h3 id="trace-memory-allocations">Trace Memory Allocations</h3>

<p>This is a tool for checking the number of internal Legion objects
allocated over time, and their total memory usage.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">CC_FLAGS</span><span class="o">=</span><span class="nt">-DTRACE_ALLOCATION</span> make
./app <span class="nt">-level</span> <span class="nv">allocation</span><span class="o">=</span>2</code></pre></figure>

<p>Legion will periodically print the total number of internal Legion
objects that have been allocated, their total memory usage, and the
difference (in number and size) compared to the last snapshot.</p>

<h3 id="legion-gc">Legion GC</h3>

<p>This is a tool for checking for application leaks of Legion API
objects or handles.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">CC_FLAGS</span><span class="o">=</span><span class="nt">-DLEGION_GC</span> make
./app <span class="nt">-level</span> <span class="nv">legion_gc</span><span class="o">=</span>2 <span class="nt">-logfile</span> gc_%.log
legion/tools/legion_gc.py <span class="nt">-l</span> gc_<span class="k">*</span>.log</code></pre></figure>

<p>This tool will print a message if any objects are leaked by the
application.</p>

    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2023 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/legion-website-test/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/legion-website-test/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>
